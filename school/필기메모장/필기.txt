http://naver.me/FpZHfhxW




<조건문 형식>

if (조건) {
	실행문들;
}


if () {
	실행문들;
	...;
} else if() {
	실행문들;
	...;
} else {
	실행문들;
	...;
}



switch (케이스값- byte, short, int, char, String) {
case 1: 실행문; 
	break;
case 2: 실행문; 
	break;
case 3: 실행문; 
	break;
default: 실행문;
}



<변수 선언 형식>

//선언만
자료명 변수명;


//선언과 동시에 초기화
자료명 변수명 = 값(리터럴 = Literal);


//자료형이 같은 변수를 동시에 선언 후 초기화
자료명 변수명1, 변수명2, 변수명3;
변수명1 = 값(리터럴);
변수명2 = 값;
...


//자료형이 같은 변수를 동시에 선언 및 초기화
자료명 변수명1 = 값(리터럴), 변수명2 = 값, ...;



<반복문 형식>

//for문
for (초기식; 조건식; 증감식) {
	실행문들;
	...;
}


//for무한반복문
for ( ; ; ) {
	실행문들;
	...;
}


//while문
기준식;
while (조건식) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//while무한반복문
while (true) {
	실행문들;
	...
	제어식이나 제어어(break);
}


//do~while문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (조건식);


//do~while무한반복문
기준식;
do {
	실행문들;
	...
	제어식이나 제어어(break);
} while (true);



<상수(Constant)>

final 자료형 상수명 = 값(리터럴);
**반드시 대문자로 상수명 기술, 반드시 선언과 동시에 초기화



<배열>

같은 자료형을 가진 여러 개의 요소를 묶어놓은 집합체 형식

//선언
1. 자료형[] 참조변수명; (기본)
2. 자료형 참조변수명[];

//공간생성, 초기화

변수명 = new 자료형[] {값1, 값2, ...};
ㅡㅡㅡㅡㅡ


//선언 및 공간생성(메모리 할당)

자료형[] 변수명 = new 자료형 [방개수];

//초기화 
변수명[인덱스번호(방번호)] = 값1;
변수명[인덱스번호(방번호)] = 값2;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)

자료형[] 변수명 = {값1, 값2, ...};
**new가 포함되어 있으며, 처음 설정한 값(요소)의 개수만큼 방 크기가 고정된다.



//new키워드
1. 데이터를 저장할 수 있는 공간을 만들어주세요.
2. 해당 공간에 해당 자료형(참조변수)의 내용을 복사해서 붙여넣어주세요.


//방번호, 방순서 = 인덱스 : 0 ~
//방크기, 방길이 = length



<지역인 경우>

변수와 배열객체의 요소값의 차이점
**변수는 지역일 경우 반드시 초기값 설정이 되어야 한다.
**배열객체는 지역일 경우 값이 없으면 자동으로 초기값 설정이 된다.

//자동 초기화 값

byte, short, int => 0
long => 0L
float => 0.0f
double => 0.0
char => '\n0000' (공백한칸)
String 자료형 포함 모든 참조자료형 => null



<for확장형>

//형식

배열변수
for (자료형 변수명 : 배열객체명) {

}

//예

int[] c = {1, 2, 3, 4, 5};
for (int i : c) {
	System.out.print(i + " ");
}

=> 1 2 3 4 5 




<이차원 배열>

행과 열로 이루어진 배열(바둑판)

//선언 및 행, 열 공간할당
자료형[][] 변수명 = new 자료형[행개수][열개수];


//초기화
변수명[행인덱스번호][열인덱스번호] = 값;
...
ㅡㅡㅡㅡㅡ

//선언 및 행 공간할당
자료형[][] 변수명 = new 자료형[행개수][];

//열 공간할당
변수명[행인덱스번호] = new 자료형[열인덱스번호];
...

//초기화
변수명[][] = 값;
...
ㅡㅡㅡㅡㅡ

//단축형식 (선언 및 공간생성, 초기화)
변수명[][] = {{값1, 값2, ...}, 
	{값1, 값2, ...}
}


//자료형[행][열] => 행 = row, 열 = column












<메소드(method)>

자바의 클래스에서 기능을 처리할 수 있도록 해주는 역할.
**리턴타입 기술부 필수.


//형식 (메소드 선언)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수자료형 매개변수명, ...]){
	실행문들;
	.
	.
	.
	[return 리턴할 값;]
}

//메소드 선언 기능

1. 자바의 메소드는 반드시 선언이 되어 있어야 사용가능.
2. 메소드는 무조건 호출을 해야 실행된다.(자동실행x)
**단 main메소드는 JVM이 실행.



//형식 (메소드 호출)

메소드명([매개값...]);


//메소드 호출 기능

1. 메소드를 실행시킴.
2. 리턴 값을 받는 공간.


//메소드 호출 시 지켜야 할 사항

1. 메소드의 이름
2. 메소드의 매개변수 개수
3. 메소드의 매개변수 자료형
4. 메소드의 매개변수 나열순서(선언된 자료형 순서대로, 자료형 개수 만큼)




<메소드 오버 로딩(Over Loading>

동일한(같은) 이름의 메소드를 한 클래스에 여러개 만들어 두는것 (여러개 쌓아두는 것)


//조건

1. 반드시 매개변수의 개수가 달라야함
2. 반드시 매개변수의 자료형이 달라야함
3. 매개변수의 개수와 자료형이 일치하면, 반드시 나열순서가 달라야 한다.
4. 메소드의 이름이 동일해야 한다.




<클래스>

자바에서 데이터를 담기 위한 속성들(변수, 상수, 객체)과 어떠한 명령들을 처리하기 위한 기능들(메소드들, 생성자들, 초기화 블럭)의 집합
자바 파일의 최소 단위
**클래스에 멤버 - 속성, 메소드, 생성자, 초기화블럭 (4개뿐)


//클래스의 형식
[접근제어자] class 클래스명 {

	[접근제어자] [기타제어자] 자료명 -변수명;
			        -변수명 = 값;
	         예) filnal int MAX = 100;
		int max = 50;
		int[] marr = new int[3];
		String str = " ";
}



//초기화 블럭

[static] {
	실행문들;

}

[접근제어자] [기타제어자] 리턴타입 메소드명() {
	실행문들;
	[retuen = 값];
}



//생성자

[접근제어자] 클래스명() {
	실행문들;

}




- 일반 클래스

main 메소드 없음


- 메인 클래스 

main 메소드 있음



- 속성 : 필드, 컬럼, 멤버 변수, 인스턴스 변수, Attribute, property



<변수의 종류>

//생명주기

- 전역변수 

전역에 사용되는 변수
프로그램이 실행되어 선언된 시점부터 프로그램이 종료될 때 까지 살아있는 변수
(멤버변수, 등)

선언만 되어있으면 자동초기화 됨
동일한 이름으로 재선언이 한번 가능함


- 지역변수

지역 내부 안에서만 살아있는 변수
(메소드, 생성자, 반복문, 조건문(제어문))

동일한 이름으로 재선언이 불가능함



객체지향언어 (Object Oriented Programming language)
 자바



<객체선언 형식>

자료형 참조변수명 = new 자료형명();
ㅣ                    ㅣ ; (-선언)	         (-공간할당)
ㅣ	         ㅣ
ㅣ	         ㅣ
클래스급이상    ㅣ
	       (= 객체명, 인스턴스명 -> 주소값 저장)



- 인스턴스 : 원본 클래스 복제 후 메모리에 저장



변수선언 및 값 할당
//변수를 만들 수 있는 자료형: 기본자료형(byte, short, int, long, char, float, double)
자료형 변수명 = 값;

객체선언 및 공간 할당(클래스복제 = 인스턴스)
//객체를 만들 수 있는 자료형
//자바에서 제공해주는 자료형(예: String), 
//우리가 직접 만든 클래스
자료형(class이상) 객체명 = new 자료형(); //자료형() => 생성자호출문





<한 개의 java파일에 여러 개의 클래스를 기술할 때 public키워드를 붙일 수 있는 조건>
**클래스명과 자바파일의 이름이 동일해야한다.
 

- 일반클래스와 메인클래스가 섞여 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 반드시 메인클래스를 선언하는 곳의 접근제어자가 public 이어야 한다.
3. 파일명은 public키워드가 붙어있는 클래스의 이름과 동일해야 한다.


- 일반클래스들만 여러 개가 있는 경우

1. 반드시 여러 개의 클래스 중에서 한 개의 클래스만 public키워드를 붙일 수 있다.
2. 파일명과 동일한 이름의 클래스에만 public키워드를 붙일 수 있다.




<클래스의 멤버로 존재할 수 있는 것>
1. 속성(변수, 상수, 객체)
- 기능
2. 메소드
3. 초기화블럭
4. 생성자



<생성자(Constructor)>

클래스에서 인스턴스(객체)를 생성할 수 있도록 도와주는 기능을 처리함.
**생성자의 목적 : 클래스안의 멤버필드(속성)의 초기화를 진행.

1. 반드시 클래스명과 동일해야 한다.
2. 반드시 리턴타입을 기술하는 기술부 자체가 없다.
3. 객체생성문에서 new키워드 뒤에 호출이 된다.
ex) ExClass ec = new ExClass();
		ㄴ생성자호출문

4. 클래스안에 기술된 생성자가 한 개도 없으면 기본생성자가 숨어있다.
- 숨어있는 기본 생성자 :
	public 클래스명(){}
**숨어있는 기본 생성자의 접근제어자는 public, 직접 기술한 기본 생성자의 접근제어자는 다 가능.


5. 클래스안에 기타생성자가 한 개라도 기술되어있으면 기본생성자는 사라진다.
**기본생성자를 사용하려면 반드시 기본생성자도 기술해줘야 한다.



- default (기본) 생성자 형식 (매개변수가 없음.)

// public 클래스명() {}

[접근제어자] 클래스명() {
	실행문들;

}



- 기타 생성자 형식 (매개변수가 있음.)

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}





//형식

[접근제어자] 클래스명([매개변수...]) {
	실행문들;

}


vs

(메소드 형식)

[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수...]){
	실행문들;
	.
	.
	[return 리턴할 값;]
}



//생성자 오버로딩 조건

**메소드 오버로딩 조건 모두 포함
**이름은 반드시 클래스명과 동일해야 한다.



//생성자호출문의 기능

1. 클래스를 복제한다. (= 객체생성)
2. 생성자안의 명령문 실행





<this키워드> : 기술할 수 있는 곳 - 메소드안, 생성자안 (순서x)

- this키워드는 반드시 멤버 앞에만 붙일 수 있다
- 단위가 객체이다
- 지역 앞에 붙을 수 없다
- (나를) this키워드를 감싸고 있는 멤버필드의 객체
- (나의) this키워드를 가지고 있는 인스턴스



<this()> 기술할 수 있는 곳 - 생성자안

1. 반드시 나와는 다른 생성자를 호출하는 호출문이어야 한다.
2. 반드시 생성자 안의 맨 처음 명령에 한번만 가능하다. 


//this();
인스턴스 기본생성자 호출문

//this(매개변수);
인스턴스 해당 케이스의 생성자 호출문 




 
- 비교대상이 변수인 경우는 == (동등비교연산자)의 의미는 값을 비교하는 연산자  (변수 - 값을 저장)
- 비교대상이 객체인 경우는 == (동등비교연산자)의 의미는 주소값을 비교하는 연산자 (객체 - 주소값을 저장)





<캡슐화(Encapsulation)> : 바로 노출되는 변수나 객체를 한 번 더 감싸서 직접 노출을 막기 위해 감싸는 것 (감싸는 기본 단위가 클래스)



<정보은닉(Imformation Hiding) = 보안> 
- 외부에서 멤버에 직접 접근을 하지 못하도록 막는 것(숨기는 것).
- 반드시 멤버필드의 접근제어자가 private가 되어야 한다.
- 반드시 멤버필드의 값을 가져오기 위해서는 반환값을 돌려줄 수 있는 public 메소드가 존재해야 한다.
							[default] 메소드도 가능은 하지만, public 권장




<접근제어자(Access Modifier)> : public > protected > default > private   (ppdp)
 


<import키워드>

나와 다른 패키지 안의 클래스나 메소드를 끌어올 때 소속을 명시하는 부분.

//형식

import 패키지경로.클래스명;
import 패키지경로.경로.경로...클래스명;



<객체(Object)> : 자바의 최상위 객체

어떠한 것을 독립적으로 표현할 수 있는 대상





메소드호출문
1. 메소드 실행
2. 리턴값이 있으면 그 값의 저장 공간


생성자호출문
1. 생성자 실행
2. 해당 케이스의 명령문 실행





<기타제어자 (Modifier)>

- final => ~할 수 없는, ~하지 못하는

- static => 정적(고정된), 공유 되는, 객체생성 없이 클래스 이름으로 접근 가능한 
							|
							ㄴ static메소드 안에서 this 대신 클래스 이름

- abstract => 추상적인, 몸체가 없는, 반드시 재정의 해야하는




<static 제어자>

static 키워드를 붙일 수 있는 것 : 멤버필드(속성), 메소드, 초기화블럭, 지역한텐 못씀

(static-멤버로 위장)

static메소드 안에서 멤버필드(속성)나 메소드를  호출, 선언 하려면 static키워드가 붙어있는 애들만 가능



(메모리 영역 - Method = static = class = 정적)





생성문에는 중괄호가 붙는다 / 이때 중괄호를 몸체라고 부름




<싱글톤패턴(Singleton)>
반드시 객체를 한 개만 생성하도록 강제적으로 제한하는 패턴(형식, 정해진것)


//조건
1. 반드시 private static 키워드와, 자료형이 내 자신의 클래스인 => 속성 하나가 선언되어야 한다.
2. 반드시 1번의 필드를 반환해주는 pubilc static 키워드가 붙은 getter메소드가 있어야 한다.
3. 반드시 생성자들의 접근제어자가 private으로 되어야 한다.




<변수들의 생명주기>
- 지역 변수
(탄생) : 지역변수가 선언된 시점
(죽음) : 지역변수가 포함된 메소드나 생성자의 명령이 모두 종료된 후

- 인스턴스 변수
(탄생) : 인스턴스가 선언된 시점(= 객체가 선언된 시점)
(죽음) : 인스턴스가 소멸되는 시점

- static변수 = 클래스변수 = 정적변수
(탄생) : 클래스가 메모리에 올라가는 시점부터(= 프로그램이 실행되는 시점)
(죽음) : 프로그램이 종료되는 시점





<UML(통합 모델링 언어, Unified Modeling Language)>

개발자가 필요한 요소들 정리
요소들의 관계 정리
요소들의 흐름들을 도식화(깔끔하게 양식화) 할때 사용하는 다이어그램

- 클래스 다이어그램 : 클래스, 인터페이스, 추상클래스 들 안에 필요한(속성,기능 정리) 조건 관리
		    해당 요소들간의 관계 정리

- 시퀀스 다이어그램 : 요소들이 어떻게 흐르는지의 절차를 정리




<클래스 다이어그램>

- 속성(변수, 상수, 객체)과 기능(메소드, 생성자)들을 보기 쉽게 정리하는 것
- 사각형으로 그려서 정리한다.
- 기술하는 방법이 정해져있다.





<String>


- String은 고정형 자료형이기 때문에 값이 변경되면 주소값도 변경된다
- String으로 만든 객체는 주소값이 아닌 값을 출력
- String에서 제공하는 모든 메소드는 원본 훼손이 일어나지 않는다


//String에서 제공하는 메소드(배운것들 작성) (String메소드)

- .concat("문자열")
해당 문자열을 문자열객체 뒤에 추가하는 메소드

- .length()
문자열의 길이 메소드

- .trim()
왼쪽 끝과 오른쪽 끝에 있는 공백 제거하는 메소드

- .charAt(값1)
값1에 해당되는 인덱스번호의 문자를 가져오는 메소드

- .substring(값1)
값1에 해당되는 인덱스번호부터 끝까지의 문자열을 가져오는 메소드

- .substring(값1, 값2)
값1에 해당되는 인덱스번호부터 값2 마이너스 1을 한 인덱스번호까지의  문자열을 가져오는 메소드

- .contains("문자열")
해당 문자열이 있는지 묻는 메소드 (리턴타입 boolean)

- .replace(a, b)
a를 b로 바꾸는 메소드

- .replaceAll([aaa], b)
[aaa]에서 a,a,a 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .replaceAll([^aaa], b)
[^aaa]빼고 나머지를 하나하나 b로 바꾸는 메소드
**[ ]는 replaceAll에서만 사용가능

- .startsWith(문자열)
해당 문자열이 접두사인가
boolean으로 리턴

- .endsWith(문자열)
해당 문자열이 접미사인가
boolean으로 리턴

- .indexOf(문자열) : 해당 문자열의 맨 앞글자를 왼쪽에서부터 찾아서 해당 인덱스를 반환함.

- .indexOf(문자열, 인덱스번호) : indexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 오른쪽으로 찾는다.

- .indexOf(아스키코드) : 해당 아스키코드 값에 문자를 찾아 인덱스를 반환함.

- .lastIndexOf(문자열) : 해당 문자열의 맨 앞글자를 오른쪽에서부터 찾아서 해당 인덱스를 왼쪽에서부터 세어 반환함.

-.lastIndexOf(문자열, 인덱스번호) : lastIndexOf(문자열)과 동일한데 해당 인덱스번호를 시작지점으로 인식하여 왼쪽으로 찾는다.

- .toUpperCase() : 싹 대문자로

- .toLowerCase() : 싹 소문자로

- .compareTo(문자열) : 문자열 비교, 값을 int로 반환

- .compareToIgnoreCase(문자열) : 비교 문자열의 대소문자를 똑같다 치고 compareTo(문자열) 함



- 패키지(클래스를 묶어놓은 집합체)
- import(다른 패키지를 끌어오세요)
- * (아스테리스크, 전체) 패키지안에 있는 모든 클래스에 import
	ex) import 패키지명.*


<Wraper클래스>

기본자료형을 클래스화 시켜놓은 자료형
String과 마찬가지로 특이클래스, 값이 바뀌면 주소값도 변경된다.

기본자료형 -> Wraper클래스 : Boxing (UpperCase)

Wraper클래스 -> 기본자료형 : Unboxing (LowerCase, DownCase)


숫자<>문자 형변환 할땐 클래스급으로 => (기본자료형 -> Wraper클래스 : Boxing)


기본자료형 <-> Wraper클래스  :  지들끼린 자동형변환 가능.

기본자료형을 Wraper클래스로 만드는 이유 >> 기본자료형의 Wraper클래스에 메소드를 사용하기 위함




<동일한 메소드 : 메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드>



<상속(inheritance)>

나의 기능을 확장(extends), 나의 기능을 실체화(implements, realization)
부모에게서 물려 받은 것을 자식에게서도 사용할 수 있도록 하는것.

부모 : Super, 상위, 기본
자식 : Sub, 하위, 파생

//형식
확장(extends) : 반드시 부모와 자식이 동급인 경우
ex) 부모(클래스) 자식(클래스) / 부모(인터페이스) 자식(인터페이스)
public class ChildrenClass(자식클래스) extends ParentClass(부모클래스) { }
public interface ChildrenInterface (자식인터페이스) extends ParentInterface (부모인터페이스) { }

실체화(implements) : 부모와 자식이 급이 다른 경우, 인터페이스는 클래스를 상속 받을 수 없다.
public class ChildrenClass(자식클래스) implements ParentClass(부모클래스) { }


클래스급이상(클래스, 추상클래스, 인터페이스)인 경우 형변환은 반드시 상속관계에서만 형변환이 가능하다. 
아니면 String <> Wraper클래스 간 메소드를 이용해서 형변환

<상속 - 다형성(polymorphism)>

하나의 객체가 여러개의 자료형을 가지고 있는 것을 말함
=> 상속, 형변환 을 말함 => 필요한 이유는 메모리 낭비를 줄일 수 있다.

부모는 여러 자식을 품을 수 있음
자식은 부모를 품을 수 없음
자식은 지가 다 가질라함 -> 부모 Hiding, 부모꺼 내꺼처럼


<pacha케이스>
같은 이름 속성 : 부모것만		같은 이름 메소드 : 자식것만	(static메소드는 이름 같아도 부모것만)
다른 이름 속성 : 부모것만		다른 이름 메소드 : 부모것만

<chacha케이스>
같은 이름 속성 : 자식것만		같은 이름 메소드 : 자식것만
다른 이름 속성 : 부모자식 모두	다른 이름 메소드 : 부모자식 모두

상속관계에서도 오버로딩이 존재한다.
ex) 
(부)
public void md( ) //Hiding
public void md1(int a) -이놈
(자)
public void md( ) //Overriding -이놈
public void md1(String a) -이놈

이놈들 => 상속관계에서의 메소드 오버로딩




<오버라이딩(Overriding) 오버라이드(Override)>

부모와 자식간에 동일한 이름의 메소드가 존재하는 경우 자식의 메소드로 재정의(덮어쓰기) 되는 현상
(해당 메소드의 부모의 접근제어자 이상의 접근제어자를 사용해야 함)



부모와 자식관계에서 동일한 이름의 메소드가 있는 경우(매개변수까지 같은 동일 메소드)
부모 메소드가 가려지고(Hiding) 자삭의 메소드로 재정의(덮어쓰기) 되는 현상

//조건 
1. 반드시 상속관계가 존재해야 한다
2. 반드시 부모와 메소드가 동일해야 한다(매개변수까지 같은 동일 메소드)
3. 반드시 접근제어자가 부모 이상의 접근제어자로 선언되어야 한다
4. *********반드시 재정의(덮어쓰기) 되기 위해서는 리턴타입까지 동일해야 한다 (2번이랑 같은 말)

*private 처리된 부모의 속성은 상속되지 않는다




<Super키워드>

상속관계가 있을 때 부모 클래스에 호출(접근)하는 키워드
this키워드와 조건이 비슷함

super키워드 : 부모 인스턴스

super( ) 호출문 : 부모 인스턴스 안의 기본생성자 호출(자동으로 숨겨있다)
**자동으로 숨겨진 부모의 기본생성자는 실행되는 자식의 생성자 중 마지막으로 실행되는 생성자의 처음 명령에 숨어있다  *****마지막으로 실행되는 생성자*****
(단, 부모클래스에 기타생성자만 기술되어 있으면 오류 이럴경우 부모클래스에 기본생성자 기술하면 오류x)

super(매개변수) 호출문 : 부모 인스턴스 안의 해당 케이스의 기타생성자 호출(반드시 기술 해야한다.)






<상속의 캐스팅>

(상위 = <하위)
업캐스팅, 상위 자료형 생략가능, new한테도 업캐스팅 가능, 
하위는 상위의 자식자료형이여야 함

(하위 = <상위)
다운캐스팅, 하위 자료형 생략안됨, 상위 new한테는 다운캐스팅 불가능, 
하위는 상위의 자식자료형이여야 함


import키워드 - 다른 package를 사용하기 위한 - import 패키지명.패키지명....
package키워드 - class들의 소속 - package 패키지명




<추상클래스>

구현부(몸체)가 없는 메소드를 하나 이상 가지고 있는 abstract 키워드가 있는 클래스를 말함

- 키워드이며 기타생성자
- 클래스와 인터페이스 중간다리

//형식
[접근제어자] abstract class 클래스명 {

	//반드시 필수) public abstract 리턴타입 메소드명([매개변수들...]);

 }

//조건

1. class 정의시 abstract키워드가 붙어있어야 한다.
2. abstract클래스(추상클래스)는 반드시 abstract메소드를 한개 이상은 꼭 가지고 있어야 한다.
3. abstract메소드는 반드시 상속받은 자식클래스에서 재정의(Override)가 이루어져야 한다.
(자식클래스에서 재정의 되는 부분에는 몸체구현을 해야하며, abstract키워드가 제거된다.)
4. 객체생성을 할 수 없다. (생성자가 없는것이 아님)
(생성자, 메소드, 멤버필드 모두 가질 수는 있다.)
5. 객체생성 시 자식클래스로 생성 해야 한다.


<@(At기호)> : 어노테이션(Annotation) : 특수한 기능을 가진 주석

//형식
@명령이름





<인터페이스(Interface)>

추상메소드, 상수만 가지고 있는 집합체(묶음)

- 멤버필드에 변수는 상수만 있기 때문에 초기화까지 해줘야함


//형식

[접근제어자] interface 인터페이스명 {
	[public static final << 숨어있다] 자료형 상수명 = 값; //초기화까지 하거나, 선언만.
	ex)
	public static final int A = 5;
	int A = 5;	//앞에 public static final 숨어있음

	[public abstract << 숨어있다] 리턴타입 메소드명([매개변수들...]);
	ex)
	public abstract void setA(int a);
	void setA(int a);	//앞에 public abstract 숨어있음
}



//인터페이스의 조건
기능을 쉽게 바꿀 수 있도록 하기 위함.
보안을 위함.

1. 멤버필드는 반드시 public static final 상수만 가능
2. (권장) 메소드는 반드시 public abstract 메소드만 가능
3. 생성자를 가질 수 없다.
4. abstract 메소드는 반드시 자식클래스에서 재정의(Override) 되어야 한다.
5. 객체생성 시 자식클래스로 생성 해야 한다.



//인터페이스의 목적
1. 기능을 쉽게 바꿀 수 있다.(= 코드수정 용이. = 가독성이 좋다.)
2. 보안을 위해
***3. 다중 상속을 위해




//extends, implement

extends - 같은 급인 경우 사용하는 키워드
ex)
1. 자식클래스 extends 부모클래스
2. 자식클래스 extends 부모추상클래스
3. 자식인터페이스 extends 부모인터페이스


implement - 다른 급인 경우 사용하는 키워드
ex)
1. 자식클래스 implement 부모인터페이스
2. 자식추상클래스 implement 부모인터페이스
***인터페이스는 클래스를 상속 받을 수 없다 





상속자식에서 재정의시
abstract키워드는 사라짐
접근제어자가 부모이상의 접근제어자가 되어야함
반드시 몸체(구현부)가 있어야함




<Template Method>
GOF패턴(gang of four)
**형식이 정해져 있는 메소드를 말함
GOF패턴중 상속자식에서 재정의 하는 메소드의 양식을 변경할 수 없는 것은 행위패턴 중 하나



<POJO(Plain Old Java Object)>
기존의 순수한 자바 객체

//조건
1. 멤버필드가 (권장)private 처리 되어야 한다
2. 멤버필드의 값을 설정하거나 얻어갈 수 있는 접근제어자가 public인 gatter, setter 메소드가 존재해야 한다

//형식
[접근제어자] [기타제어자] class 클래스명 {
	private 자료형 필드명;
	....
	public 리턴타입 getter메소드() {return 값;}
	public void setter메소드(매개변수) {
		맴버필드 초기화 명령문 기술;
		//초기화 명령문 형식
		this.멤버필드명 = 매개변수명;
	}
 }



인터페이스끼리 상속관계일땐 오버라이드 불가능, 안해도됨, 못함 
=> 이유는 인터페이스가 abstract메소드만 가질 수 있기 때문. abstract메소드는 몸체가 없어서 안됨

인터페이스의 자식클래스에서 오버라이드 할때 다중상속(다형성)되어 있는 부모급 인터페이스들의 모든 abstract메소드를 오버라이드 해줘야함


<인터페이스의 기타생성자, private>
인터페이스에서 default, static 기타생성자의 기능은 조금 다름
접근제어자인 private의 기능도 조금 다름

- 인터페이스에서의 static키워드
1. 인터페이스의 statica메소드 또한 오버라이드 되지 않으며, 반드시 인터페이스명으로(해당 static메소드 앞에 인터페이스명.으로) 접근가능
(또한이라 한 이유는 클래스의 상속관계에서도 static메소드는 오버라이드 되지 않았다)
2. (자료형이 인터페이스인 객체)의 객체명으로는 접근불가
3. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다

- 인터페이스에서의 default키워드(기타제어자로 사용)
1. 인터페이스에 선언된 default메소드에는 앞에 public을 기술해줘야한다
(public default로 기술, 메소드 앞에 아무것도 안쓸경우 인터페이스에선 //public abstract가 숨어있기 때문에 default를 쓰고싶으면 public default로)
2. 상속받은 자식에서 재정의 하지 않아도 사용가능 하다


- 인터페이스에서의 private키워드

1. 인터페이스의 private메소드는 상속 불가능, 재정의 불가능
2. 따라서 동일한 메소드(메소드명, 매개변수명, 매개변수 자료형 이 같은 메소드)가 존재해도
   별도의 독립적인 영역의 메소드로 인식한다.
   (같지만 같은 메소드가 아닌거)
   (pacha케이스에서 동일한 메소든데 부모메소드에 private처리가 되어있으면 같지만 다른메소드, 다른메소드로 인식해서 자식메소드 Hiding, 부모메소드는 private라서     외부접근 불가능)






<java.lang.String 메소드 추가>
 - .forName( 문자열 )
문자열 << 이 클래스의 패키지명.까지 다 붙여야 됨
문자열 << 이 클래스에 대한 정보를 알려줘, (ex)드라이버설치)
외부라이브러리를 사용하는 메소드

 - .toGenericString()
더 자세히

 - .toString()
오브젝트가 가지고 있는 메소드
모든 자식클래스에서 오버라이드해서 사용가능
재정의는 무조건 문자열로 출력 될 수 있게
 .앞의 해당클래스에 재정의해서 사용
 .앞의 해당클래스에 toString()메소드가 있는 경우 >> .앞의 해당클래스명을 출력하면 toString()메소드가 호출되고 리턴값 출력


 - 문자열객체명.split("구분자"[, 숫자값])
숫자값이 없는 경우 : nolimit = default (배열로 나누면서 연속적으로 끝까지 아무 값도 없는 경우는 배열에서 제외 됨)
	default는 0임
=> 해당 구분자를 기준으로 문자열 객체를 하나씩 나누어 문자열 배열 형태(반환타입 String[ ])로 만든다.
=> 해당 구분자는 삭제된다.
숫자값이 있는 경우 : (범위 지정 => (인덱스 - 1)배열까지)의 String[ ]로 나눈다.


 - .getChars(복사할 객체의 시작인덱스번호(int), 복사할객체의 마지막인덱스-1(int), 복사해서 붙여넣기 할 객체명, 붙여넣을 객체의 시작 위치 인덱스번호(int))
 매개변수 4개
 



<java.lang. 안에 유용한 메소드들>
 - Character.is~~()메소드들은 해당 요소에서 작은따옴표를 제외하고 안의 값만 그대로 가져와서 비교한다.
	~~에는 Digit, Letter, UpperCase, 등이 있음

 - Math.random()
숫자0과 숫자1 사이의 실수(0.~) 반환
(ex)
(Math.random() * a) + b
b부터 a까지 사이의 실수
정수로 받고 싶으면 메소드 앞에 (int)로 형변환

 - Math.abs(a) 
a의 절대값

 - Math.ceil 
무조건 올림처리

 - Math.floor 
무조건 내림처리

 - Math.rint   
반올림 처리

 - Math.max(a, b) 
a와b 중에 큰 값

 - Math.min(a, b) 
a와b 중에 작은 값







<java.util. 안에 유용한 메소드들>


 - random.nextInt()
int num = random.nextInt();
nextInt에 값 지정이 안되면 int의 유효범위 내의 정수가 임의 출력	//0포함

(ex)
int num = random.nextInt(11); 
//0부터 11개 >> 0 ~ 10 
//nextInt(a) a는 양수만 가능


float f = random.nextFloat();
0.0부터 1.0 사이의 임의의 실수 값


boolean b = random.nextBoolean();
임의의 논리값





//스캐너패키지 메소드
//가변형 자료형 StringBuffer
//Arrays클래스 메소드 >> 원본훼손 일어나는 메소드, 원본훼손 일어나지 않는 메소드









<초기화블럭(initializaion Block)>

필드(=속성=필드=인스턴스=Attribute=Property=컬럼=column)의 값을 초기화 시키는 기능을 가지고 있는 블럭

//형식
- 인스턴스 필드 블록 형식 : {필드의 초기화명령문; (static필드, 인스턴스필드)}
- 클래스 필드 블록 형식 : static{ 필드의 초기화명령문; (static필드)}

//초기화 순서
1번. 필드의 자동초기화값
2번. 필드선언 시 초기값 바로 대입하는 경우(명시적 초기화)
3번. 인스턴스 필드 블록 초기화값
4번. 클래스 필드(static필드) 블록의 초기화값
5번. 생성자에서 초기화한 값 
6번. setter메소드로 초기화한 값(단, setter메소드는 자동실행 안됨. 실행하려면 반드시 호출해야 함)

(ex)
class Ex {
	static int a = 10;	(1번) 명시적초기화
	{ a = 20; }	(2번) 인스턴스필드 초기화블록
	static { a = 55;}	(3번) 클래스(static)필드 초기화블록
	Ex() {
	a = 77;		(4번) 생성자 초기화
	}
 }



***멤버필드를 초기화 할 수 있는 방법

- 초기화 블럭 사용
- 생성자 사용 (this.머시기로)
- setter메소드 사용
- 명시적초기화 (선언과 동시에 값 대입을 하는 방법)

(명시적초기화 ex)
class Ex {
 int a = 1; //명시적초기화
 }


**필드(=멤버=속성=Attribute=property=컬럼=인스턴스 또는 클래스) 상수 예외사항
- 반드시 선언과 동시에 초기값 설정을 해주어야 하나, 생성자와 초기화블럭 중 딱 한 번은 초기값 설정을 할 수 있다.

(생성자로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
Ex() {
  	MAX = 10; //이걸로 한번은 가능(생성자)
	}
 }

(초기화블럭으로 상수 초기화 ex)
class Ex {
 	final int MAX; //만 하면 에러이지만
{
  MAX = 10; //이걸로 한번은 가능(초기화블럭)
	}
 }




<접근제어자(Access Modifier)와 기타제어자(Modifier)>

접근제어자 : public, protected, default, private
기타제어자 : final, static, abstract


//사용가능 범위 정리
===================================================
- 지역변수    : 접근제어자 모두 안됨, 기타제어자는 final만 가능
- 멤버필드    : 접근제어자 모두, 기타제어자는 abstract제외한 모두
- 메소드	     : 접근제어자 모두, 기타제어자 모두
- 생성자	     : 접근제어자 모두, 기타제어자 모두 안됨
- 초기화블록 : 접근제어자 모두 안됨, 기타제어자 static만 가능
- 클래스	     : 접근제어자 public, default, 기타제어자 static만 제외하고 가능
	      (단, 이너(inner) 클래스경우 예외)
===================================================

**같이 쓸 수 없는 제어자들
private 와 abstract
//abstract는 상속관계에서 쓰이는데 private는 같은 클래스 아니면 안보이니까 안됨
final 과 abstract
//abstract는 상속관계에서 쓰이는데 상속관계에서 final은 상속 할 수 없는 이란 뜻이라 안됨
static 과 abstract
//static은 공유되는 인데 abstract는 몸체가 없어서 공유고 뭐고 안됨




<제네릭타입(=지네릭타입=Generic Type)>
클래스, 메소드 에 가능
<>필수
사용자가 제네릭타입을 만드는 ex) class Ex<A> { 머시기 }

//형식
class 클래스명<클래스이상급자료형의 변수명(권장.대문자)>{
	클래스이상급자료형의 변수명 a;
	public 클래스이상급자료형의 변수명 getA() {
		return a;
	}
	public void setA(클래스이상급자료형의 변수명 a) {
		this.a = a;
	}
 }



<권장하는 제네릭타입>
 T => 한 개의 자료형을 변경하고자 하거나 어떤 변수를 지정할 지 잘 모르는 경우는 대개 T변수를 쓴다. (자료형을 의미하는 Type의 약자에서 따온 명칭)
 E => 배열처럼 나열하는 목록의 자료형을 가지는 클래스의 요소 자료형을 지정 할 때 사용하는 명칭(Element의 약자에서 따온 명칭) 
 K => Key요소의 자료형을 지정하는 명칭
 V => Value의 요소의 자료형을 지정하는 명칭
 N => Number자료형을 지정하는 명칭


<제네릭타입에서 <?> = 와일드카드>

? => 와일드카드 : 전체 다, 무엇이든지 => *(아스테리스크) 같은 놈





<컬렉션프레임워크(Collection Framework)>
한꺼번에 많은 데이터들을 처리하기 위한 구조, 형식을 제공하는 것. (배열같은)

//컬렉션프레임워크 형식
(자료형명<자료형명>) <- 자료형
ex) List<Car>
**컬렉션프레임워크는 제네릭기반의 자료형이므로 반드시 요소(제네릭타입)의 자료형은 클래스급 이상의 자료형으로 지정해 주어야 한다.


상속관계의 인터페이스로 되어있음

인터페이스 
	Collection인터페이스가 조상 인터페이스임
 - List인터페이스 -> ArrayList클래스, LinkedList, Vector, Stack, Queue(큐)
	=> 배열객체가 보완되어 나온 자료형, 방구조를 변경할 수 있다
	=> 중복값을 가질 수 있다. => 인덱스가 있기 때문에 (순서가 있다)	(ex. 0번인덱스에 1이 있어도 1번인덱스에 1을 담을수 있음)

	Collection인터페이스가 조상 인터페이스임
 - Set인터페이스 -> HashSet클래스, TreeSet클래스
	=> 리스트와 비슷하지만 중복값을 가질 수 없다.
	=> 순서가 없다. (인덱스가 존재하지 않음)

	Iterator(반복자)인터페이스가 조상 인터페이스임.
 - Map인터페이스 -> HashMap클래스, TreeMap클래스
	=> 키(key)와 값(value)의 쌍으로 이루어진 자료형 //<>제네릭타입을 두개 해줘야함 <하나 key꺼, 하나 value꺼>
	=> 키는 무조건(권장) 문자열자료형(String)으로 지정해 준다.
	=> 중복값을 가질 수 있지만, 중복키는 불가능하다.
	=> 순서가 없다. (인덱스가 존재하지 않음)






//18
//노트필기
//컬렉션프레임워크에 추가
//
//



<Collection Framework 종류와 형식>

- Collection인터페이스를 상속받은 자식 interface : List, Set
- Iterator인터페이스를 상속받은 자식 intetface : Map


List 인터페이스를 상속받은 자식 클래스 : ArrayList : 순서가 있다.(인덱스 존재, 중복값 허용)

//형식
List<자료형> 객체명 = new ArrayList<자료형>();
List<자료형> 객체명 = new ArrayList<자료형>([값(요소), 값(요소)2, 값(요소)3, ...]);
ArrayList<자료형> 객체명 = new ArrayList<자료형>();

//값(요소)추가 : 
- .add(추가할 값)메소드 : 마지막에 값을 추가한다.
- .add(인덱스번호, 추가할 값)메소드 : 해당 인덱스에 값을 추가하고 기존의 인덱스번호부터 ~ 마지막인덱스까지 한 칸씩 뒤로 밀린다.

//값(요소)삭제 : 
- .remove(인덱스번호) : 해당 인덱스의 값을 삭제한다.
- .remove(값) : 처음 인덱스부터 순서대로 검색하여 처음 해당되는 값만 삭제한다.
(중복값이 존재하는 경우는 맨 처음 값만 제거됨)

//해당값(요소) 모두 제거
- .removeAll(컬렉션프레임워크자료형객체) : 해당 자료형으로 지정해둔 값(요소)과 일치하는 값이 있으면 모두 제거함. 
---------------------------------------------------------------------------------
***컬렉션프레임워크자료형객체
*ex)
ArrayList<String> aAList = new ArrayList<String>();
aAList.add("홍길동");
aAList.add("고길동");
aAList.add("마이콜");
aAList.add("홍길동");

ArrayList<String> bAList = new ArrayList<String>();
bAList.add("홍길동");
aAList.removeAll(bAList); // aAList객체에서 홍길동이라는 이름이 모두 제거됨.
---------------------------------------------------------------------------------
- .clear() : 해당 객체를 주소값만 제외한 안의 방을 모두 제거함 



Set자료형 : 순서가 없는 자료형
(인덱스없음 = 중복값 불가)

//형식
Set<자료형> 객체명 = new HashSet<자료형>();
HashSet<자료형> 객체명 = new HashSet<자료형>();
- 순서가 있는 것 처럼 보이도록 처리할 수 있는 자료형 : LinkedHashSet자료형

//방추가 : List자료형과 동일
//방제거 : remove(값) 또는 remove(객체명)으로 제거 가능




Map자료형 : 순서가 없으며, 키와 값의 쌍으로 이루어진 자료형
(키는 중복값 불가, 값은 중복값 가능)
(키, 값에 null값 사용가능, 단 예외 자료형은 제외)

//형식
Map<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
HashMap<키자료형, 값자료형> 객체명 = new HashMap<키자료형, 값자료형>();
- 순서가 있는 것 처럼 보이도록 하는 자료형 : LinkedHashMap
- 키와 값에 null값을 허용하지 않는 자료형 : Hashtable

//추가 : .put(키명, 추가할 값);
//변경 : .put(키명, 변경할 값);
**키 중복이 허용되지 않으므로 키가 존재하지 않으면 put은 insert기능
**키가 존재하면 put은 update기능으로 처리됨.



=================================================
<객체의 크기(방길이, 문자개수, 행개수, 등등)를 나타내는 키워드 또는 메소드>

 - 배열객체의 방길이 : length
 - 문자열 길이(개수) : length( ) 메소드 
 - 컬렉션프레임워크 객체의 크기 : size( ) 메소드
=================================================


Iterator 인터페이스 자료형 : 한줄로 나열된(순서가 있던 없던 상관없음 - List, Set 가능) 데이터를 하나씩 떼어서 반복해서 가져올 수 있는 자료형 (StringTokenizer처럼)
- .hasNext() : 다음 요소가 있는지 확인, 데이터를 가져오지 않음. (boolean값으로 유무(true, false) 반환)
- .next() : 다음의 요소 한 개를 가져옴. 해당 값을 반환함

//형식
Iterator<자료형> 객체명 = 한줄로나열된객체명.iterator();
**제네릭형식으로 자료형을 반드시 기술해주어야 하나씩 요소를 떼어올 때 쉽게 가져올 수 있다.





<익명 클래스(Anonymous)>

- Inner class로, 이름이 없는 클래스를 말한다.
- 클래스 정의와 동시에 객체를 생성할 수 있다.

- Inerface, AbstractClass 모두 익명 클래스로 객체를 만 수 있다.
부모 클래스의 이름이나 구현하고자 하는 인터페이스의 이름을 사용해서 정의하기 때문에 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 둘 이상의 인터페이스를 구현할 수 없다. 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.

- 이름이 없기 때문에 생성자도 가질 수 없다.
- 인터페이스와 추상클래스 내부의 모든 추상메소드를 반드시 오버라이딩 해야 함.

- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다. (매개변수로 생성하는 익명클래스는 종료세미콜론 없어도 됨)
- 외부에서 익명클래스의 멤버필드에는 접근불가.

- 익명클래스 내부에 기술가능한 static의 경우 : 
	1. static final로 선언된 상수(일반 변수 static은 불가)
	2. 외부 변수는 Effectively final나 final만 가능
	**Effectively final : 외부에 일반 변수라도 값 변경이 전혀 안 된 변수

//익명 클래스를 사용하는 이유
- 프로그램 내에서 한 번만 객체를 만드는데 사용되는 클래스를 굳이 정의할 필요가 없기 때문
- AWT, SWING, GUI, 이벤트 처리에 쓰임
- 외부에서 익명클래스의 멤버필드에 접근이 안되므로, 클래스 안에서 모두 처리되어야하는 경우만 익명클래스를 사용한다.

//형식
new 부모클래스이름( ) {
	//익명클래스 기술
 };

//형식2
new 구현인터페이스이름( ) {
	//익명클래스 기술
 }



<이너클래스(inner Class)>
내부클래스

클래스 안이나 메소드 안에 선언된 또 다른 클래스를 말함.
- 클래스를 선언 시 static 제어자를 사용 할 수 있다. (멤버의 개념)
- 클래스를 선언 시 접근제어자 모두 사용 할 수 있다.


//종류
- 인스턴스(instance) 내부 클래스 
클래스의 멤버 위치에 선언된 일반 클래스
외부에서 접근 할 수 있다.

- static 내부 클래스 
클래스의 멤버 위치에 선언된 static 클래스
외부에서 접근 할 수 있다.

- 지역(local) 내부 클래스 
메소드 안에 선언된 클래스
외부에서 접근 할 수 없다.



<람다식 함수>
- 이름 없는 함수
- 함수의 구현과 호출만으로 프로그램을 만들 수 있는 방식이다.
- 인터페이스만 이용 가능

- 외부에 정의된 변수를 참조할 때, final, 또는 Effectively final변수만 가능하다.
- 함수 내부에서 지역변수 선언시 final, 일반 변수만 가능, static불가
- 인터페이스 메소드를 참조하여 만들 경우 해당 인터페이스 내부에는 메소드가 한 개만 선언되어 있어야 한다. 여러 개 인 경우 에러 발생

- 람다식 메소드는 호출되면 익명클래스가 자동으로 생성된다. (눈에는 보이지 않음)
- 마지막 }(종료중괄호) 뒤에 종료 ;(세미콜론)을 꼭 넣어준다
- 자바 8버전부터 지원됨

//문법
(매개변수목록) -> {함수몸체};
한 줄 명령인 경우 중괄호 생략이 가능

리턴타입 메소드명(매개변수....){
 실행코드들....;
 }






<예외처리(Excetpion)>
예측가능한 에러를 정상종료가 되도록 처리하는 방법

Exception클래스 : 예외처리의 최고 조상 클래스(자료형)

//예외처리 방법
1. 책임감이 강한형식 :  try ~ catch문(짝, 반드시 같이 존재해야 함)
try문에서 발생된 에러는 catch문에서 해결함. 내가 발생시킨 에러를 내가 처리함

try문 : 해당 실행문들을 감싸는 위치에 존재
catch문 : try문에서 발생되는 에러를 처리하는 명령문을 감싸는 위치에 존재함

//형식
try {
       실행코드들;
        ...;
} catch (예외처리자료형명 객체명) { **//System.out.println(객체명); = 예외처리자료형명의 (패키지경로 포함)경로: 에러내용
    //try문에서 에러가 발생될 경우 처리할
      실행코드들;
      ...;
}[ finally{
에러가 발생이 되든, 발생이 되지 않든 반드시 try ~ catch문이 실행된 후 마지막에 실행되는 부분의 코드들을 기술;
} ]



2. 책임 전가형식 : throws
- 메소드를 호출한 곳에서 에러를 처리하도록 책임을 전가함
- 위치는 메소드 선언문의 () 소괄호 뒤에 존재함

//형식
[접근제어자] [기타제어자] 리턴타입 메소드명([매개변수들...]) throws 예외처리자료형명, ... {
	실행코드들...;
 }




<입출력 라이브러리는 java.io패키지에서 제공됨>

스트림 : 단방향으로 흐르는 데이터의 흐름을 스트림이라고 함.

바이트 스트림 : 그림, 멀티미디어, 문자 등 모든 종류의 데이터를 입출력할 때 사용
- 바이트코드화, 메모리 효율 좋음, 인코딩 등 해야 내가 알아볼 수 있음
문자 스트림 : 문자만 입출력할 때 사용
- 메모리 효율 안좋음, 내가 바로 알아볼 수 있음


바이트 스트림의 최상위 클래스 : InputStream(입력), OutputStream(출력)
하위 클래스 : 예) FileInputStream, FileOutStream

문자 스트림 최상위 클래스 : Reader(입력), Writer(출력)
하위 클래스 : FileReader, FileWriter



<스트림 : 단방향으로 흐르는 데이터의 흐름>

FileWriter => 문자열이나 char[]배열로 값 입력시 FileReader 객체를 통해 바로 읽어 들일 수 있다.

FileWriter로 입력을 하더라도 byte코드 한 개 한 개 입력하여 작성하는 경우는 반드시 byte코드를 문자스트림방식으로 변환해서 읽어야만 한다.

FileOutputStream => 바이트코드로 파일을 생성할 수 있다.

FileInputStream => 바이트코드로 파일을 읽어들일 수 있다. 바로 문자로 출력이 어렵기 때문에 InputStreamReader를 통해 문자스트림형식으로 변환 후 출력 가능하다.

FileOutputStream을 이용해서 파일을 작성할 때 인코딩을 설정하여 작성하는 경우 반드시 File을 읽어들일 때도 인코딩을 설정해서 읽어주어야 한다.





<프로세스(Process)와 스레드(Thread)>

프로세스 : 실행하고 있는 프로그램 또는 실행한 프로그램이 메모리에 올라와있는 상태를 프로세스라고 함

 - 단일프로세스 : 하나의 프로그램 당 하나의 프로세스만을 가지고 있는 것
	장점 : 메모리를 많이 차지 하지 않음, 속도가 빠름
	단점 : 하나의 프로세스에 문제가 발생하면 프로그램이 종료 됨

 - 멀티프로세스 : 하나의 프로그램 당 여러 개의 프로세스를 가지고 있는 것
	장점 : 하나의 프로세스에 문자가 발생되도 프로그램이 전체적으로 영향을 받지 않는다, 독립적으로 작업이 진행 됨
	단점 : 메모리를 단일프로세스보다 많이 차지함, 속도가 느릴 수 있다.
	예) 크롬브라우저

스레드 : 프로세스(프로그램) 안에서 실행되는 하나의 작업 단위를 스레드라고 함
하나의 스레드에서 문제가 일어나면 다 멈춤

 - 단일스레드 : 프로세스 안에 하나의 스레드만 존재함
	장점 : 메모리를 많이 차지 하지 않는다.
	단점 : 멀티작업을 진행하는 경우에는 멀티스레드보다 속도가 느릴 수 있다.

 - 멀티스레드 : 프로세스 안에 여러 개의 스레드가 존재함
	장점 : 멀티작업을 진행하는 경우에는 단일스레드보다 속도처리가 빠를 수 있다.
	단점 : 단일스레드보다 메모리를 많이 차지 한다.



자바에서는 기본적으로 한개의 스레드를 가지고 있다. (대표적 : main메소드)




<네트워크 필기>

v 인터넷 : 지역네트워크를 통신으로 연결한 것
v 네트워크 란 : 여러대의 컴퓨터들을 통신회선으로 연결한 것. 그물망처럼 연결된 통신망을 말함


v 네트워크 종류 : 
- PAN (Persnal Area Network) : 가장 작은 규모의 네트워크. 예시 : bluetooth
- LAN (Local Area Network) : 근거리 영역 네트워크. 예시 : Wi-Fi
- MAN (Metropolitan Area Network) : 대도시 영역 네트워크. 예시 : 대학교내의 통신망
- WAN (Wide Area Network) : 광대역 네트워크. 예시 : 핸드폰5G망 등
- VAN (Value Area Network) : 공중 통신 사업자로부터 통신 회선을 임대하여 하나의 사설망을 구축하고 이를 통해 정보의 축적, 가공, 변환 처리 등 부가 가치를 첨가한 후 불특정 다수를 대상으로 서비스를 제공하는 통신망
예시 : 은행 간 현금인출기 공동이용 서비스, 신용카드 정보 시스템, 국내외 항공사 간 항공권 예약 서비스
- ISDN (Integrated Services Digital Network) : 종합정보 통신망(=BISDN) 전화, 데이터 통신, 비디오텍스 등 통신관련 서비스를 종합하여 다루는 통합서비스 디지털 통신망. 디지털 전송방식과 광섬유 케이블 사용.


v 프로토콜(protocol) : 통신을 주고 받기 위한 통신 규칙. 컴퓨터와 컴퓨터도 서로 이해 할 수 있는 언어, 공용된 언어를 사용 해야 한다는 것


	v IP(Internet protocol address)(집주소-아파트(ip)) : 네트워크상에서 장치들이 서로 통신을 하기 위한 규칙에 필요한 서로를 식별하기 위한 고유 주소 또는 특수번호를 말함. (집 주소처럼 컴퓨터 주소라고 보면 됨. 하나의 랜카드 당 한 개의 ip가 할당되어 있다.)
**랜카드 : 네트워크를 사용하기 위한 어댑처 역할을 하는 장치
- IP는 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다. 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있기 때문에 패킷 전송과 정확한 순서를 보장하려면 TCP프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.


	v 전송 제어 프로토콜(Transmission Control Protocol, TCP, 문화어: 전송조종(제어)규약(규칙)) : 웹 브라우저들이 월드 와이드 웹(www-대부분 웹이라고 함)에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송에도 사용된다.


v 포트(port)(집주소-아파트(ip) 동호수(port)) 란 : 같은 ip에서 접근해야하는 프로그램이 여러개 일 경우 해당 프로그램에 대해 접근하기 위해 부여된 프로그램 주소값이라고 생각하면 된다.


v 서버 : 서비스를 제공하는 프로그램을 의미함 (서비스를 제공하는 역할)
v 클라이언트 : 서비스를 요청하고, 받는 프로그램을 의미함 (서비스를 요청하고 받는 역할)
v 소캣(Socket) : 프로그램이 네트워크에서 데이터를 통신할 수 있도록 연결해주는 연결부


v ServerSocket 클래스(서버측) :
- java.net패키지에서 제공
- 서버 프로그램을 개발할 때 쓰이는 클래스
- 서버를 구동 시킬때, 요청을 받기위한 준비를 할때 사용
- 서버를 구동 시키는 것이므로 ip주소는 필요없으며, 자신의 서버에 제대로 접근할 수 있는 포트번호만 있으면 된다.
예시 : ServerSocket echoServer = new ServerSocket(4000); //4000이 포트번호임.

v Socket클래스(클라이언트측/서버측) :
- java.net클래스에서 제공
- client에서 서버로 접속하거나 Server에서 요청을 accept(수락)하는데 필요한 클래스
- 서버에 접근을 해야하므로 해당 서버의 ip주소와 해당 서버내의 프로그램이 부여받은 포트번호까지 필요하다.
예시 : Socket socket = new Socket("127.0.0.1", 4000);
	//서버의 ip주소: "127.0.0.1" , 서버의 포트번호: 4000
- 클라이언트의 요청을 수락해야하므로 Socket으로 요청한 자료형과 일치되는 Socket자료형으로 accept(수락)해주어야 함.
예시 : Socket socket = echoServer.accept();


v TCP/IP 송수신 과정
1. 서버 : 클라이언트의 요청을 받기 위한 준비를 한다. (ServerSocket)
   ServerSocket echoServer = new ServerSocket(4000);

2. 클라이언트 : 서버에 접속 요청을 한다. (Socket)
   Socket socket = new Socket("127.0.0.1", 4000);
2. 서버 : 클라이언트의 요청을 받아 들인다. (accept)
   Socket socket = echoServer.accept();

3. 클라이언트 : 서버에 메시지를 보낸다. (BufferedWriter)
3. 서버 : 클라이언트가 보낸 데이터를 출력한다. (BufferedReader)

4. 서버 : 클라이언트에에 메시지를 보낸다. (BufferedWriter)
4. 클라이언트 : 서버가 보낸 데이터를 출력한다. (BufferedReader)

5. 서버, 클라이언트 모두 종료 : 종료 한다. (socket.close())


v InetAddress 클래스
- InetAddress 클래스는 IP주소를 표현한 클래스임
- ip주소뿐만 아니라 도메인을 이용하여 ip정보를 가져올 수도 있다
- 자바에서는 모든 IP주소를 InetAddress 클래스를 사용한다
- default로 된 생성자가 하나 존재하나 객체 생성 불가
- 호스트 이름과 호스트에 대응하는 IP주소를 알 수 있는 메소드를 제공한다


v 객체를 반환하는 메소드(키워드가 모두 static 임)
- getAllByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 배열을 반환함
- getAddress(byte[] addr) : 매개변수 addr에 대응되는 InetAddress 클래스 객체를 반환함
- getByAddress(String host, byte[] addr) : 매개변수 host, addr로 생성한 InetAddress 클래스 객체를 반환함

- getByName(String host) : 매개변수 host에 대응되는 InetAddress 클래스 객체를 반환함
- getLocalHost() : 로컬호스트의 InetAddress 클래스 객체를 반환함

** Localhost(로컬호스트)는 서버의 기능을 제공하는 자신의 컴퓨터를 의미한다.
** IPv4에서의 IP주소는 127.0.0.1이다. (32비트 표현) 
(ip = 127.0.0.1 = 로컬호스트 => 나의 피씨를 인터넷에서 나만 볼 수 있는 주소이고 외부접근불가)
** IPv6은 32비트의 ipv4의 값의 표현이 제한적이라 보완되어 나온 물리적 주소 표기방법임. (128비트)


v 메소드
- getAddress() : InetAddress 클래스 객체의 실제 ip주소를 바이트 배열로 반환
- getHostAddress() : ip주소를 문자열로 반환
- getHostName() : 호스트 이름을 문자열로 반환
- toString() : ip주소를 String으로 오버라이딩한 메소드. "호스트이름/ip주소" 형식으로 값을 반환함.

내컴퓨터 ip => cmd >> ipconfig(간단히) / ipconfig /All(자세히)



<데이터베이스>

RDB(Relational DataBase) : 관계형데이타베이스
표구조의 데이터를 테이블이라는 구조화된 형식으로 저장, 변경, 삭제, 추가, 검색등을 지원하는 저장소

RDBMS(Relational DataBase Management System) : 
테이블 구조로 데이터를 저장하고, 변경하고, 삭제하고, 추가, 검색할 수 있는 그 이외에 데이터를 전반적으로 쉽게 관리할 수 있는 시스템을 말함.
종류 : Oracle, MySQL, MariaDB...
데이터는 무조건 테이블 구조로 저장이 된다. (다 테이블화 해버림)
영구적으로 데이터가 반영이 된다. (저장이된다) => 실질적으로 데이터는 파일로 저장이 된다.



<DBMS(데이터베이스 관리 시스템)의 장단점>
1. 장점
⇒ 데이터 중복의 최소화
파일 시스템에서는 각 응용 프로그램마다 자신의 파일이 개별적으로 관리 유지되기 때문에 전체적으로 저장되는 데이터의 입장에서 보면 상당히 많은 데이터가 같은 내용을 표현하면서 중복적으로 저장되고 있다. 그러나, 데이터베이스는 데이터를 통합하여 구성함으로써 이러한 중복을 사전에 통제할 수 있다. 이것은 물론 데이터의 중복을 완전히 배제한다는 것을 의미하는 것은 아니다. 왜냐하면 통합 데이터베이스 환경속에서도 성능 향상의 이유로 데이터의 중복이 불가피할 때가 있기 때문이다.

⇒ 데이터의 공용
같은 내용의 데이터를 여러 가지 구조로 지원해 줄 수 있는 DBMS의 복잡하고도 정교한 기법 때문에 데이터베이스의 데이터 공용이 가능하다. 이것은 기존 여러 응용 프로그램들이 수행하던 데이터에 대한 유지 관리 부담을 면제시켜 줄뿐만 아니라 새로 개발하는 응용 프로그램에 대해서도 데이터 구성에 신경 쓸 필요없이 응용 자체에만 전념할 수 있게 해준다는 것을 의미한다.

⇒ 데이터의 일관성 유지
현실 세계의 어느 한 사실을 나타내는 두 개의 데이터가 있을 때 오직 하나의 데이터만이 변경되고 다른 하나는 변경되지 않는다면 데이터간의 불일치성, 즉 모순성을 갖게 된다. 모순성을 내포한 데이터베이스는 서로 상충되는 정보를 제공하게 되고 데이터베이스의 유용성을 저해하게 된다. 데이터베이스는 관리 시스템은 바로 이 데이터의 중복을 제어하고 중앙 집중식 통제를 통해 데이터의 일관성을 유지할 수 있다.

⇒ 데이터의 무결성 유지
데이터 중복성이 완전히 제거된다고 하더라도 허용되지 않는 값이나 부정확한 데이터가 여러 가지 경로에 의해 데이터베이스에 잠입될 수 도 있다. 데이터베이스 관리 시스템은 데이터베이스가 생성/조작될 때마다 제어 기능(제약조건)을 통해 그 유효성을 검사함으로써 데이터의 무결성을 유지할 수 있다.
(NOT NULL, PRIMARY KEY, FOREIGN KEY등)

⇒ 데이터의 보안 보장
DBMS는 데이터베이스를 중앙 집중식으로 총괄, 관장함으로써 데이터베이스의 관리 및 접근을 효율적으로 통제할 수 있다. 이것은 DBMS가 정당한 사용자, 허용된 데이터와 연산등을 확인 검사함으로써 모든 데이터에 대해 철저한 보안을 제공한다.
일반적으로 같은 내용의 데이터가 여러 파일에 분산 관리될 때 같은 수준의 보장되기는 상당히 어렵다.

⇒ 표준화
DBMS의 중앙 통제 기능을 통해 데이터의 기술양식, 내용, 처리방식, 문서화 양식등에 관한 표준화를 범기관적으로 시행할 수 있다.

⇒ 전체 데이터 요구의 조정
한 기관의 모든 응용 시스템들이 요구하는 데이터들을 전체적으로 수집 분석하고 상충되는 데이터 요구는 조정해서 기관 전체에 가장 유익한 구조로 조직하여 효율적인 정보처리 효과를 얻게 할 수 있다.

2. 단점
⇒ 운영비의 증대
DBMS는 가격으로 보아 고가의 제품이고 컴퓨터 시스템의 지원을 많이 사용한다. 특히, 주기억장치를 많이 차지하기 때문에 DBMS를 운영하기 위해서는 메모리 용량이 더 필요하게 되고, 더 빠른 CPU를 요구하게 된다. 결과적으로 시스템 운영비의 오버헤드를 가중시키게 된다.

⇒ 자료 처리의 복잡화(DB데이타의 처리방법이 복잡해져 전문화된 프로그래머가 필요.)
데이터 베이스에는 상이한 여러 타입의 데이터가 서로 관련되어 있다. 응용 프로그램은 이러한 상황속에서 여러 가지 제한점을 가지고 작성되고 수행될지도 모른다. 다라서, 응용 시스템은 설계 시간이 길어지게 되고 보다 전문적, 기술적이 되어야 하기 때문에 고급 프로그래머가 필요하게 된다.

⇒ 복잡한 예비와 회복
데이터베이스는 그 구조가 복잡하고 여러 사용자가 동시에 공용하기 때문에 문제가 일어났을 때 정확한 이유나 상태를 파악하기 어려울 뿐만 아니라 여기에 대한 예비(Backup, 백업)조치나 사후회복 (Recovery, 복구)기법을 수립해 놓는 것도 매우 어렵다.

⇒ 시스템의 취약성
데이터베이스 시스템은 통합된 시스템이기 때문에 그 일부의 고장이 전체 시스템을 정지시켜 시스템 신뢰성과 가용성을 저해할 수 있다. 이것은 특히 데이터베이스에 의존도가 높은 환경에서는 아주 치명적인 약점이 아닐 수 없다.



<SQL(Structure Query Language)> : 구조화된 명령 언어

직접적으로 데이터를 관리하는데 사용하는 명령문


*SQL 문장
- 명령문은 대/소문자를 구별하지 않는다.
- 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.


DQL(Data Query Language) : 데이터를 가져오는 명령만 처리하는 명령문 = 데이터 질의어
select문


DDL(Data Defination Language) : 데이터를 저장하는 구조를 정의, 수정, 제거하는 기능을 처리하는 명령어 = 데이터 정의어
create : 테이블, 계정, 뷰, 프로시저, ...등을 생성할 때 사용하는 명령어
alter : 테이블, 계정, 뷰, 프로시저, ...등을 수정, 변경할 때 사용하는 명령어 (이름 변경까지 포함)
drop : 테이블, 계정, 뷰, 프로시저, ...등을 제거할 때 사용하는 명령어
truncate : 테이블의 구조만 제외하고 나머지 데이터를 모두 제거하는 명령어 (내가 지정한 테이블의 모든 데이터를 다 지우는 기능만 있다. 전체 삭제기능. 자동확정됨)


DCL(Data Control Language) : 데이터를 제어하는 기능을 담당하는 명령어 = 데이터 제어어
grant : 계정에 권한을 부여하는 명령
revoke : 계정의 권한을 회수하는 명령


TCL(Transaction Control Language) : 트랜젝션(작업)을 제어하는 명령어 = 트랜젝션 제어어
commit : 데이터베이스에 전체 데이터의 갱신결과를 영구적으로 확정하는 기능
rollback : 데이터베이스에 전체 데이터의 갱신 결과를 영구적으로 전체 되돌리는 기능
checkpoint(savepoint명령) : rollback하는 곳의 시점을 지정하여 전체 rollback이 아닌 원하는 지점까지의 rollback기능을 제공하는 명령어




//22
//필기



<오라클>


- 테이블 명명규칙
-------------------------------------------------------
테이블명은 문자로 시작해야 한다(한글포함)
테이블명은 128Byte이하 작성가능
테이블명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능
SQL키워드는 테이블명으로 사용불가
테이블 이름은 대소문자를 가지지 않는다
(단, 큰따옴표로 묶어 처리하는 경우 대소문자 가림)
동일한 계정내에서는 동일한 이름의 객체가 존재하는 경우 테이블명으로 사용할 수 없다 (테이블, 뷰, 함수, 프로시저, 등)
-권장
되도록 테이블명이나 컬럼명은 영어로 기재할 것
되도록 대소문자를 가리지 않도록 명명해줄 것.



- 컬럼(속성) 명명규칙
-------------------------------------------------------
컬럼명은 문자로 시작해야한다.(한글포함)
컬럼명은 문자(한글포함), 숫자, 특수문자($,_,#)까지만 사용가능하다.
SQL키워드는 컬럼명으로 사용할 수 없다.
한 테이블 내에서 동일한 이름으로 지정할 수 없다.




**큰따옴표를 묶어 지정하는 경우는 테이블명 컬럼명 모두 큰따옴표로 묶어야하며, DML, DDL, DCL, 등을 처리할 때도 반드시 큰따옴표로 묶어서 기술해야한다.
-------------------------------------------------------






1. 사용자(user) 계정 생성(create)
[CREATE문 : DDL]
형식 : CREATE USER 사용자계정명 IDENTIFIED BY 비밀번호;
>>예시 : CREATE USER TEST IDENTIFIED BY 1111;

2. 사용자 계정에 권한 부여
[GRANT문 : DCL]
형식 : GRANT 부여할권한1, 부여할권한2, .... TO 사용자계정명;
>>예시 : GRANT CONNECT, RESOURCE, DBA TO TEST;

3. 사용자 계정으로 접근하기(접속하기)
[CONNECT(CONN)문 : 종료세미콜론이 필요없는 문]
형식 : [CONNECT 사용자계정명/비밀번호] 또는 [CONN 사용자계정명/비밀번호]
>>예시 : CONNECT TEST/1111 또는 CONN TEST/1111

4. 테이블(table) 생성(create)하기
[CREATE문 : DDL]
형식 : CREATE TABLE 테이블명(
	컬럼명1 자료형 [제약조건1 제약조건2 ... ... ] , (뒤에 이어지는 컬럼이 있다는 , )
	컬럼명2 자료형 [제약조건1 제약조건2 ... ... ] ,
	...
	컬럼명N 자료형 [제약조건1 제약조건2 ... ... ] (마지막엔 , 없이)
);

4-1. 테이블 생성하기 (테이블 복제본만들기)
**테이블을 만드는 계정과 복제본을 끌어올 계정이 다른 경우는 복제본 테이블의 사용자계정명(스키마명)을 반드시 기술해주어야 한다.
형식 : CREATE TABLE 테이블명 AS SELECT * FROM [사용자계정명(복제할테이블이 속한)-스키마명].복제할테이블명;
**SCOTT계정에서 제공되는 테이블명 : EMP(사원관리 테이블), DEPT(부서관리 테이블), GRADE(등급관리 테이블)
-현재 접속 계정 : TEST인 경우
>>예시 : CREATE TABLE EMP AS SELECT * FROM SCOTT.EMP;
-------------------------------------------------------

**해당 계정내의 전체 테이블 목록 확인하는 명령 : SELECT * FROM TAB;
**해당 테이블의 전체 구조를 확인하는 명령 : DESC 테이블명;	[DESCRIBE]
**SQL PLUS : 오라클에서 무료(오픈소스)로 제공되는 COMMAND LINE INTERFACE 데이터베이스 개발툴

-------------------------------------------------------


* SQL 문법
- 대/소문자를 구별하지 않는다. 하지만 값은 대/소문자를 구분한다.
- SQL 문장은 한 줄 또는 여러 줄에 나눠서 입력할 수 있다.
- SQL 문장의 끝은 반드시 세미콜론(;)으로 끝을 맺는다.


* SELECT문
- DATABASE에 저장되어 있는 자원들을 검색할 때 사용하는 문장이다.
- 구성(문법 : 형식 : Syntax)

	SELECT [DISTINCT(중복값제외하는 키워드)] {*, 컬럼명1, 컬럼명2, ...}
	FROM 테이블명
	WHERE 조건;

- 모든 컬럼을 선택할 때는 "*" 를 사용한다.
하지만 "*"는 컬럼 검색과 함께 연산이 많아서 데이터베이스의 속도를 저하시킨다.





SELECT * | 컬럼명1, 컬럼명2 => 가져올 컬럼을 지정하는 절 : *(아스테리스크) => 전체 컬럼을 다 가져오세요.
FROM 테이블명 => 가져올 데이터가 존재하는 테이블명을 지정하는 절
--ㄴ필수-----------------조건ㄱ------
[WHERE  => 가져올 행 수의 조건을 지정하는 절
GROUP BY => 조건으로 가져온 것 중에서 동일한 값을 가진 컬럼이 있을 경우 그 값의 중복을 제거하는 절
HAVING => 위 GROUP BY절 조건에서 다시 조건을 거는 경우 (반드시 GROUP BY절이 존재해야 사용가능)
ORDER BY => 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절]


-- : 오라클의 한 줄 주석 기호
/**/ : 오라클의 여러 줄 주석 기호

>>예시1)
SELECT NO, NM FROM USERLIST
WHERE NO = 2;

>>예시2)
SELECT * 
FROM USERLIST
(오라클한줄주석=>)--WHERE GENDER = '남';
WHERE NO = 1 OR NO = 2 OR NO = 6;
(WHERE NO = 1 AND NO = 2 AND NO = 6;) => 안됨 -표설명

>>예시3)
SELECT NM
FROM USERLIST
GROUP BY NM;

SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER;
 = 그룹바이를 쓸때 그룹바이에 쓰는 컬럼만 셀렉트해야함

>>예시4)
SELECT NM, GENDER
FROM USERLIST
GROUP BY NM, GENDER
ORDER BY NM(오름차순으로 하고), GENDER DESC; (내림차순으로 마무리)



- 기본틀
SELECT 컬럼
FROM 테이블
[WHERE 조건]

--dept테이블에서 지역이 보스톤인 데이터의 부서명을 가져오세요
SELECT DNAME
FROM DEPT 
WHERE LOC = 'BOSTON';




EMP테이블 : 사원정보 테이블

컬럼명		자료형	코멘트
EMPNO		숫자형	사원번호
ENAME		문자형	사원명
JOB		문자형	직책
MGR		숫자형	상위관리자번호
HIREDATE	날짜형	입사일자
SAL		숫자형	연봉
COMM		숫자형	커미션
DEPTNO		숫자형	부서번호



DEPT테이블 : 부서정보 테이블

컬럼명		자료형	코멘트
DEPTNO		숫자형	부서번호
DNAME		문자형	부서명
LOC		문자형	지역(지점)


SELECT EMPNO, ENAME, DEPTNO
FROM EMP
WHERE ENAME = 'SMITH';

SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE DEPTNO = 20;

사원정보 테이블에서 이름과 연봉과 입사일자를 가져와
SELECT 이름과 연봉과 입사일자
FROM 사원정보 테이블

입사일자가 81년 5월 1일 미만인 사원의 사번, 이름을 가져오세요
SELECT EMPNO, ENAME
FROM EMP
WHERE HIREDATE < '1981/05/01';

연봉이 3000이상인 사원의 모든 정보를 가져오시오
SELECT * 
FROM EMP
WHERE SAL >= 3000;




연산자 : 

우선순위 연산자 : ( )
산술연산자 : +(덧셈), -(뺄셈), *(곱셈), /(나눗셈 몫)
비교연산자 : > , >= , < , <= , = 
논리연산자 : AND (모든 조건이 참인 경우만 참, 나머지는 거짓)
	    OR (모든 조건이 거짓인 경우만 거짓, 나머지는 참)
	예시) DEPTNO >= 20 AND DEPTNO <=30   --->   DEPTNO BERWEEN 20 AND 30
DATE자료형(날짜자료형)
문자열결합 연산자 : ||
예시) '문자열1' || '문자열2'




//
//23
//필기
//

- SELECT문

SELECT * | 컬럼명들
FROM 테이블명 
WHERE  조건들
GROUP BY 그룹으로 묶을(묶어야 할) 컬럼들
HAVING 그룹으로 묶은 다음 다시 조건을 거는 경우
ORDER BY 컬럼의 오름차순(ASC-생략가능,디폴트값), 내림차순(DESC) 지정하는 절

- 해석순서
FROM절 -> WHERE절 -> GROUP BY절 -> HAVING절 -> SELECT절 -> ORDER BY절


//연습

DEPT 부서번호 부서명
SELECT DEPTNO, DNAME
FROM DEPT;

10번 부서에 해당하는 사원의 이름 급여 입사일자만 가져오는데
이름은 

SELECT ENAME, SAL, HIREDATE
FROM EMP
WHERE DEPTNO = 10;


SELECT절에서 중복값 제외하는 방법
SELECT DISTINCT DEPTNO, JOB FROM EMP;



- 비교 연산자
<, >, <=, >=
같다 =
다르다 <>, !=, ^=

- 논리 연산자
NOT, AND, OR

- SQL 연산자
BETWEEN 값1 AND 값2, IN (값1, 값2, 값3), LIKE , IS NULL, IS NOT NULL

형식 : 컬럼명 BETWEEN 값1 AND 값2 => 값1~값2 사이
형식 : 컬럼명 IN (값1, 값2, 값3) => 값1,2,3 이 포함되는
형식 : 컬럼명 LIKE '문자열값'
형식 : 컬럼명 IS NULL => NULL값에 해당되는 값이 있는지 확인하는 연산자
형식 : 컬럼명 IS NOT NULL => NULL값에 해당되지 않는 값이 있는지 확인하는 연산자
**오라클에서 NULL의 의미 : 어떤 값이 있는지 모른다, 비어있는 값, 빈 문자열


조건절들은 BOOLEAN값을 가져옴

//연습
10번 부서에서 CLERK직책인 사원의 사번, 이름, 직책, 부서번호
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE BETWEEN DEPTNO = 10 AND JOB = 'CLERK';



LIKE : 문자열 일부 포함여부
와일드카드 : 
% => 무슨 문자열이든 상관이 없다. = 어떤 문자열이든 올 수 있다, 몇 개가 오든 상관없다, 아무것도 오지 않아도 상관없다.
_ => 건너띄는 칸 수가 됨. = 문자 한개를 의미, 어떠한 문자가 오든 한 개

형식 : 컬럼명 LIKE '%값'; => 컬럼의 문자열에 앞에는 어떠한 문자든 올 수 있지만 마지막 문자열이 입력한 값으로 끝나는 문자를 가져옴
예) ENAME LIKE '%N' => 이름이 N으로 끝나는 정보를 가져옴
예) ENAME LIKE '%N%' => 이름 안에 N이라는 문자가 포함되는 정보 모두 가져온다.
예) ENAME LIKE 'N%' => 이름이 N으로 시작하는 정보를 가져옴
예) ENAME LIKE '_N%' => 앞 첫글자에 어떠한 문자가 오든 상관없이 단 한 개의 문자가 와야하고, 두번째 문자가 N이라는 문자가 포함되는 정보를 가져옴
예) ENAME LIKE '%N__(2)' => 앞 글자가 어떠한 문자가 몇 개 오든 상관없이 끝에서 세번째 문자가 N으로 끝나는 정보를 가져옴


- AND 연산자
true AND true : true
true AND false : false
true AND null : null
false AND false : false

false AND null : false
null AND null : null


- OR 연산자
true OR true : true
true OR false : true
true OR null : true
false OR false : false

false OR null : null
null OR null : null



* GROUP BY 형식
SELECT GROUP BY에서 설정한 컬럼들, 또는 그룹함수들
FROM 테이블명
WHERE 조건(어떤 컬럼이던 가능)
GROUP BY 그룹으로 묶을 컬럼명들
HAVING 그룹함수로 지정하는 조건 또는 GROUP BY에 설정한 컬럼으로 만드는 조건만 가능
ORDER BY 컬럼의 정렬을 지정;


* 그룹 함수

- 테이블 내의 행들에 대해서 연산한 후 단 하나의 결과 값으로 되돌리는 함수
- WHERE절에는 사용할 수 없다
- SELECT절, HAVING절 에 사용가능
- 반드시 GROUP BY를 해야만 컬럼과 함께 사용할 수 있다.
- GROUP BY가 없는 경우는 SELECT절에만 그룹함수 사용가능
- 종류 : 
합계 : SUM(컬럼명),
평균 : AVG(컬럼명),
최대값 : MAX(컬럼명),
최소값 : MIN(컬럼명),
행(줄) 수 : COUNT(컬럼명 또는 *) 등이 있음
- 그룹 함수는 NULL값을 제외한다. (COUNT(*)만 포함)


NVL함수 : NULL값을 다른 값으로 대체할 때 사용하는 함수
형식 : NVL(컬럼명, 대체할 값)



//연습
사원정보 부서별로 인원수
SELECT DEPTNO, COUNT(*)
FROM EMP
GROUP BY DEPTNO;

부서별로 연봉의 평균이 2000이상인 부서별, 연봉 평균 자료 가져와
SELECT
FROM EMP
GROUP BY DEPTNO, 
HAVING 





**DML(Data Manipulation Language) 얘빼고 나머진 데이터 이상을 
: 데이터를 조작하는 명령어 = 데이터 조작어
: 데이터를 삽입, 삭제, 변경, 검색(조회)
insert 삽입 => 데이터 추가 기능 명령어
delete 삭제 => 데이터 삭제 기능 명령어 (데이터의 일부제거, 전체제거 가능)
update 변경 => 데이터 갱신(수정) 기능 명령어
select 검색 => 원본은 유지되지만 데이터를 검색해서 가져올 때 변형을 해서 가져올 수 있다. (검색, 조회)
*****반드시 영구적인 반영을 위해서는 TCL(확정 : commit, 되돌리기 : rollback)을 이용해야만 영구반영이 이루어진다.




* INSERT명령문 : DML중에서 데이터의 행 수를 추가할 때 사용하는 명령문

--정식형식 : 테이블의 컬럼을 모두 지정하거나 일부만 지정할 때 사용가능 
(없는 값은 NILL값으로 자동처리/ 단, 지정한 기본값이 있는 경우는 해당 지정값으로 자동처리)

INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ...)
VALUES (값1, 값2, ...);

예시) : DEPT01 =>
INSERT INTO DEPT01 (DEPTNO, DNAME, LOC)
VALUES (10, '운영');	//정식형식은 모든 컬럼을 다 채워주지 않아도 된다 (= 원하는 컬럼만 채워도 된다)
또는
INSERT INTO DEPT01 (LOC, DNAME, DEPTNO)
VALUES ('서울', '운영', 10);	//정식형식은 컬럼의 순서도 내맘대로 넣을수 있음

--단축형식 : 

INSERT INRO 테이블명 VALUES (값1, 값2, ...);
**조건 : 반드시 테이블에 있는 컬럼의 개수만큼 컬럼의 순서대로 모두 값(해당 자료형값)을 넣어야 한다.(컬럼명을 쓰지 않기 때문에 맞춰서 넣어야 하는거임) = 컬럼 개수, 컬럼 순서, 해당 자료형 값

예시) : DEPT01 => //컬럼의 순서 : (DEPTNO, DNAME, LOC)
INSERT INTO DEPT01 VALUES (10, '운영', '서울');

INSERT INTO DEPT01 VALUES (10, '운영'); (X-불가능)
INSERT INTO DEPT01 VALUES ('서울', '운영', 10); (X-불가능)



* UPDATE명령문 : 데이터를 부분 수정할 때 필요한 명령문 (줄 단위로 처리됨)

형식 : 

UPDATE 테이블명
SET 변경할 컬럼명 = 변경할 값1, 변경할 컬럼명 = 값2, ...
WHERE 조건들...
예시) : DEPT01 => 30번 부서인 부서명을 'CLERK'로 변경해라
UPDATE DEPT01
SET DNAME = 'CLERK'
WHERE DEPTNO = 30;



슈도컬럼(PSEUDO) : 처음에는 값이 정해져있지 않으나 실행이 될 때 값이 정해지는 컬럼(의사가 존재하는 컬럼)
- SYSDATE : 현재 날짜의 정보를 가지고 있는 예약어(연산자컬럼)




DELETE명령문 : 데이터를 줄(행) 단위로 삭제하는 경우 처리하는 명령문

형식 : 

DELETE 
FROM 테이블명 
WHERE 조건들...;

//연습
사원정보(EMP01)테이블에서 부서번호가 10인 사원만 제거
DELETE FROM EMP01 WHERE DEPTNO = 10;



//24
//필기
//



<CRUD>
C -> (CREATE) INSERT
R -> (READ) SELECT
U -> UPDATE
D -> DELETE



<DML : 데이터 조작어(DQL : SELECT포함)>
- INSERT : 추가
- DELETE : 삭제
- UPDATE : 변경
- SELECT : 검색, 조회



<SELECT형식>
SELECT 컬럼명 
FROM 테이블명 
WHERE 조건 
GROUP BY 그룹 조건 컬럼명 
HAVING 그룹에 대한 조건 
ORDER BY 컬럼에 대한 오름차순,내림차순(DESC);



//해당 테이블의 구조 보기
DESC 테이블명;



<INSERT형식>
1.
INSERT INTO 테이블명
(컬럼1,컬럼2,...)
VALUES
(값1,값2,...);

2.
INSERT INTO 테이블명 VALUES (값1,값2,...);



<UPDATE형식>
UPDATE 테이블명
SET 컬럼1 = 값1, 컬럼2 = 값2, ...
WHERE 조건들;



<DELETE형식>
DELETE FROM 테이블명
WHERE 조건들...;



<INSERT형식2 (여러 개의 테이블에 데이터 한꺼번에 추가하기)>
--모든 테이블이 같은 형식, 구조, 컬럼의 나열 순서까지 동일한 경우
--테이블명1과 테이블명2의 컬럼기술부를 제거할 수 있는데 => 해당 테이블의 전체 컬럼에 대해 순서대로 값을 넣는 경우만 가능
INSERT ALL
INTO 테이블명1
INTO 테이블명2
VALUES (값1, 값2, 값3, ...)	--값 자리에는 컬럼명으로 대체하여 들어온다.
SELECT (* | 컬럼명1, 컬럼명2, 컬럼명3, ...) FROM 데이터를 끌어올 테이블명 [WHERE 조건들...];

--테이블의 나열 순서는 동일하지만 컬럼의 개수가 다른 경우
INSERT ALL
INTO 테이블명 (컬럼1, 컬럼2) VALUES (값1, 값2)	--값 자리에는 컬럼명으로 대체하여 들어온다.
INTO 테이블명 (컬럼1, 컬럼2, 컬럼3) VALUES (값1, 값2, 값3)	--값 자리에는 컬럼명으로 대체하여 들어온다.
SELECT 컬럼명1, 컬럼명2, 컬럼명3 FROM 데이터를 끌어올 테이블명 [WHERE 조건들...];



//SELECT * FROM EMP WHERE 1=0;
테이블의 양식만 복사함






<DUAL 테이블>
- 오라클에서 제공되는 어느 계정에서나 접근 가능한 테이블
- 산술 연산이나 가상 컬럼 등의 값을 한 번(한 행(ROW))만 출력하고 싶을 때 유용하게 사용할 수 있는 테이블로서 DUMMY 라는 컬럼 한 개로 구성되어 있다.



<숫자함수>
- ROUND : 특정 자리수에서 반올림
형식 : 
ROUND (값) : 정수값으로 반올림한다.
ROUND (값, 소수점자리수) : 지정한 소수점자리수까지만 나타나도록 반올림한다.
예 : 
SELECT ROUND(345.678) FROM DUAL;
예 : 
SELECT ROUND(345.678, 2) FROM DUAL;
*값에 날짜도 가능
예 : 
ROUND (날짜, YEAR) : 6,7월 중 7월부터 반올림
ROUND (날짜, MONTH) : 15,16일 중 16일부터 반올림

- MOD : 나눗셈의 나머지값을 반환
형식 : 
MOD (피젯수, 젯수) : 피젯수를 젯수로 나눈 값의 나머지를 반환

- FLOOR : 소수점 자리수를 무조건 버림 (정수자리값만 표현되며 반올림처리 안함)
형식 : 
FLOOR (값) : 소수점을 지정하는 자리가 없음
예 : 
SELECT FLOOR(345.678) FROM DUAL;

- CEIL : 소수점 자리수를 무조건 버리고 정수자리값을 올림처리
정수자리값만 표현되며 일의 자리값이 무조건 올림처리 됨
형식 : 
CEIL (값) : 소수점을 지정하는 자리가 없음
예 : 
SELECT CEIL(345.118) FROM DUAL;

-TRUNC : 특정 자리수에서 버림
형식 : 
TRUNC (값) : TRUNC (값, 0)과 같음
TRUNC (값, 자리수) : 자리수 - (양수(소수점자리 지정), 음수(정수 자리수 지정))
*값에 날짜도 가능



<슈도컬럼(PSEUDO)> : 처음에는 값이 정해져있지 않으나 실행이 될 때 값이 정해지는 컬럼(의사가 존재하는 컬럼)
- SYSDATE : 현재 시각의 년/월/일 시:분:초에 대한 정보를 가지고 있음.
	출력시 년/월/일까지만 표현 됨.
	문자자료형과 DATE자료형 모두 가진다.

- SYSTIMESTAMP : 현재 시각의 년/월/일 시:분:초.밀리세컨드초 (UTC +시간정보)까지 가지고 있음.
		출력시 해당 정보 모두 표현 됨.
		DATE자료형만 가진다.



<문자함수>
- LOWER (소문자로 변환), UPPER (대문자로 변환)
형식 : 
LOWER ('문자열값'), UPPER ('문자열값')

- INITCAP : 첫 글자만 대문자로, 나머지는 소문자로 변환
형식 : 
INITCAP('문자열값')
예 : 
SELECT INITCAP('DATA BASE') FROM DUAL;
=> Data Base

- CONCAT (문자를 연결) : 문자열 결합 함수, 두 개의 단어만 결합가능
형식 : 
CONCAT('연결할 첫번째 문자열 또는 문자열자료형의 컬럼명', '연결할 두번째 문자열 또는 문자열자료형의 컬럼명')

- LENGTH : 글자의 개수, LENGTHB : 메모리에 차지하는 바이트 수
*영어, 숫자등은 1자당 1Byte, 한글은 버전에 따라 1자당 2Byte ~ 3Byte
형식 : 
LENGTH ('문자열값 또는 문자열자료형의 컬럼명')
LENGTHB ('문자열값 또는 문자열자료형의 컬럼명')

- SUBSTR : 문자열에서 원하는 문자열만큼 추출할 때 사용하는 함수
형식 : 
SUBSTR ('문자열값 또는 문자열자료형의 컬럼명', 시작위치, 추출할 개수)
*시작위치 : 
양수 : 정방향, 왼 -> 오
음수 : 역방향, 오 -> 왼
*값에 날짜도 가능

- REPLACE : 문자열 대체 함수
형식 : 
REPLACE('문자열값 또는 문자열컬럼명'. '구분자') : 대체할 문자는 기본값으로 빈문자열로 대체 됨
형식 : 
REPLACE('문자열값 또는 문자열컬럼명'. '구분자', '대체할문자') : 해당 구분자의 문자열이 대체할 문자로 변경 됨


<함수>
- INSTR : 특정 문자의 위치를 반환하는 함수
형식 : 
INSTR ('문자열값 또는 문자열자료형의 컬럼명', 찾을 글자)
INSTR ('문자열값 또는 문자열자료형의 컬럼명', 찾을 글자, 시작위치, 몇번째 발견)
*시작위치 : 
양수 : 정방향, 왼 -> 오
음수 : 역방향, 오 -> 왼
*N번째 발견
시작위치에서부터 가져올 N번째 발견 된 놈

- LPAD, RPAD (특정 기호로 채우기)
형식 : 
LPAD ('문자열값', 총 칸수, '채울문자 한 개')
RPAD ('문자열값', 총 칸수, '채울문자 한 개')

- TRIM (연속 된 특정 문자 제거하기)
형식 : 
TRIM ('제거할 문자' FROM '문자열값 또는 문자열자료형의 컬럼명')
LTRIM ('문자열값 또는 문자열자료형의 컬럼명', '제거할 문자')
RTRIM ('문자열값 또는 문자열자료형의 컬럼명', '제거할 문자')



<변환함수>
- TO_CHAR : 해당 값을 문자열로 변환해주는 함수
날짜 형식의 데이터를 문자열 형식으로 변환하는 경우
형식 : 
TO_CHAR (문자열로 변환 할 문자열이 아닌값, '포멧형식')
** 포멧형식
포멧형식은 반드시 문자열값으로 표현해준다.
YYYY 또는 YY : 년 4자리 또는 년 2자리
MM : 월 2자리
DD : 일 2자리
HH24 또는 HH12(=HH) : 24시간제 또는 12시간제
MI : 분
SS : 초
FF자리수 : 밀리세컨드초 (예: FF3 => .FFF)
AM : 오전 또는 오후
DAY : 요일
D : 요일을 숫자로 반환 (일-1, 월-2, ..., 토-7)

숫자값 데이터를 문자열 형식으로 변환하는 경우
형식 : 
TO_CHAR (숫자값, '000,000,000') : 총 9칸 준비 + 구분기호 개수(= 11)
=> 채워지지 않은 공간은 무조건 0으로 채운다.
TO_CHAR (숫자값, '999,999') : 총 6칸 준비 + 구분기호 개수(= 7)
=> 채워지지 않은 공간은 한 칸 공백으로 채운다.

** 만약 숫자값이라는 명시를 해주는 키워드가 붙을 경우에 
9 : 값이 있는 곳은 자리수 인식, 값이 없는 곳은 자리수를 무시한다.
0 : 값이 있든 없든 자리수 모두 인식하고 없는 자리수를 0으로 채운다.


- TO_DATE : 날짜자료형이 아닌 값(문자열값)을 날짜자료형으로 변환하는 함수
형식 : 
TO_DATE (날짜자료형값 또는 날짜자료형을 가진 컬럼명, '포멧형식')
** 포멧형식 TO_CHAR함수의 날짜 함수 형식과 동일하다.
** 날짜형식의 자료형 : DATE (년/월/일 -> 시분초정보 까지), TIMESTAMP (년/월/일 시:분:초.밀리세컨드초 까지)


- TO_NUMBER : 숫자가 아닌 값을 숫자형으로 변환하는 함수
형식 : 
TO_NUMBER ('숫자가 아닌 값 또는 컬럼명', '포멧형식')


- NVL : NULL값을 다른 값으로 대체할 때 사용하는 함수
형식 : 
NVL (컬럼명이나 값, NULL을 대체할 값)


- NVL2 : NULL값을 다른 값으로 대채할 때 사용하는 함수 중 하나
형식 : 
NVL2(컬럼명이나 값, NULL이 아닐 때 대체할 값, NULL일 때 대체할 값)


- POWER(N, M) : N의 M제곱승
예 : 
POWER(5, 3) => 5*5*5 = 125

- SQRT(N) : N의 루트(제곱근)값
예 : 
SQRT(9) => 3


//
//25
//필기
//


**SELECT절에 오는 모든 함수는 단일 값만을 반환하는 함수여야만 한다.

<DECODE 함수>(JAVA에 SWITCH문 유사)
형식 : 
SELECT DECODE(
기준컬럼명, 
케이스값1, 실행값1,
케이스값2, 실행값2, 
케이스값N, 실행값N,
마지막 실행값)		<<마지막 값 부분은 케이스값이 필요없음,
AS 별칭 FROM 테이블명;	    SWITCH~CASE의 default의 기능과 동일

<CASE WHEN 함수>(JAVA에 IF문 유사)
형식 : 
SELECT CASE [기준컬럼명, ]
WHEN 조건1 THEN 실행값1
WHEN 조건2 THEN 실행값2
...
ELSE 실행값
END AS 별칭 FROM 테이블명;


================================================

<DDL (데이터 정의어)>

생성 : CREATE문 
삭제 : DROP문
변경/수정 : ALTER문 - 컬럼의 (추가 ADD, 변경 MODIFY, 삭제 DROP, 이름변경 RENAME)
테이블의 데이터를 전체 영구삭제 : TRUNCATE
이름변경 : RENAME문


<<CREATE문>>

<테이블생성문 형식>
CREATE TABLE 테이블명(
컬럼명 자료형 [제약조건1 제약조건2 ...],
...
컬럼명 자료형 [제약조건1 제약조건2 ...]
);


<<ALTER문>>
(테이블이나 사용자 계정등의 정의(구조)를 변경하는 명령)

<(ADD)-테이블 컬럼을 추가하는 명령형식>
//제약조건 가능
-다중 컬럼 추가
ALTER TABLE 테이블명
ADD (추가할 컬럼명 자료형, 추가할 컬럼명 자료형, ..., 추가할 컬럼명N 자료형);

- 단일(한 개의) 컬럼 추가
ALTER TABLE 테이블명
ADD 추가할 컬럼명 자료형;

<(MODIFY)-테이블의 컬럼 정보를 수정하는 명령> 
//컬럼의 자료형을 변경하는데 해당 자료형과 다른 자료형으로 변경할 땐 컬럼의 데이터들이 모두 비어(NULL)있어야 한다
//같은 자료형으로 변경할 땐 들어있는 데이터 이상의 범위내에서만 줄이거나 늘릴 수 있음
//NUMBER자료형은 사이즈를 늘리는 것만 가능 (줄이는거 불가능)
//제약조건 불가
-다중 컬럼 수정
ALTER TABLE 테이블명
MODIFY (기존 컬럼명 변경할 자료형, 기존 컬럼명 변경할 자료형, ..., 기존 컬럼명N 변경할 자료형);

- 단일(한 개의) 컬럼 수정
ALTER TABLE 테이블명
MODIFY 기존 컬럼명 변경할 자료형;

<(DROP)-테이블의 컬럼을 삭제하는 명령형식>
- 단일(한 개의) 컬럼 삭제
ALTER TABLE 테이블명
DROP COLUMN 삭제할 컬럼명;

-다중 컬럼 삭제
ALTER TABLE 테이블명
DROP (삭제할 컬럼명, 삭제할 컬럼명, ..., 삭제할 컬럼명N);

<(RENAME)-테이블의 컬럼명 변경하는 명령형식>
ALTER TABLE 테이블명
RENAME COLUMN 기존의 컬럼명 TO 변경할 컬럼명;


<<RENAME문>> 
(테이블의 이름을 변경)

RENAME 기존의 테이블명 TO 변경할 테이블명;


DROP TABLE 테이블명;
DROP TABLE 테이블명 PURGE; //휴지통도 안가고 영구삭제
TRUNCATE TABLE 테이블명;



================================================



<자료형>
데이터타입, 컬럼(속성)에 들어갈 데이터의 유형을 결정한다.
//들어갈 값의 범위를 지정

문자형
CHAR(크기[BYTE]| CHAR) (고정형 문자 자료형) : 1~2000BYTE	예) CHAR(5 CHAR)
VARCHAR2(크기[BYTE]| CHAR) (가변형 문자 자료형) : 1~4000BYTE
LONG : 가변형 문자 자료형 : 최대 2GB까지 표현 가능(권장하지 않음. 이전버전화의 호환성을 위해 유지)

숫자형 - 정수, 실수 포함
NUMBER : 부동 소수점 자리수 숫자형	*입력한 숫자 그대로
NUMBER(자리수) : 정수값의 자리 수를 지정
NUMBER(소수점 제외 총 자리수, 소수점 자리수) : 고정 소수점 자리수 숫자형
정수값(총 차리수-소수점 자리수).지정한 소수점 자리수(초과된 소수점은 반올림으로 처리됨)
예) NUMBER(7, 2) => 12345.56 - 소수점 제외하고 총 자리수(1234556=7) , 소수점 자리수(.56=2)

날짜형
DATE : 년/월/일 시:분:초 까지 입력 가능한 날짜형 자료형
TIMESTAMP : 년/월/일 시:분:초.밀리세컨드초 까지 입력 가능한 날짜형 자료형

BIG DATA TYPE
BLOB : BINARY LARGE OBJECT -> 이진데이터 전용 큰 사이즈를 기술할 수 있는 자료형(최대 4GB - 1BYTE 까지 가능 //4기가 빼기 1바이트)
CLOB : CHARACTER LARGE OBJECT -> 가변 길이 문자데이터 전용 큰 사이즈를 기술할 수 있는 자료형(최대 4GB - 1BYTE 까지 가능)
**데이터 입력과 출력이 쉽지 않아 사용을 권장하지 않는 자료형이다.




//
//26
//필기
//



<테이블생성문 형식>
CREATE TABLE 테이블명(
컬럼명 자료형 [제약조건1 제약조건2 ...],
...
컬럼명 자료형 [제약조건1 제약조건2 ...]
);



<<제약조건>>
CONSTRAINT : 테이블의 속성을 지정할 때 해당 속성에 들어오는 값의 범위나 크기를 제외한 나머지에 대한 조건을 기술하는 것을 말함.


<NOT NULL 제약조건 (필수 입력)>
해당 속성의 값에 NULL값이 들어오면 안되게끔 하는 조건
형식 : 테이블을 설정할 때 
컬럼명 자료형 NOT NULL



<<데이터 무결성>>

* 무결 : 결점이나 결함이 없는 상태
* 데이터 무결성이란 데이터 베이스 내의 데이터에 대한 정확성, 일관성, 유효성, 신뢰성을 보장하기 위해 데이터 변경 혹은 수정 시 여러가지 제한을 두어 데이터의 정확성을 보증하는 것을 말한다. 관계형 관리시스템(RDBMS)에서는 설계 시 무결성을 고려한 설계로 데이터를 보호할 필요가 있다.
키 = 필드 = 컬럼 = 속성

* 제약조건 (CONSTRAINT)
1) 개체(객체) 무결성 (Entity integrity) => 기본키 (primary key => UNUQUE + NOT NULL)
**UNUQUE : 중복값 배제(단, 이놈은 NULL값 허용)
**NOT NULL : NULL값 배제(단, 이놈은 중복값 허용)
모든 테이블이 기본 키(primary key)로 선택된 필드(column)를 가져야 한다. 기본 키로 선택된 필드는 고유한 값(Unique-중복된 값을 허용안함)을 가져야 하며, 빈 값(Null)은 허용하지 않는다.
- UNUQUE 제약 조건 또는 PRIMARY KEY 제약 조건을 설정하여 테이블의 기본 키나 식별자로 사용되는 열의 무결성을 강제하도록 한다.

2) 참조 무결성 (Referential integrity) => FOREIGN (외래키) 
**(부모와 자식) 주종관계의 테이블이 존재해야 한다.
**노예테이블은 주인테이블이 주는 데이터만 받을 수 있음, 계속 받을 수 있음(중복가능), 안주면 없음(NULL가능), 주인테이블에 없는 데이터는 못받음
참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것을 말한다. 외래키와 관련있는 무결성. 외래키 값은 NULL이거나 참조 릴레이션의 기본 키 값과 동일해야함. 즉 릴레이션(= 테이블)은 참조할 수 없는 외래키 값을 가질 수 없다.

=============================================================================================================================

3) 도메인 무결성 (domain integrity)
열에 대한 데이터 무결성을 보장하기 위한 것으로 컬럼의 값이 널 값을 허용하지 않거나, 데이터 타입이 적절한지, 올바른 형식의 데이터가 저장되었는지 등을 확인하는 것이다. 
자료형지정, 체크(CHECK), 디폴트(DEFAULT), NOT NULL 등의 제약(constraints)들로 이러한 도메인 무결성을 보장할 수 있다. 예를 들어, 생일 날짜 컬럼에 알파벳이 입력되는 경우 도메인 무결성을 위반하는 것이라 볼 수 있다.
* 도메인 : 속성(Column) 하나가 가질 수 있는 모든 값의 집합.

=============================================================================================================================


<<키의 종류>>
1) 슈퍼 키 (SUPER KEY) => 2개 이상의 컬럼을 조합해서(복합키중에) 유일성이 만족되면 슈퍼 키
슈퍼 키는 테이블에 존재하는 필드들의 부분집합으로써, 유일성을 만족해야 한다.

2) 후보 키 (CANDIDATE KEY) => 기본 키가 될 수 있는 컬럼들
후보 키는 이름에서도 나타나듯이 기본 키가 될 수 있는 후보를 말한다. 후보키는 테이블에 존재하는 전체 필드의 부분집합으로써, 유일성(uniqueness)과 최소성(irreducibility)을 만족해야 한다. 유일성은 모든 레코드에서 해당 필드에 중복된 값이 나타나지 않는다는 속성이며, 최소성은 최소한의 필드로 레코드를 유일하게 구별할 수 있어야 한다는 속성이다.

3)** 기본 키 (PRIMARY KEY) => 반드시 한 테이블안에 PRIMARY KEY 조건은 한 개만 존재해야 함
기본 키는 테이블에서 특정 레코드를 구별하기 위해 후보 키 중에서 선택된 고유한 식별자를 말한다. 기본 키는 후보 키와 같이 유일성과 최소성에 대한 속성을 가져야 하며, NULL값을 가질 수 없다. 기본 키를 설정할 때는 아래와 같은 두 가지 사항을 고려하는 것이 좋다.

- 값이 자주 변경되지 않는 것을 선택 : 
기본키로 선택 된 필드에 저장되는 데이터가 많은 자리수를 갖는 정수거나 많은 문자를 포함하는 문자열이라면, 기본 키를 비교할 때 그 만큼 많은 비용이 소모 될 것이다. 그러므로, 짧고 단순한 형식의 데이터를 저장하는 필드를 기본 키로 설정하는 것이 DBMS의 성능 측면에서 유리하다.

4) 대체 키 (ALTERNATE KEY)
후보 키 중에서 기본 키로 선택 된 것들을 제외한 모든 키를 대체 키라고 한다.

5) 복합 키 (COMPOSITE KEY)
두 개 이상의 필드를 포함하는 키를 복합 키라고 한다. 앞에서 예를 들은 {id, dept_id}와 같은 키는 복합 키의 한 예시이다.

6)** 외래 키 (FOREIGN KEY) => 주테이블의 기본키로 만든 컬럼이 외래키
외래 키는 한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키를 말한다. 외래 키는 한 테이블의 레코드에서 다른 테이블의 레코드를 참조하기 위해 이용된다.

하나의 필드 또는 전체 필드의 부분집합으로 구성된다.
중복된 값과 NULL값을 가질 수 있다.
반드시 참조되는 테이블에서 유일한 값을 갖는 필드를 참조해야 한다. 예를 들어, 외래 키는 참조되는 테이블의 기본 키를 참조할 수도 있다.
참조되는 테이블에 존재하는 값만을 가져야 한다. NULL값은 실제로 존재하는 값은 아니지만, 많은 데이터베이스에서 NULL값은 예외로 한다.



<제약 조건 확인>

- P : PRIMARY KEY

- R : FOREIGN KEY (REFERENCES)

- U : UNIQUE

- C : NOT NULL, CHECK

데이터 딕셔너리 : 메타데이터(데이터를 위한 데이터)를 가지고 있는 테이블

제약조건에 대한 전반적인 데이터를 가지고 있는 데이터사전(데이터 딕셔너리) 테이블 :
USER_CONSTRAINTS


<데이터 딕셔너리 쿼리문 예시>

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP02';

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP03';




--PRIMARY KEY 조건
반드시 한 테이블안에 PRIMARY KEY 조건은 한 개만 존재해야 함
컬럼레벨 방식으로 기술하는 경우는 한 개의 컬럼에만 PRIMARY KEY 조건을 사용할 수 있다.
테이블레벨 방식으로 기술하는 경우는 여러 개의 컬럼을 조합(복합키)하여 PRIMARY KEY 조건을 사용할 수 있다.


--복합키로 기본키를 지정 : 반드시 테이블 레벨 정의 방법 이용 (컬럼레벨 정의 방법 불가)
**테이블레벨 정의 방법 :  컬럼을 정의하는 부분에 제약조건을 정의하는 방법



<제약 조건 이름 설정>
 
-- 제약 조건 이름(CONSTRAINT_NAME) 규칙

[테이블명]_[컬럼명]_[제약 조건 유형]
예: EMP04_EMPID_PK / EMPID_PK / EMP04_PK / PK
제약조건 정식형식 : CONSTRAINT 제약조건이름 제약조건유형
- 컬럼레벨 정의 방법 : 컬럼 안에 제약 조건을 같이 기술하는 것

<<해당 컬럼의 제약조건 검색>>
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_CONS_COLUMNS;




<제약 조건 추가, 삭제, 변경>

-- 추가 형식 : ADD CONSTRAINT 제약조건명 제약조건유형(컬럼명)
**NOT NULL은 ADD로 추가할 수 없기 때문에 MODIFY 에서 수정으로 추가해 줘야 한다.
- 예 : 
ALTER TABLE DEPT03
ADD CONSTRAINT DEPT03_DEPTNO_PK PRIMARY KEY (DEPTNO);



-- 수정 형식 : MODIFY 컬럼명 추가할제약조건
- 예 : 
ALTER TABLE DEPT03
MODIFY DNAME NOT NULL;



-- 삭제 형식 : DROP CONSTRAINT 제약조건명;
**NOT NULL은 제약조건명을 자동으로 부여받는 것만 가능하므로,
제약조건 데이터사전이나 제약조건을 검색하여 이름을 찾은 후 삭제 가능.
- 예 : 
ALTER TABLE DEPT03
DROP CONSTRAINT DEPT03_DEPTNO_PK;




<CHECK 제약 조건(값의 범위나 조건을 지정)>
- 입력 값이 조건에 맞지 않으면 DB에서 받지 않는다. 오류
- 입력 값의 범위를 지정 할 수 있다.
- 입력 할 수 있는 값의 범위를 설정해 줌

컬럼레벨 정의형식 : 
컬럼명 CONSTRAINT [제약조건명] [제약조건] (해당 컬럼값의 범위)
컬럼명 [제약조건명] [제약조건] (해당 컬럼값의 범위)

형식 : 
CREATE TABLE 테이블명 (
COL1 VARCHAR2(20) CONSTRAINT 제약조건명 제약조건,     --제약조건에 이름지정
COL2 VARCHAR2(20) CHECK(값의 범위나 조건 지정),    --이름을 지정하지 않는 경우
COL3 VARCHAR2(20)
);





<FOREIGN KEY(참조키, 외래키) 제약조건>
- 주인테이블의 기본키를 이용하여 노예테이블에 일반컬럼이나 기본키로 사용하는 방법
- 반드시 주인테이블의 기본키로만 이용할 수 있다.
- 반드시 주인의 기본키 속성(컬럼)안에 들어있는 값만을 가져다 쓸 수 있다. 그 이외의 값은 쓸 수 없다 (단, NULL은 사용가능)
- 주인의 기본키 속성값을 가져다 쓸 수 있으면서 중복으로 사용가능
 
컬럼레벨 방식 단축형식 : 
노예의 컬럼명 주인의 기본키자료형 REFERENCES 주인테이블명(주인테이블 기본키컬럼명)

정식형식 : 
CONSTRAINT [테이블명]_[컬럼명]_[제약조건명칭] FOREIGN KEY(노예테이블에 연결할 컬럼명) 
REFERENCES 주인테이블명(주인테이블 기본키컬럼명)


INSERT ALL INTO DEPT01 VALUES (DEPTNO, DNAME, LOC) SELECT * FROM DEPT;

SELECT * FROM DEPT01;

CREATE TABLE EMP06 (
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10) NOT NULL,
JOB VARCHAR2(9),
DEPTNO NUMBER(4) REFERENCES DEPT01(DEPTNO)
);


- 주종관계가 존재할 때 주인테이블은 먼저 제거되지 않는다
- 주종관계가 존재할 때는 노예테이블 먼저 제거해야 한다.
- 주종관계가 존재할 때 주인테이블을 제거하려면 모든 노예테이블을 지워줘야 가능하다.
단, DROP TABLE 주인테이블명 CASCADE CONSTRAINTS; 을 사용하면 주인테이블만 제거가능





<DEFAULT 제약조건>
- 해당 속성(컬럼)에 아무런 데이터를 넣지 않는 경우 기본으로 넣을 값을 설정할 수 있는 조건

형식 : 
컬럼명 DEFAULT 해당 자료형에 맞는 값으로 지정
예 : 
컬럼명 자료형 DEFAULT 0 		--숫자형
컬럼명 자료형 DEFAULT '가'		--문자형
컬럼명 자료형 DEFAULT SYSDATE	--날짜형

**조건 : 반드시 제약조건 중 가장 처음에 기술해야 한다.
실질적으로 제약조건은 아님 그래서 제약조건란에 표시가 되지 않음




//
//27
//필기
//




TCL(Transaction Control Language) : 트랜젝션(작업)을 제어하는 명령어 = 트랜젝션 제어어
commit : 데이터베이스에 전체 데이터의 갱신결과를 영구적으로 확정하는 기능
rollback : 데이터베이스에 전체 데이터의 갱신 결과를 영구적으로 전체 되돌리는 기능
checkpoint(savepoint명령) : rollback하는 곳의 시점을 지정하여 전체 rollback이 아닌 원하는 지점까지의 rollback기능을 제공하는 명령어



<트랜잭션(Transaction)>
- 데이터베이스에서 데이터를 처리하는 하나의 논리적인 작업 단위를 의미

- COMMIT
  저장되진 않은 모든 데이터를 데이터베이스에 저장하고,
  현재의 트랜잭션을 종료하는 명령. 즉, 정상 처리되어 확정한다는 것
  Transaction(INSERT, UPDATE, DELETE) 작업내용을 DB에 저장.

- SAVEPOINT
  현재까지의 트랜잭션을 특정 이름으로 지정하는 명령.

- ROLLBACK
  저장되지 않은 모든 데이터 변경사항을 취소하고,
  현재의 트랜잭션을 끝내라는 명령.
   Transaction(INSERT, UPDATE, DELETE) 작업내용을 취소.

- 자동 COMMIT과 자동 ROLLBACK이 되는 경우
  SQL*PLUS 정상 종료는 자동 COMMIT, 비정상 종료는 자동 ROLLBACK
  DDL과 DCL 명령문이 수행 된 경우 자동 COMMIT



<트랜잭션 조건(ACID)>
1. 원자성(Atomicity) : 트랜잭션은 모두 다 정상적으로 완료되거나 아니면 모두 다 처리가 되지 않아야 한다.

2. 일관성(Consitency) : 트랜잭션은 어느 곳에서든 어느 시점에든 동일하게 데이터가 유지되어야 한다.

3. 독립성(= 고립성 = Isolation) : 하나의 트랜잭션이 실행되면 다른 작업은 해당 트랜잭션 중간에 끼어들 수 없어야 한다. 
트랜잭션은 다른 트랜잭션과 독립적으로 실행되어야 한다.

4. 영속성(= 지속성 = Durability) : 작업이 완료(COMMIT) 된 트랜잭션은 시스템의 에러가 발생되어도 영구적으로 데이터의 저장이 되어야 한다.






<<서브쿼리(SUB QUERY)>>
- 서브쿼리는 하나의 SQL문 안에 포함된 또 하나의 SELECT문을 의미함.
- 서브쿼리를 포함하고 있는 쿼리를 메인쿼리, 포함된 또 하나의 쿼리를 서브쿼리하고 한다.
- 서브쿼리는 비교 연산자의 오른쪽에 기술해야 하고 반드시 괄호로 묶어야 한다.
   (예외, INSERT ALL INTO 문의 SELECT절, CREATE TABLE 복제문의 SELECT절 등)
- 서브쿼리는 메인쿼리가 실행되기 전에 한 번만 실행된다.
- 단일 행 서브쿼리, 다중 행 서브쿼리 모든 서브쿼리의 SELECT절 안의 컬럼은 한 개여야만 한다.

<단일 행 서브쿼리(Single Row)>
- 오직 하나의 ROW(줄)만을 반환
- 단일 행 비교 연산자(=, >, >=, <, <=, <>)를 사용

<다중 행 서브쿼리>
- 서브쿼리에서 반환되는 결과가 하나 이상의 행일 때 사용
- 다중 행 연산자(IN, ANY, ALL)를 사용


<예시 : >
단일 행 서브쿼리
SELECT * FROM EMP WHERE DEPTNO >= (SELECT DEPTNO FROM DEPT WHERE DEPTNO = 10);
다중 행 서브쿼리
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE DEPTNO <> 40);



<서브쿼리에서 그룹함수 사용법>
예시 : 평균 급여보다 더 많은 급여를 받는 사원 검색
SELECT ENAME, SAL FROM EMP 
WHERE SAL > (SELECT AVG(SAL) FROM EMP);



<ALL 연산자>
- 컬럼명 < ALL(100, 200, 300) -- 최소값(100)보다 작다. (소<소)
- 컬럼명 > ALL(100, 200, 300) -- 최대값(300)보다 크다. (대>대)

<ANY 연산자>
- 컬럼명 < ANY(100, 200, 300) -- 최대값(300)보다 작다. (소<대)
- 컬럼명 > ANY(100, 200, 300) -- 최소값(100)보다 크다. (대>소)




<서브쿼리를 이용한 데이터 추가>

INSERT INTO EMP03 
SELECT * FROM EMP;

INSERT INTO DEPT01 
SELECT * FROM DEPT;




<서브쿼리를 이용한 데이터 변경>

UPDATE DEPT01
SET LOC = (SELECT LOC FROM DEPT01 WHERE DEPTNO = 40)
WHERE DEPTNO = 10;

- 서브쿼리를 이용한 두 개 이상의 컬럼에 대한 값 변경(단일행 다중컬럼)
UPDATE DEPT01
SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 30) 
WHERE DEPTNO = 10;

- 서브쿼리를 이용한 두 개 이상의 컬럼에 대한 두 개 이상의 값 변경(다중행 다중컬럼)
UPDATE DEPT01
SET DNAME = (SELECT DNAME FROM DEPT WHERE DEPT.DEPTNO = EMP01.DEPTNO);




<서브쿼리를 이용한 데이터 삭제>

DELETE FROM EMP01
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');







<기존 테이블 데이터까지 복제할 때 새 테이블에 컬럼 추가하면서 만드는>

CREATE TABLE EMP01
AS SELECT '테이블별칭'.*, '한번에 지정할 값' AS DNAME FROM 가져올테이블 '테이블별칭';
**테이블의 별칭은 AS 사용불가 반드시 한칸공백으로 구분



<기존 테이블 데이터까지 복제 방법2>

CREATE TABLE EMP01
AS SELECT 테이블별칭.* FROM 가져올테이블 테이블별칭;





//
//28
//필기
//




<<조인 (JOIN)>>

**JOIN은 각 테이블간에 공통된 컬럼(조건)으로 데이터를 합쳐 표현하는 것.


//조인의 유형

<내부 조인 (INNER JOIN) : (= 교집합)>
- 두 테이블에 공통으로 존재하는 컬럼을 이용하여 합치는 방식

1. 동등 조인 (Equi Join) : 공통 존재 컬럼의 값이 같은 경우를 추출하는 조인 방식
(INNER JOIN, ANSI INNER JOIN)

2. 교차 조인 (CROSS JOIN) : 조인 조건이 없는 조인 방식
(CROSS JOIN, ANSI CROSS JOIN)



<외부 조인 (OUTER JOIN) : (= A 또는 B 또는 합집합)>
- 특정 테이블의 모든 데이터를 기준으로 다른 테이블의 정보를 추출(다른 테이블에 값이 없어도 출력됨)

1. 왼쪽 외부 조인 (LEFT OUTER JOIN) = A : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출
(LEFT OUTER JOIN, ANSI LEFT OUTER JOIN)

2. 오른쪽 외부 조인 (RIGHT OUTER JOIN) = B : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출
(RIGHT OUTER JOIN, ANSI RIGHT OUTER JOIN)

3. 완전 외부 조인 (FULL OUTER JOIN) = 합집합 : 양쪽의 모든 데이터를 추출
(ANSI FULL OUTER JOIN)



*Equi Join (동등 조인, 가장 많이 사용)
- WHERE절에서 조인 조건을 사용 (권장사항 : 조인 조건 개수 = 연결 테이블 수 - 1 이상)
- 명확성을 위해 컬럼명 앞에 테이블명 또는 테이블 별칭을 설정

형식 : 
SELECT [테이블별칭1.]컬럼명, [테이블별칭1.]컬럼명, [테이블별칭2.]컬럼명, [테이블별칭2.]컬럼명
FROM 테이블명1 [테이블별칭1], 테이블명2 [테이블별칭2]
WHERE 테이블명1.동일한값의컬럼명 = 테이블명2.동일한값의컬럼명

--부서번호를 기준으로 같은 값을 가진 사원 테이블과 부서 테이블 결합 
SELECT ENAME, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;



*Self Join : 동일 테이블 사이의 조인 
- 반드시 테이블의 별칭이 존재해야 한다.
- 반드시 컬럼을 명시할 경우 테이블의 별칭을 생략할 수 없다.




**ANSI Join (미국표준연구소 표준 조인)
- 다른 DBMS와의 호환성을 위해서는 ANSI 조인을 사용하는 것이 좋다.

*ANSI Inner Join (동등조인과 동일하게 처리)
형식 : 
SELECT [테이블별칭 또는 테이블명.]컬럼명1, ...
FROM 왼쪽기준이되는 테이블명 [테이블별칭]
[INNER(디폴트)] JOIN 오른쪽기준이되는테이블명 [테이블별칭]
ON 조인조건
WHERE 조인조건 이외의 조건 기술; 




**USING을 이용한 조인 조건 지정, ON대신 사용가능.
(단, 조인 조건에 사용되는 컬럼명이 동일해야 한다.)
USING을 사용하는 경우 해당 컬럼이 맨 앞에 딱 한 번만 표현된다.

형식 : 
ON 테이블1의(컬럼명) = 테이블2의(컬럼명) (두 컬럼명이 같을 때)
=> USING (컬럼명)




<외부 조인>
- OUTER JOIN : 2개 이상의 테이블이 조인될 때 어느 한쪽 테이블엔 데이터가 존재하는데, 다른 쪽 테이블에는 데이터가 존재하지 않는 경우에, 데이터가 누락되는 문제를 해결하기 위해 사용되는 조인 기법임.


1. LEFT OUTER JOIN : FROM절의 테이블에 해당되는 값을 모두 표현하고, 그 뒤에 JOIN절에 해당하는 테이블의 값을 표현하는 방식. 해당 값이 없는 컬럼은 NULL처리 함. (LEFT OUTER JOIN, ANTI LEFT OUTER JOIN)


2. RIGHT OUTER JOIN : JOIN절에 해당하는 테이블의 값을 모두 표현하고, 그 뒤에 FROM절의 테이블에 해당되는 값을 표현하는 방식. 해당 값이 없는 컬럼은 NULL처리 함. (RIGHT OUTER JOIN, ANTI RIGHT OUTER JOIN)


3. FULL OUTER JOIN : 조인할 두 테이블의 값을 모두 표현하고, 해당 값이 없는 컬럼은 NULL처리 함. (ANSI FULL OUTER JOIN)
FULL OUTER JOIN은 ANSI조인만 가능하기 때문에 (+)아우터 연산자를 사용하지 못한다


*조인에서 권장사항 : 최대 5개 이상의 테이블 정도만 조인해라



<**여러 개의 테이블을 JOIN>
여러개의 JOIN절이 존재할 경우 반드시 JOIN절 마다 ON절이 존재해야 한다.

SELECT E.EMPNO, E.ENAME, D.DEPTNO, S.DEPARTMENT_NAME 
FROM EMP E
JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO
JOIN DEPARTMENTS S 
ON E.DEPTNO = S.DEPARTMENT_ID;




<(+) : OUTER 연산자의 조건>

- 하나의 조건에 존재하는 컬럼에 동시에 사용할 수 없다.
예)
EMP.DEPTNO(+) = DEPT.DEPTNO(+) [불가능] / EMP.DEPTNO(+) = DEPT.DEPTNO [가능]

- 여러 개의 테이블을 조인하는 경우 아우터 연산자는 동일한 테이블의 동일한 컬럼에 아우터 연산자를 연속하여 사용할 수 없다.
예)
EMP.DEPTNO(+) = DEPT.DEPTNO AND EMP.DEPTNO(+) = DEPARTMENTS.DEPARTMENT_ID [불가능]
EMP.DEPTNO(+) = DEPT.DEPTNO AND EMP.DEPTNO = DEPARTMENTS.DEPARTMENT_ID(+) [가능]




<USING(컬럼명) 조건>

- 반드시 조인하는 테이블에 동일한 컬럼이 존재해야 한다.
- 반드시 SELECT절의 컬림이 *(전체)인 경우만 가능하다.




<세미 조인(SEMI-JOIN)>
IN, EXISTS 연산자를 이용해 서브쿼리에 있는 데이터에 대해서만 메인쿼리에 추출하는 조인 방법

예 : 
SELECT * FROM DEPT B
WHERE EXISTS(SELECT * FROM EMP E WHERE E.DEPTNO = B.DEPTNO);



<안티 조인(ANTI-JOIN)>
NOT IN, NOT EXISTS 연산자를 이용해 서브쿼리에 없는 데이터만 메인쿼리에서 추출하는 조인 방법

예 : 
SELECT * FROM DEPT B
WHERE NOT EXISTS(SELECT * FROM EMP E WHERE E.DEPTNO = B.DEPTNO);

예 : 
SELECT * FROM EMP E
WHERE NVL(E.DEPTNO, 0) NOT IN(SELECT DEPTNO FROM DEPT);




<카타시안 조인(CATASIAN PRODUCT)>
조인 조건이 없는 조인
안시조인이 아닌 교차조인(CROSS JOIN)
- 컬럼은 해당 테이블의 컬럼을 모두 합한 개수만큼 
- 행(줄)은 해당 테이블의 행(줄) 수를 모두 곱한 개수만큼
예 : 
SELECT * FROM EMP E, DEPT D;






//
//29
//필기
//





<<View(가상테이블)>>

- 테이블과는 달리 데이터 저장공간이 없다.
- 뷰는 단지 쿼리문을 저장하고 있는 객체.

- 뷰는 실제 자료를 갖지 않지만, 뷰를 통해 테이블을 관리할 수 있다.

- 하나의 테이블에 뷰의 개수는 제한이 없다.

- 뷰이름 권장사항
view_테이블명
테이블명_view
view_테이블명1_테이블명2

- 문법 (Syntax = 형식)
CREATE VIEW 뷰이름
AS
SELECT 컬럼명 FROM 테이블명 [WHERE 조건];



<뷰 성격에 따른 가능 범위>

- <단순뷰 (SIMPLE VIEW)> : 
VIEW를 생성할 서브쿼리에 조인 조건없이 1개의 테이블로 만들어지는 간단한 VIEW. 하나의 TABLE에서 뽑아오며 함수를 사용안한다.
DML(INSERT, UPDATE, DELETE) 사용 가능

- <복합뷰 (COMPLEX VIEW)> : 
여러 개의 테이블이 JOIN되어 생성되는 것. 하나 이상의 TABLE에서 뽑아오며 함수(GROUP BY HAVING등과 같은 함수)를 사용한다.
DML(INSERT, UPDATE, DELETE) 사용 *불가능

- <인라인 VIEW (INLINE VIEW)> : 
여러 번 사용할 필요없이 1회만 필요한 VIEW일 경우 SQL명령의 FROM절에 VIEW의 서브쿼리 부분을 바로 적어주면 되며 이런 일회용 VIEW를 말함.





//*CREATE OR REPLACE VIEW 뷰이름 FROM 테이블 WHERE 조건;
- 해당 뷰이름으로 만들어져 있다면 재정의를 하고, 없다면 만들어라는 식





<<인덱스(Index)>>

- 데이터베이스 테이블에 있는 데이터를 빨리 찾기 위한 용도의 데이터베이스 객체
- 일종의 색인기술 (목차)
- 테이블에 index를 생성하게 되면 index Table을 생성해 관리한다.
- 인덱스는 테이블에 있는 하나 이상의 컬럼으로 만들 수 있다.

- 가장 일반적인 B-tree(Binary Search Tree(이진검색))인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진 테이블의 행(줄, ROW)으로 저장된 주소 값으로 구성된다.

- 인덱스는 1개 이상의 컬럼으로 생성할 수 있으며, 최대 32개의 컬럼까지 지정하여 생성할 수 있다.
- 2개 이상의 컬럼으로 생성된 인덱스를 복합 인덱스라고 부른다.
- 테이블에 종속적이다.
- 기본키(주 키 = PRIMARY KEY), 유일키(UNIQUE)를 생성 할 때 자동으로 인덱스가 생성됨
- 되도록 3개 미만의 컬럼으로 만드는게 좋음


<INDEX를 사용해야 할 컬럼> : 
- where절이나 조인 조건에서 자주 사용되는 열에 생성
단, 컬럼이나 값에 대한 가공이 없어야 한다.
예 : 
SUBSTR(DEPTNO, 1, 2) = 10 (X)
DEPTNO = 10 (O)

- 조회결과가 전체행의 5 ~ 15% 정도로 읽어들일 것으로 예상되는 컬럼
단, 5 ~ 15% 라도 데이터가 *너무 많을 경우에는 인덱스를 사용해도 소용이 없을 수 있다.
그런 경우에는 다른 방법으로(페이징처리, 등) 처리를 해주는 것이 좋다.


<INDEX를 사용하지 말아야 할 컬럼> : 
- 테이블에 데이터가 너무 적거나(5%이하) 또는 15%이상의 데이터가 있는 경우
- where절에 자주 사용되지 않는 열은 사용되지 않는다.
- 중복값이 많은 경우
- 테이블이 자주 갱신될 때
- 값에 NULL이 많은 컬럼


<인덱스 생성>
//형식 (= 문법 = SYNTAX)
CREATE INDEX [계정명(= 스키마명).]인덱스명 ON [계정명.] 테이블명((인덱스로 만들)컬럼1, 컬럼2, 컬럼3,....);

**UNIQUE인덱스 생성
반드시 중복값이 없는 컬럼이거나 PRIMARY KEY 제약조건이 걸려있는 컬럼에만 생성가능
//형식
CREATE UNIQUE INDEX [계정명(= 스키마명).]인덱스명 ON [계정명.] 테이블명((인덱스로 만들)컬럼1, 컬럼2, 컬럼3,....);



<인덱스 재생성>
//형식 (= 문법 = SYNTAX)
CREATE INDEX 인덱스명 ON 테이블명((인덱스로 만들)컬럼명, 컬럼명,....);

오라클은 ALTER INDEX 문을 사용해서 인덱스 컬럼 변경 불가.
인덱스의 컬럼을 추가, 제거 또는 순서를 변경하기 위해서는
인덱스를 삭제(DROP)다시 생성(CREATE) 해야 한다.



<인덱스 수정>
- 인덱스명 변경(인덱스명만 변경가능, 컬럼 추가, 삭제, 변경 불가)
//형식 (= 문법 = SYNTAX)
ALTER INDEX 기존인덱스명 RENAME TO 변경인덱스명;
//예 : 
ALTER INDEX PERSON_INDEX_NM_MAIL RENAME TO PERSON_INDEX;



<인덱스 삭제>
- 인덱스컬럼 추가, 삭제, 변경, 제거는 삭제 후 재생성으로 가능
//형식 (= 문법 = SYNTAX)
DROP INDEX 인덱스명;
//예 : 
DROP INDEX PERSON_INDEX;



<인덱스 리빌드>
- 인덱스 속도가 저하되었거나, 깨졌을 경우
//형식 (= 문법 = SYNTAX)
ALTER INDEX 인덱스명 REBUILD;




<<레벨 확인 방법>>
**BLEVEL(Branch level) : 오라클이 index에 접근할 때 몇 단계를 거쳐서 해당 위치를 찾아가는지의 여부를 나타냄
예 : 
SELECT TABLE_NAME, INDEX_NAME, BLEVEL FROM DBA_INDEXES WHERE OWNER = '계정명';




<<시퀀스(SEQUENCE)>>
- 시퀀스는 유일(UNIQUE)한 값을 생성해주는 오라클 객체 (NOCYCLE일 때)
- 시퀀스를 생성하면 기본 키와 같이 순차적으로 증가하는 컬럼을 자동적으로 생성할 수 있게 된다. (INCREMENT값이 양수일 경우)
- SEQUENCE를 생성할 때 값을 지정하지 않으면 1부터 1씩 증가. 
- 즉, 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 방생기라 보면 됨. (NOCYCLE일 때)
- 시퀀스는 테이블에 종속적이지 않다.



<시퀀스 형식>
CREATE SEQUENCE 시퀀스명

--시퀀스명 명명규칙 (권장사항)
- SEQ(SEQUENCE)_[테이블명_]컬럼명
- [테이블명_]컬럼명_SEQ(SEQUENCE)


① [START WITH n] 
② [INCREMENT BY n] 
③ [{MAXVALUE n | NOMAXVALUE}]
④ [{MINVALUE n | NOMINVALUE}]
⑤ [{CYCLE | NOCYCLE}]
⑥ CACHE | NOCACHE



① START WITH : : 디폴트 1부터 시작
시퀀스 번호의 시작값을 지정할 때 사용함. 
예시: 1부터 시작되도록 하려면: START WITH 1

② INCREMENT BY : 디폴트 1씩 증가
연속적인 시퀀스 번호의 증가치를 지정할 때 사용함.
예시: 1씩 증가하는 시퀀스를 생성하려면 : INCREMENT BY 1

③ MAXVALUE n | NOMAXVALUE  : 디폴트 NOMAXVALUE  
미지정시 : 9999999999999999999999999999 자동입력
MAXVALUE :  시퀀스가 가질 수 있는 최대값을 지정할 때 사용. 
NOMAXVALUE :  미지정값을 의미, 9999999999999999999999999999

④ MINVALUE n | NOMINVALUE : 디폴트 NOMINVALUE
MINVALUE 은 시퀀스가 가질수 있는 최소값을 지정할 때 사용. 
NOMINVALUE: 미지정값을 의미, 기본 1이고 최소 -999999999999999999999999999

⑤ CYCLE | NOCYCLE : 디폴트 NOCYCLE 
CYCLE 은 지정된 시퀀스 값이 최대값까지 증가가 완료되게 되면 다시 START WITH 옵션에 지정한 시작 값에서 다시 시퀀스를 시작하도록 한다. NOCYCLE은 증가가 완료되게 되면 에러를 유발한다.

⑥ CACHE OR NOCACHE :NOCACHE 권장, 디폴트 NOCACHE
- CACHE 설정 시 메모리에 시퀀스 값을 미리 할당
- NOCACHE 설정 시 시퀀스값을 메모리에 할당하지 않음. (= CACHE 20과 동일) 

==============================================




//시퀀스를 MAX부터 -1씩 감소하는 예시
CREATE SEQUENCE SEQ_NO
START WITH 5 -- 이 부분은 생략가능.
INCREMENT BY -1
MAXVALUE 5 -- 이 부분은 생략불가, START값이 MAX보다 크면 안됨
NOCACHE; -- 이 부분은 생략가능. 디폴트가 NOCACHE
--CYCLE인 경우는 반드시 MINVALUE가 존재해야 함.


//CACHE값 설정 오류 예시
CREATE SEQUENCE SEQ_NO
INCREMENT BY 2
MAXVALUE 5
CYCLE CACHE 4;
--CYCLE은 CACHE 또는 NOCACHE로 꼭 설정을 해주어야 하며, CACHE값은 1보다 크고 한 사이클 주기(MINVALUE와 MAXVALUE, INCREMENT BY 값까지 체크하여 확인)보다 작거나 같아야 한다.



================================================
<<CURRVAL, NEXTVAL>> : 슈도컬럼(PSEUDO)
- CURRVAL : 현재 값을 반환한다.
- NEXTVAL : 현재 시퀀스값의 다음 값을 반환한다.

- CURRVAL에 새로운 값이 할당되기 위해서는 NEXTVAL로 새로운 값을 생성해야 한다.
- 즉, NEXTVAL로 새로운 값을 생성한 다음에 이 값을 CURRVAL에 대체하게 된다는 이야기이다.



================================================

@ NEXTVAL, CURRVAL을 사용할 수 있는 경우
- SELECT문 (아래 분가능부분 제외)
- INSERT문의 SELECT절, VALUES절
- UPDATE문 SET절
- CREATE문의 서브쿼리



@ NEXTVAL, CURRVAL을 사용할 수 없는 경우
- VIEW의 SELECT절

- DISTINCT 키워드가 있는 SELECT문
- SELECT문의 GROUP BY, HAVING, ORDER BY 절
- SELECT, DELETE, UPDATE문의 WHERE 조건

- CREATE TABLE, ALTER TABLE의 DEFAULT



//USER_SEQUENCES 데이터 딕셔너리로 시퀀스 확인하고 필요없는 것 제거할 것
SELECT * FROM USER_SEQUENCES;





//
//30
//필기
//




<<DCL(Data Control Language, 데이터 제어어)>>
- 데이터의 보안, 무결성, 회복, 병행 수행 제어, 등을 정의하는데 사용하는 언어
**TCL포함
- GRANT : 데이터베이스 사용자에게 사용 권한을 부여
- REVOKE : 사용자계정의 권한을 회수



<*권한 관리>

- 사용자에 의해 사용되는 권한
CREATE SESSION : 데이터베이스에 연결할 수 있는 권한, USER로 연결(접속)할 수 있는 권한
CREATE TABLE : 테이블을 생성할 수 있는 권한
CREATE VIEW : 뷰를 생성할 수 있는 권한
CREATE SEQUENCE : 시퀀스를 생성할 수 있는 권한
CREATE PROCEDURE : 함수를 생성할 수 있는 권한

- CONNECT 롤 :
사용자가 데이터베이스에 접속 가능하도록 가장 기본적인 시스템 권한을 묶어 놓았다.
CREATE TABLE(접근권한), CREATE SEQUENCE, CREATE CLUSTER, CREATE SESSION, ALTER SESSION, CREATE SYNONYM, CREATE DATABASE LINK

- RESOURCE 롤 : 
유저를 생성하면 일반적으로 CONNECT, RESOURCE 롤을 부여 한다.
사용자가 객체를 생성할 수 있도록 시스템 권한을 묶어 놓았다.
CREATE TABLE(자원(생성)권한), CREATE SEQUENCE, CREATE CLUSTER, CREATE TRIGGER, CREATE PROCEDURE



<현재 사용자의 시스템 권한 정보 확인>
SELECT * FROM SESSION_PRIVS;



=====================================================


1. 선택적 권한부여 : 
DBA권한을 가진 USER가 자신의 계정에 접근하는 USER의 권한을 선택하여 부여할 수 있다.
GRANT SELECT ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT INSERT ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT DELETE ON [스키마명(계정명)].[TABLE명] TO [USER명];
GRANT UPDATE ON [스키마명(계정명)].[TABLE명] TO [USER명];

--또는
GRANT SELECT, INSERT, DELETE, UPDATE ON [TABLE명] TO [USER명];
GRANT ALL ON [TABLE명] TO [USER명];
=====================================================


2. 선택적 권한취소 : 
REVOKE SELECT ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE INSERT ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE DELETE ON [스키마명(계정명)].[TABLE명] FROM [USER명];
REVOKE UPDATE ON [스키마명(계정명)].[TABLE명] FROM [USER명];

--또는
REVOKE SELECT, INSERT, DELETE, UPDATE ON [TABLE명] FROM [USER명];
REVOKE ALL ON [TABLE명] FROM [USER명];
=====================================================


다른 계정에 SELECT, INSERT, DELETE, UPDATE 모든(ALL) 권한 부여
GRANT ALL ON [TABLE명] TO [USER명];


다른 계정에 모든 테이블에 대한 SELECT 권한 부여
GRANT SELECT ANY TABLE TO [USER];


--ALL과 ANY는 같이 사용할 수 없다
--ALL은 ON이 필요하고 ANY는 ON이 없어야해서 같이 사용 안됨
GRANT ALL ON ANY TABLE TO ORAUSER; (X)

=====================================================




<<시노님(SYNONYM : 동의어 - 테이블에 대한 별칭 부여)>>
- DBA권한이 부여된 계정만 생성 가능.
- 비공개동의어(PRIVATE SYNONYM), 공개동의어(PUBLIC SYNONYM)이 있다.


<비공개동의어(PRIVATE SYNONYM)> : 
만든 계정에서만 접근 가능하며, 다른계정은 권한을 부여 받아야 접근할 수 있다.
(단, DBA권한 계정은 모두 접근 가능)
비공개동의어는 비공개시노님은 접근권한이 부여된 계정이더라도 접근할 때 반드시 계정명.으로 접근해야 한다.

생성형식 : 
CREATE OR REPLACE [PRIVATE-디폴트,생략가능|PUBLIC-생략불가] SYNONYM [스키마명.]시노님명 FOR [스키마명.]객체명;
**객체명에는 테이블명, 뷰명, 프로시저명, 함수명, 패키지명, 시퀀스명, 등이 올 수 있다.
**시노님은 별도의 수정구문이 없으므로 삭제 후 재생성을 해야한다.




<[오라클]오라클계정 비밀번호 만료기간 해제 및 변경>

비밀번호 유효기간은 기본값이 180일로 설정 되어있어 유효기간이 지나면 자동만료되어 접속할 수 없게 된다.

오라클 계정 비밀번호 만료일이 지나면, [oracle : the password has expired] 라는 메세지와 함께 접속할 수 없다.


<비밀번호 만료기간 해제하기>

1. 관리자계정으로 접속
splplus / "as sysdba"

2. 비밀번호 유효기간 확인
SQL > select * from dba_profiles where profile = 'DEFAULT';

2-1. 비밀번호 만료기간만 확인해보면, 180으로 설정되어 있는 것을 볼 수 있다.
SQL > select * from dba_profiles where resource_name = 'PASSWORD_LIFE_TIME';

3. DEFAULT 비밀번호 만료기간 unlimited로 변경하기
SQL > alter profile default limit password_life_time unlimited;

4. 다시 한번 비밀번호 만료기간 확인해보기
비밀번호 만료기간 해제 완료


만약, 비밀번호가 만료되어 접속이 안될 때, 해결방법은 
비밀번호 유효기간을 바꾸기전에 계정의 락 해체 후에 비밀번호를 변경해줘야 한다.


<계정 락 해체하기>
SQL > alter user 계정명 account unlock;

<비밀번호 변경하기>
SQL > alter user 계정명 identified by 새비밀번호;




ORACLE SID(데이터베이스) 선택 변경 방법

WINDOWS 편집창에서 실행 할 것 (SQL편집창에서 실행하면 안됨)
C:\Users\hi>set oracle_sid=SID명입력하기
C:\Users\hi>SQLPLUS 사용자계정명/비밀번호[@SID명]




<<의사 컬럼 (슈도컬럼 = PSEUDO)>>

<ROWNUM> 키워드
- 인덱스에서 저장하는 ROWID(행주소)값이기도 함.
- 저장된 행 순서대로 자동으로 순번을 부여함.
- 단순쿼리인 경우에는 where절에만 사용 가능.
단, 서브쿼리 사용 시 select절에도 표현할 수 있다.
- 페이징처리를 하려면 서브쿼리를 이용하여 할 수 있다.
*페이징처리 : 한 번에 보여지는 수를 조정하는 것
- order by절 이용 시 꼭 서브쿼리에서 사용할 것

// 형식 : 
- ROWNUM < 값
- ROWNUM <= 값
*값은 양의 정수로 표현

--단순쿼리 시
SELECT * FROM CUSTOMERS WHERE ROWNUM <= 1000 AND CUST_GENDER = 'M';

--서브쿼리 시
SELECT ROWNUM RN, C.* 
FROM (SELECT * FROM CUSTOMERS WHERE CUST_GENDER = 'M') C
WHERE ROWNUM <= 500;

--**페이징 쿼리
페이징 처리시에는 꼭 별칭을 지정해 주어야만 제대로 인식될 수 있다.
SELECT * FROM (SELECT ROWNUM RN, C2.* FROM CUSTOMERS C2 WHRER CUST_GENDER = 'M')
WHERE RN BETWEEN 10 AND 13;

SELECT * FROM (SELECT ROWNUM RN, C2.* FROM CUSTOMERS C2 WHRER CUST_GENDER = 'M')
WHERE RN >= 50 AND RN <= 100;




<<MERGE절>>
조건에 의해 한꺼번에 추가(INSERT), 갱신(UPDATE), 삭제(DELETE) 할 수 있는 명령문 ON절에 있는 조건에 UPDATE 할 컬럼이 들어가면 안됨. 오류 발생

형식 : 
MERGE INTO 변경을원하는테이블명1 [별칭]	--서브쿼리가 와도 된다.
USING 데이터를가져올테이블명2 [별칭]	--뷰, 테이블, 서브쿼리 등 가능
ON (테이블1과 테이블2를 엮을 조건)		--이너조인과 동일하게 기술
-ㄴ필수--

[
WHEN MATCHED THEN		--이 절에는 반드시 UPDATE문이 와야 한다.
(ON절 조건이 일치하면)
UPDATE SET 테이블1의컬럼1 = 테이블2의컬림1, 테이블1의컬럼2 = 테이블2의컬럼2,....
[DELETE WHERE 조건		**반드시 UPDATE절과 같이 써야 한다.]
]


[
WHEN NOT MATCHED THEN		--이 절에는 INSERT문이 올 수 한다.
(ON절 조건이 일치하지 않으면)
INSERT (테이블1의컬럼1,테이블1의컬럼2,....) VALUES (테이블2의컬럼1, 테이블2의컬럼2,...);
]




CREATE TABLE EMP01 AS SELECT * FROM EMP01;

MERGE INTO EMP01 A
USING (SELECT EMPNO, SAL, JOB FROM EMP WHERE DEPTNO = 10) B
ON (A.EMPNO = B.EMPNO)
WHEN MATCHED THEN
UPDATE SET A.SAL = SAL + SAL * 0.01
WHEN NOT MATCHED THEN
INSERT (A.EMPNO, SAL, JOB) VALUES (B.EMPNO, B.SAL, B.JOB);





//
//31
//필기
//




<<집합 연산자>>
집합연산자 : UNION, UNION ALL-합집합 / INTERSECT-교집합 / MINUS-차집합

집합연산자의 제한 조건 : 
- **두 테이블의 컬럼 개수와 자료형, 나열순서가 같아야 한다.

- ORDER BY 절은 모든 쿼리문을 다 기술한 뒤 맨 마지막에 한 번만 기술가능하다.
(단, ORDER BY 절을 쓸 때는 처음에 기술한 테이블이 기준이 되기 때문에 처음 기술한 테이블의 컬럼으로만 정렬 가능)
- LOB(BLOB, CLOB, BFILE)자료형, LONG자료형에는 사용할 수 없다.


1. UNION : 합집합
- 두 개의 테이블의 데이터를 모두 포함한 결과를 반환함.
- 중복을 허용하지 않는다. 중복값은 1개만 표현함
예: 
SELECT DEPTNO, ENAME FROM EMP *UNION SELECT DEPTNO, DNAME FROM DEPT;


1-2. UNION ALL : 합집합
- UNION과 거의 다 동일하지만 중복을 허용하여 모두 출력한다.


2. INTERSECT : 교집합
- 두 개의 테이블의 데이터 중 공통된 항목만 반환함.
- 중복을 허용하지 않는다.


3. MINUS : 차집합
- 두 개의 테이블의 데이터 중 공통된 항목을 제외한 데이터만 반환하는데,
단, 먼저 처리된 테이블의 항목만 반환한다. 나중에 처리된 테이블의 결과는 제외.
- 중복을 허용하지 않는다.




<<PL/SQL (ORACLE'S PROCEDURAL LANGUAGE EXTENSION TO SQL)>>
1. 절차적 언어
- 절차적 언어란, 개발자가 처리 절차(처리순서, 처리방법)를 처음부터 끝까지 정해주어야 하는 언어.

2. 비절차적 언어
- 비절차적 언어란, 개발자가 처리절차를 지정하지 않고 원하는 결과를 정의하여 요청하는 언어.


<PL/SQL>
- 오라클 자체에 내장되어 있는 절차적 언어(Procedural Language)로서,
SQL의 비절차적 언어의 단점을 보완, 확장한 언어

- **SQL 문장에서 변수 정의, 조건(IF), 반복(LOOP, WHILE, FOR) 처리 등을 지원

- **블록(Block) : PL/SQL 프로그램의 기본 단위

- 데이터에 대한 조작을 SQL만으로 처리하는데 한계가 있는 경우, 
DB안에서 데이터 값에 대한 처리를 하고 싶은 경우(함수, 프로시저, 트리거 등등) 사용.


<구성> : 
- DECLARE(선언부) : 기술여부는 선택, 실행에 사용 될 변수/상수/커서 등을 선언
- BEGIN(실행부) ~ END : 기술여부는 필수, 조건문/반복문/SELECT/DML/함수 등을 정의
- EXCEPTION(예외 처리부) : 기술여부는 선택, PL/SQL 실행 도중 발생하는 오류(예외 상황)를 해결하는 문장 서술


<PL/SQL 작성 주의사항>
1. PL/SQL블록을 구성하는 DECLARE, BEGIN ~ END, EXCEPTION 키워드에는 세미콜론(;)을 사용하지 않는다.
(단 BEGIN문 안에 기술하는 SQL명령문에는 세미콜론을 사용해야 한다.)

2. PL/SQL블록의 각 부분에서 실행해야 하는 문장 끝에는 세미콜론(;)을 사용.
ex) DBMS_OUTPUT.PUT_LINE('HELLO, PL/SQL !');

3. SQL에서와 마찬가지로 PL/SQL 내부에서도 주석 사용 가능
한 줄 주석 : --
여러 줄 주석 : /*주석내용*/

4. PL/SQL문 작성을 마치고 실행하기 위해 마지막에 슬래시(/)를 사용(SQLDevelper에서는 생략 가능)
**마지막에 슬래시(/)는 PL/SQL문 작성이 끝났다는 의미와 실행하라는 의미를 가지고 있음.

5. 선언 조건(권장사항)
변수 : 변수앞에 v를 붙여준다. variable의 약자
상수 : 상수앞에 c를 붙여준다. constant의 약자
매개변수 : 매개변수앞에 p를 붙여준다. parameter의 약자



- <익명블록 (ANONYMOUS BLOCK)> : 
이름 없이 선언된 PL/SQL문을 익명블록이라 함.

//형식 : 
[
DECLARE   --선언부 (DECLARE SECTION)
   변수나 상수, 커서를 선언
]
BEGIN   --실행부 (EXECUTABLE SECTION)
   SQL문
   제어문, 반복문, 출력문
   커서 사용
   [EXCEPTION   --예외 처리부 (EXCEPTION SECTION)]

END;
/




--DBMS_OUTPUT : java의 System.out객체와 유사

--SET SERVEROUTPUT ON : 
DBMS_OUTPUT이 정상 작동하도록 설정을 ON하는 기능(출력 콘솔창을 킨다는 의미)
SET SERVEROUTPUT ON을 기술해주지 않으면 출력결과를 확인하기가 어렵다.
단. sqldeveloper에서는 생략가능




DBMS_OUTPUT 패키지는 문자열 출력을 위해 3가지 프로시저를 지원함
PUT_LINE : 문자열을 출력한 후 다음 라인으로 이동.
PUT : 문자열을 출력한 후 대기. 반드시 다음 줄로 넘어갈 수 있는 무언가가 지정되어 있어야 한다.
NEW_LINE : 다음 라인으로 이동. 매개인자 값을 넣으면 안됨.



<*변수>
- 테이블의 컬럼 정의와 구조가 동일하다.
- 변수를 초기화 하지 않고 정의만 한 경우는 해당 변수의 자료형에 상관없이 NULL값으로 지정된다.
- 변수 정의 시 NOT NULL 이나 CONSTANT(상수) 로 정의하여 변수의 데이터에 일부 제약(Constraint) 사항을 정의할 수도 있다.

- 형식 : 
변수명 자료형(데이터타입) := 초기값;
변수명 자료형(데이터타입) [NOT NULL] [:= 초기값];
변수명 자료형(데이터타입);



<*  :=	PL/SQL에서의 대입연산자 >



<상수>
- 한 번 값을 할당 받으면 변하지 않는 수
- 꼭 선언과 동시에 초기화도 해주어야 한다.

- 형식 : 
상수명 CONSTANT 자료형(데이터타입) := 상수값;
*꼭 CONSTANT 키워드를 붙여야 한다.



<연산자>
** : 제곱연산자 예) 2**3 -> 2의 3승

+값, -값 : 부호연산자. 양수, 음수 식별연산자

*, / : 산술연산자 중 곱셈, 나눗셈

+, -, || : 산술연산자 중 덧셈, 뺄셈 및 문자열 연결 연산자

=, <, >, <=, >=, <>, !=, ~=, \^=, IS NULL, LIKE, BETWEEN~AND, IN : 비교연산자

NOT : 논리연산자, 부정을 의미
	NOT true : false
	NOT false : true
	NOT null : null

AND : 논리연산자, 교집합을 의미 
	true AND true : true
	true AND false : false
	false AND false : false
	true AND null : null
	false AND null : false
	null AND null : null

OR : 논리연산자, 합집합을 의미 
	true OR true : true
	true OR false : true
	false OR false : false
	true OR null : true
	false OR null : null
	null OR null : null



DECLARE
VEMPNO NUMBER(4);
VENAME VARCHAR2(10);
BEGIN 
VEMPNO := 7788;
VENAME := 'SCOTT';
DBMS_OUTPUT.PUT_LINE('사번 / 이름');
DBMS_OUTPUT.PUT_LINE('---------');
DBMS_OUTPUT.PUT_LINE(VEMPNO || '/' || VENAME);
END;
/




<<데이터 타입>>

- <스칼라 타입> : 
숫자(NUMBER), 문자(CHAR, VARCHAR2), 날짜(DATE, TIMESTAMP), BOOLEAN 등
- 스칼라 변수 : SQL자료형과 비슷하게 선언하는 변수를 말함.


-<레퍼런스 타입(= 참조자료형)> : 
- 레퍼런스 변수 : DB 테이블의 특정 컬럼으로 변수 타입을 지정할 때 사용
- 테이블에서 컬럼의 자료형이 반경되더라도, PL/SQL에서의 변수 선언부분을 수정할 필요가 없다는 장점이 있다.

- 형식 : 
   테이블이름.필드명%TYPE : 컬럼 타입 선언, 컬럼(열, 칸, 필드, 항목, 속성) 단위
   예) EMP.EMPNO%TYPE -> NUMBER(4,0)

   테이블이름%ROWTYPE : 레코드 타입 선언, 레코드(행, 줄, 로우) 단위
   예) EMP%ROWTYPE -> 
    /EMPNO/         /ENAME/	      /JOB/         /MGR/    /HIREDATE/   /SAL/          /COMM/        /DEPTNO/
NUMBER(4,0) VARCHAR2(10) VARCHAR2(9) NUMBER(4,0)  DATE  NUMBER(7,2) NUMBER(7,2) NUMBER(2,0)	
				
			
			
				
			
DECLARE
--테이블의 컬럼의 데이터타입과 일치시켜 주는 것이 좋다. 에러 예방
--스칼라 변수 선언
VEMPNO NUMBER(4);
VENAME VARCHAR2(10);
VDEPTNO NUMBER(2);
VDNAME VARCHAR2(14);
BEGIN
--테이블 안의 데이터를 받아오는 경우 select절 안에 into를 이용한다.
--select절 컬럼의 데이터타입, 개수, 순서와
--INTO절의 변수의 데이터타입, 개수, 순서가 일치해야 한다.
--select절의 데이터는 INTO절을 통해 해당 변수를 초기화 해줘야 하기 때문에 
--반드시 한 줄의 데이터만 가져오는 쿼리문이여야 한다.

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME
INTO VEMPNO, VENAME, VDEPTNO, VDNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.ENAME = 'SMITH';

DBMS_OUTPUT.PUT_LINE('사번 / 이름 / 부서번호 / 부서명');
DBMS_OUTPUT.PUT_LINE('---------------------------------');
DBMS_OUTPUT.PUT_LINE(VEMPNO || ' / ' || VENAME || ' / ' || VDEPTNO || ' / ' || VDNAME);
END;
/			
			



<IF~ ELSIF~ ELSE조건문>
- 형식 : 
IF 조건1(condition1) THEN
   실행문1(statement1);
[
ELSIF 조건2 THEN
   실행문2;
ELSE
   실행문3;
]
END IF;




<ORACLE에서의 BOOLEAN자료형>
값 : TRUE, FALSE, NULL 값을 가질 수 있다. (대소문자 안가림)
다른 자료형은 DBMS_OUTPUT의 출력문을 통해 출력 가능하지만 
BOOLEAN자료형 값은 DBMS_OUTPUT의 출력문으로 바로 값을 출력할 수 없다.(오류)





//
//32
//필기
//





<<반복문 (LOOP)>>

<BASIC LOOP 기본 반복문>
형식 : 
LOOP

반복으로 실행할 코드;
...
(*필수) 탈출하는 코드;
END LOOP;




<FOR LOOP>
형식 : 
FOR 인덱스명 IN [REVERSE(역순)] 시작값..종료값 LOOP --(시작값과 종료값 사이 점두개 기술 필수)

반복으로 실행할 코드;
...
[탈출하는 코드;]
END LOOP;


**인덱스명 : 
선언할 필요가 없다.
변수처럼 값을 직접 대입받아서 변경하거나 할 수 없다.
IN 뒤의 범위의 값을 자동으로 하나씩 받아서 값을 가지게 되는 변수이다.




<WHILE LOOP>
형식 : 
WHILE 조건 LOOP

반복으로 실행할 코드;
...
탈출하는 코드;
END LOOP;





<CONTINUE> : 
LOOP 머리로 돌아가라




<라벨>
<<라벨명>> --라벨을 붙일 수 있다.
...
...
GOTO 라벨명; --라벨로 돌아가기, 대소문자 구분 안함.




<<커서 (Cursor)>>
- SQL문을 처리한 결과를 담고 있는 영역(메모리영역)을 가리키는 일종의 포인터
- 처리 결과가 여러 개의 행으로 구해지는 SELECT문을 처리할 때 이용.
- 커서의 사이클 : 열기(OPEN) - 패치(FETCH) - 닫기(CLOSE)
- FETCH문은 결과셋(결과테이블)에서 로우(행=레코드) 단위로 데이터를 읽어들인다.
- FETCH 후에 CURSOR는 결과셋에서 다음 행으로 이동한다.

- 커서의 상태 
   -- %FOUND : 커서 영역에 FETCH 되지 않은 자료가 있다면 TRUE
   -- %ONTFOUND : 커서 영역의 데이터가 모두 FETCH 되었다면 TRUE
   -- %ISOPEN : 커서가 OPEN 된 상태이면 TRUE
	         묵시적커서는 OPEN 상태 인식이 안된다. 따라서 늘 FALSE
   -- %ROWCOUNT : 커서가 얻어 온 레코드의 개수
**묵시적커서 : 커서를 명시적으로 선언하지 않아도 자동으로 실행되는 커서(대표적 : SQL실행문)
**명시적커서 : DECLARE부에 선언하는 커서들
SQL%ROWCOUNT : 해당 코드가 기술되기 바로 직전에 실행된 SQL명령에서 처리된 묵지적커서의 행수를 반환함.
커서명%ROWCOUNT : 해당 커서의 전체 행 수를 반환함.

- 형식 : 
DECLARE
CURSOR 커서이름 IS SELECT쿼리문; --명시적커서
BEGIN
OPEN 커서이름 [(매개변수, ...)];
FETCH 커서이름, INTO 변수이름;
CLOSE 커서이름;
END;
/



<<CURSOR와 FOR LOOP>>
- 반복할 때마다 CURSOR를 OPEN 한 후, 행(레코드)을 인출(FETCH)한다.
- 모든 행이 처리되면 자동으로 CURSOR가 CLOSE된다.
- REVERSE처리를 할 수 없다.

- 형식 : 
FOR 레코드 IN 커서명[(매개변수, ...)]
LOOP
실행문;
...
END LOOP;




<<동적 SQL>>
- 고정된 SQL이 아닌 변경 가능한 쿼리를 말한다.
- 사용될 SQL문이 실행시에 결정된다.
- 종류 : 
원시 동적 SQL(NDS - Native Dynamic SQL)방식, DBMS Dynamic SQL방식이 있음.

사용을 하는 이유
- 컴파일 시 SQL문이 확정되지 않을 때
- PL/SQL 블록 상에서 DDL문을 사용해야 할 때

NDS(Native Dynamic SQL) : 원시 동적 SQL
- 동적 SQL한 종류.
- EXECUTE IMMEDIATE ~ INTO 문 사용

- 형식 : 
EXECUTE IMMEDIATE sql문자열 INTO 담을변수1, 담을변수2, ...
[USING sql문자열에서 사용한 변수에 대응되는 바인드변수1, 바인드변수2, ...];
**sql문자열은 SQL쿼리문을 담기 때문에 자료형의 사이즈를 좀 넉넉하게 해준다.

**실행 순서 : sql문자열 -> [USING절] -> EXECUTE IMMEDIATE -> INTO절




--SQL쿼리문을 변수에 담는다
--V_SQL변수가 VARCHAR2이므로 안의 SMITH가 문자열이라는 것을 인식하도록 하기 위해서는
--''값''(작은따옴표 2개)을 사용해야 한다. 큰따옴표가 아님.

--바인드 변수 사용 : 연결해주는 변수를 바인드라고 함.
--SQL쿼리문에 변수를 설정하여 해당 변수에 대응하는 값을 연결해주는 방식
--여러 SQL안의 값이 변경되어도 구문을 변경해줄 필요가 없다.
--SQL쿼리문을 바인드 변수로 처리
--SQL쿼리문 안의 바인드 변수는 꼭 [:변수명] 형식으로 기술해주어야 한다.




//
//33
//필기
//



혹시라도 이전 버전이나 낮은 버전 사용하는 경우 DBA권한을 부여 받은 계정에서라도 PL/SQL에서 CREATE TABLE명령문 실행 시
에러가 발생되는 경우 (PRIVILLAGE...) DBA권한을 가진 계정이더라도
다시 한 번 CREATE TABLE권한을 부여해주어야 한다.
- GRENT CREATE TABLE TO TEST;



-------------------------------------------------------------------------
<<함수 (FUNCTION)>>
오라클에서 제공하고 있는 내장함수(= 빌트인함수)처럼
매개변수를 받아 뭔가를 처리해 그 결과를 반환하는 데이터베이스 객체이며,
사용자 정의 함수를 말함.
*****꼭 반환값이 있어야 한다. => 리턴문, 리턴값이 존재

//형식 :
CREATE OR REPLACE FUNCTION 함수이름 (매개변수1, 매개변수2, ...)
RETURN 데이터타입
IS[또는 AS]
변수, 상수 등 선언
BEGIN
실행부
...
RETURN 반환값;
[EXCEPTION]
END [함수이름];


//호출문형식 : 
<매개변수가 없는 함수 호출>
함수명 혹은 함수명()

<매개변수가 있는 함수 호출>
함수명(매개변수1, 매개변수2, ...)


--함수제거 : 
DROP FUNCTION 함수명;

-------------------------------------------------------------------------


- 일반 컬렉션자료형은 동일한 자료형으로만 데이터를 가질 수 있기 때문에
자료형이 다른 타입의 중첩테이블 형식을 만드려면 레코드유형으로 자료형을 갖는 
OBJECT자료형으로 먼저 만들어주어야 한다.
- TYPE 생성시에는 제약조건을 넣을 수 없다.
- 반드시 마지막에 /기호를 넣어주어야 한다. 안 넣을 경우 에러 남.
- 유형 변경 시 반드시 하위 유형이 제거된 후에 변경해야 한다.
- OBJECT자료형을 갖는 사용자 자료형 만들기, 자료형명 : DEPT_TYPE (리턴타입)
- 자료형으로 레퍼런스타입은 불가능, 반드시 스칼라타입으로 기술

CREATE OR REPLACE TYPE DEPT_TYPE AS OBJECT (
DEPTNO NUMBER(2),
DNAME VARCHAR2(14),
LOC VARCHAR2(13)
);
/

TABLE TYPE 객체 생성
- 함수에서 반환 가능한 테이블타입으로 오브젝트 자료형 재정의

CREATE OR REPLACE TYPE DEPT_TABLE AS TABLE OF DEPT_TYPE;
-------------------------------------------------------------------------
_TYPE생성 -> 상위
_TABLE생성-> 하위
-------------------------------------------------------------------------




<<프로시저>>
반환값이 없는 프로그램. 
특정 연산을 수행하기만 함.
- 테이블의 갱신이나 다른 테이블에 데이터를 백업하거나 하는 경우 등 이용한다.


<저장 프로시저 (Stored Procedure)>
- 자주 사용되는 쿼리문을 모듈화시켜서 필요할 때마다 호출하여 사용하는 것
- 형식 :
CREATE OR REPLACE PROCEDURE 프로시저명[(P1 [IN(디폴트)/OUT/INOUT] 데이터타입 := 값, ...)]
IS [또는 AS] 
변수, 상수 등 선언
BEGIN
실행문;
...
[EXCEPTION
예외처리문;]
END [프로시저명];
/


<키포인트>
-IN 매개변수는 참조만 가능하며 값을 할당 할 수 없다.
-OUT 매개변수에 값을 전달할 수는 있지만 의미는 없다.
-IN OUT 매개변수는 값 참조 및 전달이 가능하다.
-OUT, IN OUT 매개변수에는 디폴트값을 설정 할 수 없다.

IN 매개변수에는 변수나 상수, 각 데이터 유형에 따른 값을 전달 할 수 있지만
OUT, IN OUT 매개변수는 전달 할 때 반드시 변수 형태로 값을 넘겨줘야 한다.
***OUT키워드가 들어간 매개변수는 실제값으로 호출 못함. 기본값 설정 안됨.


--매개변수 개수가 많아서 인자값이 어떤 변수에 바인딩되는지 잘 모르겠을 때,
--프로시저의 매개변수명과 동일하게 해주어야 하며, 순서는 바뀌어도 상관없다.



--IN OUT 명시 없으면 디폴트는 IN
--매개변수에 초기값이 대입되어 있을 경우, 호출문에 값이 없으면 초기값으로 대입됨.
--,(콤마)를 쓰지 않아도 되는 값까지



--OUT 매개변수
--프로시저 실행 시점에 OUT 매개변수를 변수 형태를 전달하고, 프로시저 실행부에서 이 매개변수에 특정값을 할당한다.
--실행이 끝나면 전달한 변수를 참조해 값을 가져올 수 있다. 



--IN OUT 매개변수
입력과 동시에 출력용으로 사용할 수 있다.
프로시저 실행시 OUT 매개변수에 전달할 변수에 값을 할당해서 넘겨줄 수 있지만 의미없다.
왜냐하면 OUT 매개변수는 프로시저가 성공적으로 실행을 완료할 때까지 값이 할당되지 않기 때문이다.
그러므로 매개변수에 값을 전달해서 사용한 다음 다시 이 매개변수에 값을 받아와 참조하고 싶다면 IN OUT 매개변수를 이용해야 한다.





-------------------------------------------------------------------------
//
//34
//필기
//




<<RETURN문>>
함수에서는 일정한 연산을 수행하고 결과 값을 반환하는 역할을 했지만,
프로시저에서는 RETURN문을 만나면 이후 로직을 수행하지 않고 프로시저를 빠져나간다.





<<예외처리>>
예측 가능한 에러상황을 시스템이 정상 종료되도록 처리하는 것

구체적인 예외명을 알 수 없을 때 : OTHERS를 사용한다. (자바의 EXCEPTION클래스와 유사)
OTHERS는 오라클 시스템에서 PL/SQL 코드 상에서 발생한 런타임 예외를 자동으로 잡아준다.
--오라클에서 제공하는 빌트인 함수 (언어 설계 광정에서 미리 만들어진 함수)

SQLCODE : 실행부에서 발생한 예외에 해당하는 코드를 반환한다.
예) BY ZERO에러 : '-1476'을 반환, 에러가 없으면 0을 반환

SQLERRM : 발생한 예외에 대한 오류 메시지를 반환한다.
매개변수로 예외코드 값을 받는데, 매개변수를 넘기지 않으면
디폴트로 SQLCODE가 반환한 예외코드 값과 연관된 예외 메시지를 반환한다.

DBMS_UTILITY : 좀 더 세부적인 예외 정보제공.
예) DBMS_UTILITY.FORMAT_ERROR_BACKTRACE 함수 : 몇 번째 줄에서 예외가 발생했는지 알려줌.



//형식 : CASE문과 유사
EXCEPTION
WHEN 예외명1 THEN 예외처리 구문1
WHEN 예외명2 THEN 예외처리 구문2
...
WHEN OTHERS THEN 예외처리 구문N;

===========================
미리 정의된 예외 종류들
ACCESS_INTO_NULL : (ORA-06530) 객체가 초기화되지 않은 상태에서 사용 시
CASE_NOT_FOUND : (ORA-06592) CASE문 사용시 구문 오류
CURSOR_ALREADY_OPEN : (ORA-06511) 커서가 OPEN상태에서 재OPEN 시도 시

INVALID_CUTSOR : (ORA-01001) 존재하지 않는 커서를 참조
INVALID_NUMBER : (ORA-01722) 문자를 숫자로 변환 실패 할 경우

NO_DATA_FOUND : (ORA-01403) SELECT INTO절 시 데이터가 한 건도 없을 경우
TOO_MANY_ROWS : (ORA-01422) SELECT INTO절 시 결과가 2개 이상인 경우

VALUE_ERROR : (ORA-06502) 수치 또는 값 오류
ZERO_DIVIDE : (ORA-01476) 젯수가 0일 때 오류





<<트리거(trigger)>>
이벤트가 발생하면 데이터베이스에 의해 자동으로 수행되는 명명 블록이다.
COMMIT, ROLLBACK, SAVEPOINT문을 사용 할 수 없다.
트리거의 주요 사용 목적은 테이블 데이터의 무결성 보장, 데이터베이스 관리의 자동화, 등 이라고 할 수 있다.

단순 DML트리거
- DML이벤트에 의해 수행되는 트리거를 말함.
- 테이블과 뷰에 종속되어 있으며, 대상 객체를 삭제하면 함께 삭제된다.
- 단일 타이밍 포인트(TIMING POINT)를 지정한다.
- DML이벤트 : INSERT, UPDATE, DELETE



//형식 : 
CREATE [OR REPLACE] TRIGGER [스키마.]트리거명
{BEFORE 또는 AFTER} DML이벤트[ OR DML이벤트 OR DML이벤트] ON [스키마명.]{테이블명 또는 뷰명}
[REFERENCING] --상관명 별칭 사용
[FOR EACH ROW] --행 단위로 수행하는 경우 기술
[FOLLOWS] --트리거 순서 정하기
[WHEN (조건)]
[DECLARE 선언부]
BEGIN
실행문, 출력문, 조건.제어문 등등;
...
[EXCEPTION 예외처리부]
END [트리거명];
/




--트리거 생성시 주의할 점
최대 코드 용량은 32KB를 넘을 수 없다.
순환트리거링, 재귀 트리거링이 되지 않도록 주의해야 한다.




--테이블에 종속 된 전체 트리거 활성화/비활성화 하기
ALTER TABLE [스키마명.]테이블명 {ENABLE 또는 DISABLE} ALL TRIGGER;


--해당 트리거 하나만 활성화/비활성화 하기
ALTER TRIGGER 트리거명 {ENABLE 또는 DISABLE};




<행단위 DML트리거>
:OLD, :NEW 상관명으로 이용하여 변경 전, 후 값을 참조 할 수 있다.
- 단, INSERT문의 :OLD값과 DELETE문의 :NEW값은 무조건 NULL을 반환한다.
==============================
<DML>		<:OLD>		<:NEW>
==============================
INSERT		NULL		삽입 값
-----------------------------------------------------
DELETE		삭제전 값		NULL
-----------------------------------------------------
UPDATE		갱신전 값		갱신후 값
==============================




<PRAGMA AUTONOMOUS_TRANSACTION;>

TRIGGER에 연결 된 프로시저나 함수에 트랜잭션 작업이 있어서 영향을 받게 되는 경우
해당 트랜잭션 작업에 영향을 받지 않도록 독립적으로 실행을 해주라는 명령임.






<<JDBC(Java DataBase Connection)>>
자바와 데이터베이스를 연동하는 기술.
**오라클 연동에 관련 된 인터페이스들은 java.sql패키지 안에 들어있다.
java.sql.Connection : 데이터베이스의 계정과 비번, url정보를 담고 있는 객체
java.sql.Statement : 데이터베이스의 SQL명령을 담을 수 있는 객체
java.sql.PreparedStatement : 데이터베이스의 SQL명령을 담을 수 있는 객체
java.sql.ResultSet : SELECT 명령을 실행 후 가져오는 데이터의 결과 집합(레코드들의 묶음 => 인스턴스들)을 가리키고 있는 오라클의 커서와 동일한 기능을 가진 객체


--데이터베이스 연결에 필요한 드라이버 준비 및 설치

1. 파일 준비 
(C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib)
11g => ojdbc6.jar
10g => ojdbc5.jar


2. 자바프로젝트에 1번의 jar파일을 추가하기
프로젝트명 선택 후 마우스 우클릭 -> Build Path...선택 -> Configure Build Path...선택 -> Libraries 탭 선택 -> Module Path 선택 후 오른쪽의 [Add External JARs...] 선택 -> Apply and Close 


3. 드라이버 설치
(소스코드에 기술)
Class.forName('패키지경로포함.클래스명까지기술');
=> Class.forName("oracle.jdbc.driver.OracleDriver");
=> (ojdbc6.jar)자르파일 압축해제 후 oracle안에 jdbc안에 driver안에 OracleDriver.Class파일
=> OracleDriver.Class파일 = 오라클에 접속 할 수 있는 클래스파일


4. Connection 객체 얻어오기 (필요한 사항(문자열값으로): url, username, password)
데이터베이스의 접속, 데이터베이스와 연결하는 통로를 열어두는 기능
**username = "오라클의 사용자 계정명" => "test 또는 TEST"
**password = "1111"
**url => 형식 : jdbc:데이터베이스종류:[오라클인경우는드라이버버전까지:]@호스트명:포트번호:전역데이터베이스명(SID);
(오라클서버가 설치되어 있는 url)
=> "jdbc:oracle:thin:@localhost:1521:xe"
=> "jdbc:oracle:thin:@127.0.0.1:1521:xe"

 
import java.sql.Connection;

Connection conn = DriverManager.getConnection(url, username, password);
=> Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "TEST", "1111");


=> 
String url = "jdbc:oracle:thin:@localhost:1521:xe";
=>jdbc:oracle:thin: 자바꺼,대소문자가림 / @localhost:1521:xe 오라클꺼,대소문자안가림
String username = "TEST";
String password = "1111";
Connection conn = DriverManager.getConnection(url, username, password);


5. 명령문 담을 객체 생성하기 (Statement, PreparedStatement)
Statement st = conn.createStatement();
PreparedStatement ps = conn.prepareStatement("sql명령문 문자열");


6. 명령문 실행하기 및 데이터 담기
--select명령문 인 경우
//Statement자료형 객체인 경우
ResultSet rs = st.executeQuery("select명령문 문자열");

//PreparedStatement자료형 객체인 경우
ResultSet rs = ps.executeQuery();


rs.next(); => 1줄씩만 담아오는 오라클의 cursor객체와 유사한 기능
while (re.next()) {
실행코드들...;
}


--insert, delete, update명령문 인 경우 (데이터 갱신이 발생)
//Statement자료형 객체인 경우
st.executeUpdate("DML명령문 문자열");
int result = st.executeUpdate("DML명령문 문자열");

//PreparedStatement자료형 객체인 경우
ps.executeUpdate();
int result = ps.executeUpdate();

--사용한 객체 닫아주기 (생성한 역순으로 닫기)
if(!rs.isClose() || rs != null) {
rs.close();
}
st.close(); 또는 ps.close();
conn.close();


-------------------------------------------------------------------------
//
//35
//필기
//


SELECT명령문 => executeQuery(String select문)

DML명령문 => executeUpdate(String DML문)

ResultSet rs = st.executeQuery("select명령문 문자열");
ResultSet rs = ps.executeQuery();

rs.next(); => .next()는 [(오라클의 cursor객체에) fetch기능] + [rs객체에 데이터를 담는 기능]




<Statement와 PreparedStatement의 차이>
- Statement (정적쿼리)
1. 단일로 사용될 때 빠른 속도를 지닌다.
2. 쿼리에 인자를 부여할 수 없다.
3. 매번 컴파일을 수행해야 한다.
4. 쿼리문에 값이 미리 입력되어 있어야 한다.

-PreparedStatement (동적쿼리)
1. 쿼리에 인자를 부여할 수 있다.
2. 처음 프리컴파일 된 후, 이후에는 컴파일을 수행하지 않는다.
3. 여러번 수행될 때 빠른 속도를 지닌다.
4. 쿼리문에 값이 인자로 저장된다.





ResultSet 특징
- 1개의 결과 테이블을 저장(오라클의 cursor객체와 유사)
- 연결지향성 : DB와 연결하고 있는 동안만 데이터의 값을 저장
- forward only(next()) : 한쪽 방향으로만 이동
- next()를 실행하지 않으면 예외 발생.
- 결과값을 저장 할 수 있다.
- 저장 된 값을 한 행 단위로 불러 올 수 있다.
- 한 행에서 값을 가져올 때는 타입을 지정해서 불러 올 수 있다.





-------------------------------------------------------------------------
//
//36
//필기
//




DAO(Data Access Object) : 데이터베이스에 접근하기 위한 SQL명령문을 담고 있는 객체

DTO(= VO) : Data Transfer Object(데이터를 전송하는 객체) = Value Object(데이터를 저장하는 객체)






-------------------------------------------------------------------------
//
//37
//필기
//




-------------------------------------------------------------------------
//
//38
//필기
//



함수 - 리턴값 있는
프로시저 - 리턴값 없는




<<함수 (FUNCTION)>>
오라클에서 제공하고 있는 내장함수(= 빌트인함수)처럼
매개변수를 받아 뭔가를 처리해 그 결과를 반환하는 데이터베이스 객체이며,
사용자 정의 함수를 말함.
*****꼭 반환값이 있어야 한다. => 리턴문, 리턴값이 존재

//형식 :
CREATE OR REPLACE FUNCTION 함수이름 (매개변수1, 매개변수2, ...)
RETURN 데이터타입
IS[또는 AS]
변수, 상수 등 선언
BEGIN
실행부
...
RETURN 반환값;
[EXCEPTION]
END [함수이름];


//호출문형식 : 
<매개변수가 없는 함수 호출>
함수명 혹은 함수명()

<매개변수가 있는 함수 호출>
함수명(매개변수1, 매개변수2, ...)



<<프로시저>>
반환값이 없는 프로그램. 
특정 연산을 수행하기만 함.
- 테이블의 갱신이나 다른 테이블에 데이터를 백업하거나 하는 경우 등 이용한다.


<저장 프로시저 (Stored Procedure)>
- 자주 사용되는 쿼리문을 모듈화시켜서 필요할 때마다 호출하여 사용하는 것
- 형식 :
CREATE OR REPLACE PROCEDURE 프로시저명[(P1 [IN(디폴트)/OUT/INOUT] 데이터타입 := 값, ...)]
IS [또는 AS] 
변수, 상수 등 선언
BEGIN
실행문;
...
[EXCEPTION
예외처리문;]
END [프로시저명];
/


<키포인트>
-IN 매개변수는 참조만 가능하며 값을 할당 할 수 없다.
-OUT 매개변수에 값을 전달할 수는 있지만 의미는 없다.
-IN OUT 매개변수는 값 참조 및 전달이 가능하다.
-OUT, IN OUT 매개변수에는 디폴트값을 설정 할 수 없다.






ERD (Entity )



-------------------------------------------------------------------------
//
//43
//필기
//



비주얼 스튜디오

기본형식
<!doctype html>
<html>
<head>
</head>
<body>
</body>
</html>

대소문자 안가림 권장사항-소문자
마크업 - 태그로 된 언어

DTD(Document Type Definition)

- 요소(= 태그, 엘리먼트)
- <html> HTML 문서의 루트(root), HTML 문서의 영역(Scope), Document 최고조상
태그(요소)는 <> 안에
태그(요소)<>안의 시작엔 공백 안됨 뒤에는 가능
시작태그, 종료태그 명은 같음

- <head> HTML 문서의 메타데이터를 정의
메타데이터 - 웹 브라우저에는 직접적으로 표현되지 않는 정보를 의미
- <title> ~ </title> 문서의 제목을 정의

- DOCTYPE 문서타입

- html태그 형식
<시작태그명>컨텐츠</종료태그명>

*컨텐츠 : 텍스트, 태그들(이미지, 영상, 블록, 등) 



<!DOCTYPE html>
<html>
<head>
브라우저(눈)에 보이지 않는 부분에 대한 설정을 하는 곳
</head>
<body>
브라우저(눈)에 보이는 부분에 대한 설정을 하는 곳
</body>
</html>


*바디 안에 엔터, 탭, 공백 여러개가 있어도 공백한칸으로 인식됨


<시작태그명 속성명="값" 속성명='값' 속성명= "속성명:값;속성명:값;...."....> 컨텐츠
</종료태그명>

속성명='값'
속성명="값"
둘다 가능

속성의 생성주기 - 나의 시작태그부터 종료태그까지

컨텐츠를 다룰수 없는 태그 - 빈태그 // 종료태그가 없는 친구들


<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
</head>
<body>
</body>
</html>


가로 너비 width
세로 폭 height

- 블록레벨요소
자동으로 줄 바꿈
항상 새 줄에서 시작
기본값 가로 100퍼
가로, 세로의 크기, 바깥여백(margin 마진), 안쪽여백(padding 패딩)를 설정 할 수 있다.
height는 해당 컨텐츠의 공간 + 위 아래 여백 값
<p><pre><hr>

- 인라인레벨
바깥여백 없음
아무런 영향없이 한줄에 기술됨


***블록레벨의 width100퍼 = 자신을 감싸고 있는 부모 태그의 width100퍼



- 엔티티 코드 (자바의 이스케이프)
공백한칸 => &nbsp;   &#160;
< => &lt;   &#60;
> => &gt;   &#62;
& => &amp;   &#38;
" => &#quot;   &#34;
' => &#apos;   &#39;


<b> 글씨 진하게
<strong> 이거 중요하니까 글씨 진하게
<i> 글씨 기울이기
<em> 이거 중요하니까 기울이기
<s> 그냥 취소선
<del> 이거 변경(대체) 된거라는 취소선
<ins> 이거 추가 된거라는 밑줄
<u> 그냥 밑줄
<sup> 윗첨자(승수)
<sub> 아래첨자
<small> 글씨크기 13.33333... 픽셀
<mark> 형광펜 효과
<ul> 왼쪽패딩-마커자리, 디폴트-점, 순서가 없는 리스트-<li>(li-위아래여백 없음)
<ol> 왼쪽패딩-마커자리, 디폴트-숫자, 순서가 있는 리스트-<li>(li-위아래여백 없음)





html태그 형식
<시작태그명>컨텐츠</종료태그명>
**반드시 <태그명을 기술 할 때는 공백을 넣으면 안된다.

<시작태그명 속성명="값" 속성명='속성명:값;속성명:값;....;'>컨텐츠</종료태그명>
**반드시 속성은 시작태그안에만 기술 할 수 있다.

**속성명="속성명:값;속성명:값;...." 형식으로 기술되는 속성은 style속성만 가능하다. 다른 속성은 속성명="값"의 형식으로 기술 됨.

빈 태그(empty)
시작태그만 존재
<!DOCTYPE html>
<meta charset="UTF-8">
<hr>
<br>


주석
<!-- 내용 -->





===================================================================================================
*블록레벨요소
- 위 아래 마진(바깥여백)이 존재한다
- width(가로) 100%
- height는 컨텐츠 높이만큼
- 항상 새 줄에서 시작한다.
- 위 아래 마진이 겹치는 부분은 더 큰 마진으로 겹쳐져서 표현된다.
- width, height, margin(바깥여백), padding(안쪽여백) 조절이 가능하다.
- 특수한 경우의 블록레벨요소를 제외하고는 모든 안라인레벨요소와 블록레벨 요소를 감쌀 수 있다.



*인라인레벨요소
- 바깥여백, 안쪽여백 모두 없음
- 줄 바꿈 안됨
- 한 줄에 나열 할 수 있다.
- width, height는 컨텐츠의 크기 만큼의 영역만 가진다.
- width, height 조절 불가
- padding 조절 가능(4방향 모두)
- margin 좌우만 조절 가능(상하 조절 안됨)
- 특수한 경우의 인라인레벨요소를 제외하고는 모든 안라인레벨요소는 인라인레벨요소들만 감쌀 수 있다.



*특수케이스의 블록레벨의 종류
<ul>, <ol> : 마커를 표현하기 위한 영역부분인 왼쪽 패딩이 존재한다.
<dt> : 위 아래 여백 없음
<dd> : 위 아래 여백 없음, 왼쪽마진이 존재함(임대영역이 100%, 실사용영역은 마진을 제외한 영역 - 실제 컨텐츠의 너비(width))
<li> : 위 아래 여백 없음
===================================================================================================




-------------------------------------------------------------------------
//
//44
//필기
//

기본형식
<!doctype html>
<html>
<head>
</head>
<body>
</body>
</html>




table 태그
데이터를 표형식으로 줄행 row  칸열 column 엘리먼트
tr th td 태그과 같이 쓰임
블럭요소임

tr
줄행을 설정
블럭레벨
마진 패딩 없음
마진 패딩 조절불가

th
칸열을 설정
인라인요소
표내용의 제목 담당

td
칸열을 설정
인라인요소
내용 정렬 디폴트 수평-왼쪽 수직-중간



margin: 0 auto;
- 나(블럭레벨)의 수평의 가운데 정렬을 지정하는 속성
- 반드시 가운데 정렬하고자 하는 블럭레벨 요소에 직접 주어야 한다.
- 반드시 움직일 수 있는 영역이 존재해야 한다. (실제영역이 100%가 되면 안됨)

예) table{border-collapse: collapse; margin: 0 auto;}
에) <p style = "width: 30%; margin: 0 auto;">테스트 텍스트</p>



text-align:
- 인라인레벨의 수평 정렬을 지정하는 속성
- 기본값은 left
- 수평정렬의 예약값은 left(기본), center(가운데), right(오른쪽)이 있다.
- 반드시 수평정렬을 시키고자 하는 대상을 감싸고 있는 요소(태그)에 기술해야 한다.
- 반드시 움직일 수 있는 영역이 존재해야 한다.
- 인라인레벨, 블럭레벨 모두에 해당 속성을 기술 할 수 있다.
**html에서는 텍스트로 취급되는 대상(요소)은 글자포함, 인라인레벨 요소들이다.


인라인레벨을 핸들링하는 속성들은 상속이 됨
블럭레벨은 상속 안됨



<colspan, rowspan 예시>
<table>
<tr><th>제목1</th><th colspan = "2">제목2</th><th>제목3</th>	</tr>
<tr><td rowspan="2">내용1</td><td>내용2</td><td>내용3</td>	<td>내용4</td></tr>
<tr><td>내용2</td><td>내용3</td><td>내용4</td></tr>
</table>




table의 자식으로 올 수 있는 태그
thead, tbody, tr, caption

table의 자손으로 올 수 있는 태그
tr, th, td



특수케이스의 블럭레벨요소

table: 임대영역 100%(실제영역: 컨텐츠 크기만큼)
위 아래 여백이 없다. margin, padding, width, height 조절가능

tr : 부모태그의 width 100%
width, height만 조절가능, margin, padding 조절불가능

thead, tbody (기술하지 않으면 자동으로 브라우저에서 생성해줌)
: 테이블에서 내가 원하는 행에만 스타일을 적용하고자 하는 경우 사용하는 태그

caption : table태그의 맨 처음 자식으로 기술(권장)
가운데 정렬을 가지고 있다.
테이블안에서만 위의 천성을 가질 수 있다.



특수케이스의 인라인레벨요소

td : 
width, height 조절이 가능 (인라인레벨은 원래 안됨)
블럭레벨요소를 감쌀 수 있다. (인라인레벨은 원래 안됨)

th : 
width, height 조절이 가능 (인라인레벨은 원래 안됨)
블럭레벨요소를 감쌀 수 있다. (인라인레벨은 원래 안됨)
천성- 글씨 굵게(font-weight), 수평 가운데 정렬(text-align: center)




a태그 : 인라인레벨요소 (특수케이스)
블럭레벨을 감쌀 수 있다.

a태그 => Link태그
href속성 => 다른 페이지(웹문서)로 이동 가능하도록 해주는 속성

형식
<a href = "경로포함.웹문서명.확장자명까지" [target="다른페이지가 열리는 방법기술"]>컨텐츠</a>
<a href = "url주소값" [target="다른페이지가 열리는 방법기술"]>컨텐츠</a>


href속성의 천성
공통 속성 : 실선 밑줄
바로 보기만 하는 상태 : link상태 => 글씨 색상 : 파란색
누르고 있는 상태(활성화 된 상태) : active 상태 => 글씨 색상 : 빨간색
클릭하고 페이지 이동 후 다시 본 상태(방문하고 난 후 상태) : visited 상태 => 글씨 색상 : 보라색(자주색)
마우스만 올려놓은 상태 : hover 상태 => 마우스커서가 포인터(작은 손) 모양으로 바뀜


target 속성값 : 
_self (디폴트) : 현재 창에서 새로운 페이지를 보여주세요.
_blank : 새창에서 새로운 페이지를 보여주세요.
_parent : 나(자식팝업창)의 부모창에서 새로운 페이지를 보여주세요.
_top : 나(자식팝업창)의 최고 조상창에서 새로운 페이지를 보여주세요.


절대경로 : 실제 파일이 들어있는 경로를 처음부터 끝까지(드라이버명부터 폴더명들 포함, 파일명.확장자명까지) 기술하는 방법
C:\hwork\04/13aTag.html

상대경로 : 나의 웹문서파일을 기준으로 내가 찾는 파일(웹문서 또는 이미지파일 등등)의 상대적인 위치를 기술하는 방법
나의 상위 위치 : ../
<a href = "../01/02pTag.html">move</a>

동일 위치 : ./ 나 안씀
<a href = "./13aTag.html">move</a>
<a href = "13aTag.html">move</a>


a태그의 href로 책갈피 기능 할 수 있음
id를 지정해주고 id로 이동하는 방식
href한테는 #으로 id의 기능을 할 수 있음


-------------------------------------------------------------------------
//
//45
//필기
//

기본형식
<!doctype html>
<html>
<head>
</head>
<body>
</body>
</html>




- img 태그 : 
웹 페이지에 이미지를 보여주기 위해 사용
src 속성이 꼭 기술되어야 한다. 다른 속성은 없어도 상관 없다.
빈 태그(empty tag)이다.
인라인 요소로 한 줄 바꿈이 되지 않는다.
너비, 폭 미 지정 시 디폴트는 원본 파일 크기로 적용 됨.
width속성이나 height속성을 바로 사용하는 경우는 단위를 픽셀로 자동 인식하나 style속성 안에 나열되는 속성으로 사용되는 경우는 단위를 꼭 기술해 주어야만 제대로 인식한다.
기본 정렬 값은 left-bottom이다.


- IMG태그 형식 (= 문법, Syntax) : 
<img src = "이미지파일 경로" alt = "값" title = "텍스트" width = "값" height = "값">
<img src = "이미지파일 경로" alt = "값" title = "텍스트" style = "width : 값(px 또는 %, vw); height = 값(px 또는 %, vh);">


- src 속성 : 
파일의 경로를 표시하는 속성을 지정
시작 엘리먼트에 지정된다.
절대경로 : 고정된 경로를 지정하는 방법
상대경로 : 파일의 위치를 고려하여 상대적으로 경로를 지정하는 방법 등이 있다. (되도록 상대 경로를 권장. 다른 곳으로 옮겨도 파일들의 위치만 동등하게 해주면 이미지가 손실 될 염려가 없다.)


- 너비, 폭 관련 속성 : 
픽셀(px)값이나 비율(%)값으로 나타냄.
시작 엘리먼트 안에 기술 할 것
width : 가로 너비 속성, height : 세로 폭 속성.
형식 : width = "값" height = "값"  또는  style = "width : 값; height : 값;"


- alt 속성 : 
이미지를 표시 할 수 없는 경우 이미지의 대체 텍스트를 지정함.
시작 엘리먼트에 기술
형식 : alt = "텍스트"


- title 속성 : 
웹 접근성 중 하나, 이미지의 설명
요소에 대한 몇 가지 추가 정보를 정의 함.
마우스를 오버하면 툴팁처럼 내용이 보여진다 하여 툴팁기능 이라고 함.
웹 접근성의 가장 기본적인 속성임.
시작 엘리먼트에 기술
형식 : title = "텍스트"


- lang 속성 : 
html 시작 엘리먼트(<html>)에 기술
웹 페이지의 언어와 국가를 명시 할 때 사용. (예: ko-KR: 한국어-한국/ en-US: 영어-미국/ ja-JP: 일본어-일본)
검색 시 웹 페이지의 언어나 국가를 파악하기 위한 것이지 웹 페이지를 해당 언어로만 기술해야 하는것은 아니다.
형식 : lang = "언어코드-국가코드"



텍스트는 테두리가 없음
텍스트에 보더를 주고 싶다면 인라인레벨로 묶어줘야함



form요소
form태그 안에 전송에 해당되는 input이나 button등의 submit 속성이 있어야 데이터 전송을 할 수 있다.
input요소의 name속성과 value가 있어야 데이터를 서버측에서 전달 받을 수 있다.
form컨트롤 요소들이 form안에 있어야만 데이터를 서버측에 전달 할 수 있다.
^^^
데이터를 전송하기 위한 조건
1. 입력요소들이 반드시 form태그 안에 존재해야 한다.
2. 입력요소 안에 반드시 name속성이 존재해야 한다.
**name속성이 자바에서 데이터를 가져올때 필요한 파라미터(매개변수) 역할을 한다.
3. 반드시 form태그 안에 submit이 존재해야 한다.


쿼리스트링방식(QueryString) 이란 
url뒤에 ?name명=value값&name명=value값 (name과 value의 쌍으로) 형식으로 전송하는 방식


input, select, textarea
데이터를 입력 할 수 있는 기능을 가진 입력요소들(입력태그들)은 반드시 form태그 안에 컨텐츠로 있어야 한다.


<form>
action="나의페이지경로" 가 숨어있음
method="get" 이 숨어있음
target="_self"가 숨어있음
autocomplete="on"이 숨어있음
method : 내가 입력한 데이터를 전송하는 방식


form -> 특수케이스블록레벨 위아래 여백이 없음


**폼태그의 입력요소로 전송하는 데이터는 모두 문자열로 전송됨.
**텍스트 입력요소에 값을 기입하지 않고 전송하는 경우는 빈문자열값으로 전송됨.(null아님)


label -> 인라인레벨
label이 입력요소의 앞에 있으면 머리말 역할
label이 입력요소의 뒤에 있으면 꼬리말 역할
type = "text" : 한줄문자열
type = "submit"이 있는 나를 감싸고 있는 입력요소가 있다면 그 데이터를 담아서 폼태그의 액션주소로 실행하는 기능
나(type = "submit")를 감싸고 있는 폼태그의 액션주소로 실행하는 기능
id속성은 중복값을 가질 수 없다.
input이 label태그 안에 있지 않으면 label에 for속성을 입력하고 id속성의 값을 넣어주면 label의 영역이 늘어남
input이 label태그 안에 있으면 for속성이 없어도 label의 영역이 늘어남


input -> 특수케이스인라인레벨
input태그의 type의 디폴트는 text이다.
input태그의 value는 데이터의 기본값을 설정하는것


button -> 특수케이스인라인레벨
submit버튼
<input type="submit" value = "가입하기">
<button type = "submit">가입하기</button>
<button type = "reset"> - 처음상태로 되돌려라, 초기값으로 되돌려라

type="submit" 일때 value를 쓰지 않으면 디폴트값이 한국은 "제출"이다
button태그가 form태그 안에 있으면 type의 디폴트는 submit이다.
button태그가 form태그 안에 있지 않으면 type의 디폴트는 button이다.


form태그의 
- action속성
1. 내가 이동해야 할 페이지 경로를 기술하는 속성
2. 나의 데이터를 전송할 페이지 경로를 기술하는 속성

- method속성
내가 입력한 데이터를 어떤 방법으로 전송할지 지정하는 속성
1. get방식 : url뒤에 name과 value의 쌍으로 데이터가 보여지도록 전송하는 방식
(기본값임. method속성을 기술하지 않으면 get방식으로 전송됨.)
길이 제한이 있어 대용량 데이터(파일 등)를 전송할 수 없다.

2. post방식 : 본문(body)안에(실제로는 header영역) 데이터를 숨겨서 전송하는 방식
(get방식처럼 name과 value의 쌍으로 데이터를 전송하는 것은 동일함)
길이 제한이 없어 대용량 데이터를 전송할 수 있으며, 보안처리 되어야 하는 데이터를 전송할 때 사용한다.

- submit속성
나를 감싸고 있는(submit을 가지고 있는) form태그의 action속성을 실행시킨다.(활성화한다.)



get방식 - url뒤에 쿼리스트링방식으로 달아 보내는 방식



legend -> 특수블럭레벨, 임대영역-100%, 실제영역-컨텐츠크기만큼 
                이라 text-align:으로도 옮길 수 있다.


style태그에서
ul {list-style: none;} -> none은 리스트의 마커만 없애는 값





-------------------------------------------------------------------------
//
//47
//필기
//




CSS
스타일 시트

1. 인라인 스타일 시트 (inline style sheet) : 시작 엘리먼트 안에 style 속성을 이용하여 기술하는 방식

2. 내부 스타일 시트 (internal style sheet) : <style></style> 태그를 이용하여 기술하는 방식

3. 외부 스타일 시트 (external style sheet) : 외부의 (.css)스타일시트파일을 link태그를 이용하여 끌고와서 사용하는 방식

(2,3번 선택자 필수)


범위의 우선순위
[좁음]				[넓음]
인라인		< 내부		< 외부

인 - 적용된 엘리먼트(= 태그)만 적용
내부 - <style>태그가 포함된 html문서 내에서만 적용됨 <한 페이지만>
외부 - link태그로 끌어다 사용하는 모든 html문서 내에서 적용됨


동일한 style 적용시 우선순위
[낮음]				[높음]
외부		< 내부		< 인라인



[color]

1. # : 16진수(헥사)표기법
값 형식 : #00/00/00 => 1,2번째 0-Red색상코드(0~f), 3,4번째 0-Green색상코드(0~f), 5,6번째 0-Blue색상코드(0~f)
r,g,b 각각의 두자리들이 같으면 3자리로 단축 가능 => #fff, #258, #abc,
--------------------------------------------------------------------------------------------------------------------------------------------------
2. rgb 또는 rgba 함수를 이용하는 표기법
rgb (red 0~255, green 0~255, blue 0~255)
rgba (a=alpha 투명도 : 0%~100%, 0~1사이 실수) rgba (red 0~255, green 0~255, blue 0~255, a 0%~100%(0~1))
--------------------------------------------------------------------------------------------------------------------------------------------------
3. hsl 또는 hsla 함수를 이용하는 표기법
hsl (h : hue-색상(0도~360도), s : saturation-채도(0%~100%), l : lightness-명도(0%~100%))
hsla (h : hue-색상, s : saturation-채도, l : lightness-명도, a : alpha-투명도)

hue - 0도~120도(green), 120도~240도(blue), 240도~360도(red)
saturation - 0%~100%, 커질수록 맑아짐, 실수x
lightness - 0%~100%, 50%가 기본 밝기, 커질수록 밝아짐, 실수x
alpha - 투명도, 0%~100%(0~1)
--------------------------------------------------------------------------------------------------------------------------------------------------


<스타일 표기 형식 (소문자로 기술 권장)>

선택자 {
속성명 : 속성값;
속성명 : 속성값;
속성명 : 속성값; 속성명 : 속성값;
}




무뇌태그
        span => 아무 천성이 없는 인라인레벨요소, 특정 텍스트에 style을 주기 위한 태그
        div => 아무 천성이 없는 블럭레벨요소(width:100%만)



background-color: transparent => 투명색으로



        table {
        /*요소선택자 - 태그명*/
            width: 100%;
            font-family: Georgia;
            font-style: italic;
            border: 1px solid black;
            border-collapse: collapse;
        }

        table td {
        /*자손선택자 - 선택자 사이에 콤마가 아닌 공백 한칸을 쓰는 경우
        (ㄴtable안에 존재하는 태그들 중에 자식이나 자손으로 존재하는 td들)이라는 뜻*/
            border: 10px solid red;
            padding: 10px 20px;
        }

        table.none {border-style: none;}
        /*(ㄴtable태그에서 class속성 값이 none인 table)이라는 뜻*/

        table.hidden {border-style: hidden;}
        /*(ㄴtable태그에서 class속성 값이 hidden인 table)이라는 뜻*/



영역을 가질 수 있는 조건
1. 태그 사이에 컨텐츠가 존재해야 한다.
2. (컨텐츠가 없을 때,) 선스타일과 선두께 들의 border를 설정하는 스타일이 존재해야 한다. (인라인)
3. (컨텐츠가 없을 때,) 해당 엘리먼트의 width와 height속성이 고정단위(px, vw, vh) 값으로 지정 되어야 한다.



-------------------------------------------------------------------------
//
//48
//필기
//




선택자의 대상 : 요소(태그)가 스타일을 적용하는 대상이 된다.
table, th, td : 그룹선택자


* : 범용선택자 (모든 태그에)


조합 선택자 : 
[예) 
table(a) td(b)]
- table (공백한칸) td : 자손선택자(자식, 자손), a안에 들어있는 자식, 자손으로 존재하는 b태그
- table > td : 자식선택자, 자식만 가능, 자손은 안됨, a안에 들어있는 자식b만
- table(a) + td(b) : 인접 형제선택자, a의 바로 뒤에 붙어있는 b태그 하나만
- table(a) ~ td(b) : 일반 형제 선택자, a의 뒤에 있는 b태그들

가상클래스 선택자 : 
요소나 요소를 지칭하는 선택자에 기생해서만 사용



<input type = "text" id = "uid" name = "id" class = "form1" style = "속성명:속성값;">
<input type = "text" id = "uid1" name = "id" class = "form1" style = "속성명:속성값;">
<input type = "text" id = "uid2" name = "id" class = "form" style = "속성명:속성값;">
<input type = "text" id = "uid3" name = "id" class = "form" style = "속성명:속성값;">
<button class = "form1" style = "속성명:속성값;">버튼1</button>
<button class = "form1" style = "속성명:속성값;">버튼2</button>


id속성은 중복값 불가능 (다른 속성은 중복값 가능)
input#uid : input태그안에 uid라는 값의 id속성

class : 내가 특정적으로 여러개의 태그만 묶고자 할때 사용 / 태그.(점)클래스명 으로
input.form1


동일한 타겟의 선택자가 존재할 땐 선택자의 우선순위로 정해지는데 
딸리는 선택자 안에 우선순위 선택자에 없는 속성이 있으면 적용 됨


style = "float속성:값;" : 블록레벨요소를 해당 값 방향에 붙히고 
브라우저의 해당 값 공간을 없는 공간이라 침, 인라인레벨요소가 된 것 처럼 보이게 함 
float속성을 받게 되면 width가 100%에서 컨텐츠너비만큼으로 바뀜 
- clear속성이 나오면 float속성을 끊어버림



선택자 우선순위

선택자		1000	100	10	1	계산식
*{}		0	0	0	0	specificity = 0,0,0,0
table , td, th{}	0	0	0	1	specificity = 0,0,0,1
li:first-line {}	0	0	1	1	specificity = 0,0,1,1
ul li 		0	0	0	2	specificity = 0,0,0,2
ul ol+li {}		0	0	0	3	specificity = 0,0,0,3
h1 + *[type=text]{}	0	0	1	1	specificity = 0,0,1,1
ul ol li.red {}	0	0	1	3	specificity = 0,0,1,3
li.red.level {}	0	0	2	1	specificity = 0,0,2,1
#userid {}		0	1	0	0	specificity = 0,1,0,0
style=""		1	0	0	0	specificity = 1,0,0,0
!important	최상위 우선순위를 가진다.				
			




	가상클래스(:) 선택자
        /* 아무것도 실행되지 않은 상태(초기 상태) */
        /* 가상클래스 선택자는 태그를 타겟으로 하는 선택자 뒤에 기생하여 사용 할 수 있다. */
        /* 단독사용불가 */
        /* 반드시 해당 타겟 요소에 붙여서 기술해준다. */




        (권장) :hover속성은 :link 와 :visited속성 뒤에 와야 한다.
        (권장) :active속성은 :hover속성 뒤에 와야 한다.
        위의 규칙이 지켜지지 않을 경우 :active나 :hover속성이 적용 안될 수 있다.
        (권장순서) :link => :visited => :hover => :active






        display속성은 해당 요소를
        none : 보여지지 않도록 처리함. 영역이 완전히 사라짐.
        
        block : 영역을 블록으로 보여지도록 처리함.




        /* 가장 첫번째 p요소안의 모든 서체 색상 */
        p:first-of-type {color: blue;}

        /* 가장 마지막 p요소안의 후손 em요소들의 서체 색상 */
        p:last-of-type em {color: red;}

        /* 가장 첫번째 p요소안의 모든 서체 색상 */
        /* p:first-child {color: blue;} */
        /* 없어진 친구 */

        /* p요소 중 끝에서 세번째 em엘리먼트의 배경색 */
        p:nth-last-of-type(3) em {background: hotpink;}

        /* 2번째 p요소의 배경색 => nth-of-type(값) : 값은 1부터 시작. */
        p:nth-of-type(2) {background: red;}

        /* 홀수번째의 해당 요소의 배경색 */
        span:nth-of-type(odd) {background: green;}
        
        /* 짝수번째의 해당 요소의 배경색 */
        span:nth-of-type(even) {background: yellow;}

        /* 3의 배수에 해당되는 요소 선택 */
        h1:nth-of-type(3n+0) {background: skyblue;}

        /* 3의 배수에 더하기 1을 한 것에 해당되는 요소의 배경색. n은 0부터 시작 */
        h1:nth-of-type(3n+1) {background: gray;}




        /* 체크된 input요소를 선택 */
        input:checked {height: 50px; width: 50px;}

        /* input 요소에서 disabled(비활성화) 속성을 가진 요소 */
        input:disabled {background: red;}

        /* input 요소에서 disabled(비활성화) 속성이 없는 요소 */
        input:enabled {background: #FF0;}



        /* 선택한 엘리먼트(p)가 아닌 모든 요소들의 */
        :not(p) {속성명:속성값;}




        ::선택자는 앞의 요소 및 뒤의 요소에 공백이 있으면 안됨.
        모두 붙여서 기술해야 한다.
        p ::before (X) , p:: before (X), p::brfore (O)
       

        /* span엘리먼트 안의 content(내용) 뒤에 추가 */
        span::after {
            content: " -Rem ember this";
            color: red;
        }

        /* p엘리먼트 안의 content(내용) 뒤에 추가 */
        p::before {
            content: "Read this -";
            color: blue;
        }

        /* p엘리먼트 안의 첫번째 글자 선택 */
        /* ::first-letter 선택자는 블럭요소에만 사용 가능 */
        p::first-letter {
            font-size: 200%;
            color: #8A2BE2;
        }




        /* 브라우저에 보여지는 첫 번째 줄 선택, 블록 요소에만 사용 가능 */
        p::first-line {background-color: yellow;}




        optional selector는 form 컨트롤 요소(엘리먼트) 중
        required(필수입력) 속성이 없는 요소를 의미한다.
        :optional 선택자는 익스플로러9버전 이하는 지원하지 않는다.



        [ ] -> 속성선택자

        /* 속성 선택자는 특정 속성을 가진 요소를 선택하는데 사용된다. */
        형식 1 : a[target] => 엘리먼트명[속성명]
        형식 2 : a[target = "_blank"]
        => 엘리먼트명[속성명="속성값"] or 엘리먼트명[속성명=속성값]



        text-decoration 속성
        형식 : text-decoration: 선위치 선모양 선색상;
        - 선위치 : 
          none : 선없음 / overline : 윗줄 /
          underline : 밑줄 / line=through : 취소선(가운데 선)
        - 선 스타일(선모양) : 
          wavy : 물결 / dotted : 점선 / double : 겹선




**브라우저(body)와 창의 구분
브라우저(body)에서의 줄바꿈 <br>
창에서의 줄바꿈 \n

창-textarea, alert(문자열), 등




-------------------------------------------------------------------------
//
//49
//필기
//


        /* 
        title속성 중에서 flower라는 단독 문자열이 있는(공백으로 구분) 요소만 선택
        flowers, my-flower, flower-tree 같이 무언가 연결된 문자열은 해당 안됨.
        [title~="flower"] or [title~=flower]
        */
        [title~="flower"] {border: 5px solid red;}

        /* top라는 문자열이 맨 앞에 있으면서 단독으로 있거나 -(하이픈, 대시)로 나뉘어져 있는 요소만 선택.
        topcontent, content-top과 같은 문자열은 해당 안됨. */
        [class|=top] {background: lavender;}

        /* top라는 문자열로 시작되는 모든 요소 */
        [id^="top"] {background: skyblue;}

        /* class명이 test라는 문자열로 끝나는 모든 요소 */
        [class$="test"] {background: red;}

        /* class명의 일부에 te라는 문자열이 포함된 모든 요소 */
        [class*="te"] {color: green;}



textarea의 스타일요소 중 resize => 크기 조절 기능을 조정함


*****웹 접근성을 잘 지키자*****
//데이터는 전송해야하고, 내용은 지정해놔야 할 때 웹 접근성에 맞추기 위해 readonly 처리와 background-color를 연한회색으로 해줌




list-style-type : 마커 모양(ul, ol)변경 속성.

list-style-position : 마커 들여쓰기 속성. 기본값:outside
**inside속성은 list-style-type: none; 일때는 적용되지 않는다.

list-style-image : 마커 스타일을 이미지로 사용 할 수 있는 속성.

list-style : shorthand방식. 마커모양, 들여쓰기속성, 이미지사용속성 값들을 같이 사용 가능.




<link>태그 (head에 기술)
 - href 속성 : 참조 할 파일 위치(필수)
 - rel 속성 : 문서와의 관계를 명시하는 속성(필수)
 - type 속성 : 링크된 문서의 MIME타입을 정의하는 속성(type 생략가능)
 **MIME(Multipurpose Internet Mail Extensions : 다목적의 인터넷 메일 확장자) : 웹을 통해 여러 형태의 파일을 전달하는데 사용하는 속성.




text-align : 
- 인라인레벨요소의 수평 정렬을 시키는 속성 
- 속성값 : left, center, right
***- 수평정렬을 시키고자 하는 인라인레벨 요소를 감싸고 있는 부모태그에 속성을 기술해주어야 한다.***


vertical-align : 
- 인라인레벨요소의 수직 정렬을 시키는 속성
- 속성값 : top, middle, bottom
***- 수직정렬을 시키고자 하는 인라인레벨 요소에 직접 속성을 기술해주어야 한다.




        - clear속성값: 
        left - 해당 요소에 바로 인접한 좌측에 플로팅 요소가 허용되지 않음
        right - 해당 요소에 바로 인접한 우측에 플로팅 요소가 허용되지 않음
        both - 해당 요소에 바로 인접한 양쪽에 플로팅 요소가 허용되지 않음
        inherit - 상위 요소(부모요소)의 클리어 값을 상속받음.




참고:
display: block;
요소를 블럭레벨요소로 변경해주는 속성.
블럭 속성을 적용 할 수 있도록 해준다.

display: inline;
요소를 인라인레벨요소로 변경해주는 속성.
인라인 속성을 적용 할 수 잇도록 해준다.

display: inline-block;
인라인요소: 인라인 속성을 유지하면서 블럭 속성의 일부 속성을 사용 할 수 있도록 해준다.
블럭요소: 블럭 속성을 유지하면서 인라인 속성의 일부 속성을 사용 할 수 있도록 해준다. 




-------------------------------------------------------------------------
//
//50
//필기
//



----------------------------------------------------------------------
되도록 인라인레벨 엘리먼트 안에 블록레벨 엘리먼트를 넣지 말자
=
되도록 블록레벨 엘리먼트를 인라인레벨 엘리먼트로 감싸지 말자
----------------------------------------------------------------------
ㄴ해당 인라인레벨 엘리먼트에 스타일을 주었을때 정상처리가 되지 않을 수 있기때문




        /* overflow | overflow-x(width필요) | overflow-y(height필요) 속성값 */

        visible : 오버플로가 잘리지 않고 모두 표현. 기본값(디폴트)
        hidden : 오버플로가 잘리고 나머지 내용은 보이지 않음.
        scroll : 오버플로가 잘리지만 나머지 내용을 보려면 스크롤 막대가 추가됨.
        auto : 오버플로에 대해 자동으로 설정 처리.
        만약 오버플로가 잘린 경우는 스크롤을 추가해야만 한다. 자동추가 안됨.



        텍스트의 수가 적어서 이미지의 높이를 벗어나지 못하면,
        그 부분을 감싸고 있는 div박스의 영역이 이미지를 감싸지 못하고, 
        그 안으로 들어가게 되는 현상이 발생된다.
        이 부분을 해결하기 위해서 넘치는 부분(overflow)의 값을
        어떻게 처리할 지 설정해 주면 된다.




    style의
    position속성 : 
	- static
	기본적인 배치임. 기본값(디폴트)으로 별도로 지정하지 않아도 되는 속성임.

	- sticky
	상대적 위치의 x축, y축 좌표를 기준으로 설정한 위치에 달라 붙어 있는다.

	- relative
	자신이 위치해야하는 좌측상단 좌표를 기준으로 위치를 지정한다.
	위치 top, right, left, bottom으로 지정 가능하다.
	이동한 만큼 다른 영역을 침범한다.

	- fixed
	지정한 위치에 위에 떠 있는 것처럼 고정된다.
	위치 top, right, left, bottom으로 지정 가능하며, 단위는 px, %등으로 지정 가능하다.

	- absolute
	absolute를 설정해주면 width, height가 컨텐츠크기로 바뀜
	absolute의 지정한 위치는 부모태그를 기준으로 인식함.
	내가 원하는 위치를 지정하려면 부모태그를 relative로 만들어줘야함
	relative속성이 붙은 부모태그가 없으면 부모태그는 자동으로 body가 됨
	

    z-index속성은 층 수를 정하는 속성이다.
    static은 z-index의 영향을 받지 않는다.






        @media 형식
        @media [only | not] [device종류] and (조건문) {
            #ids {color: white;}    ==> 실행문 예시
        }

        device종류: all(기본값) | screen | tv ...등등





시멘틱요소 Layout태그들
- 특수케이스 블록레벨
- width 100%, 마진, 패딩 없음



1. header - 문서 또는 섹션에 대한 헤더를 정의.
2. nav - 탐색 링크 집합(메뉴바, 네비게이션)을 정의.
3. section - 문서에서 섹션(내용이나 단락의 집합)을 정의.
4. article - 독립적인 내용을 정의.
5. footer - 문서 또는 섹션에 대한 바닥글 정의. 제작정보나 저작권정보, 기업 정보 표시





flex => 블럭레벨, 블럭레벨들의 수직,수평 위치조정하기 쉽게 해주는 태그 


[justify-content: ]
flex-start(디폴트) => left, top, 
flex-center => 가운데 배치
flex-end => right, botton, [row-reverse]랑 비슷한데 순서가 안바뀜
space-between => 첫번째 애는 스타트에 마지막 애는 엔드에 붙히고 동일한 간격으로 배치
space-around => 모두 다 동일한 간격으로 배치


flex-wrap: [wrap] => 줄바꿈에 대한 속성, 한줄로 정렬하고 부모 요소의 width가 넘으면 밑줄에
flex-wrap: [nowrap](디폴트) => 줄바꿈에 대한 속성, 한줄로 정렬하는데 부모 요소의 width가 넘으면 자식 요소의 사이즈를 줄임, 자식 요소의 사이즈도 다 줄였으면 부모 요소를 넘어감


flex-direction: [row] => 수평방향으로 나열, width 자동조절(컨텐츠 만큼), height 자동조절안됨(부모만큼 쭉)
flex-direction: [column] => 수직방향으로 나열, width 자동조절안됨(100% 그대로), height 자동조절안됨(컨텐츠 만큼)
flex-direction: [row-reverse] => 수평방향, 역순(오-왼) 정렬인데 순서도 바뀜


[line-height: 크기(px)] => 텍스트 줄 간격




#벤더프리픽스 (Vender Prefix) 란 : 
웹 브라우저 공급자가 새로운 기능을 제공할 때 이전 버전의 웹 브라우저에 그 사실을 알려주기 위해 사용하는 
접두어(prefix)를 의미함
** 높은 버전의 브라우저들은 대부분의 기능이 제공되므로 프리픽스를 사용 할 필요가 없다.


#프리픽스를 사용해야 하는 이유
1. CSS 권고안에 포함이 되지 못한 기능인 경우
2. CSS 권고안에는 포함되어 있지만 완벽하게 제정된 상태가 아닌 기능인 경우
3. 해당 기능이 포함되어 있지 않은 이전 버전의 웹 브라우저인 경우


#프리픽스 형식
-벤터프리픽스명-속성명
(또는)
-벤더프리픽스명-속성값


#웹브라우저별 벤터프리픽스
------------------------------------------------------------------------
브라우저(Browser)		     :	벤더프리픽스(Vender Prefix)
------------------------------------------------------------------------
IE, Edge, 브라우저		     :	-ms-

Chrome, Android 브라우저, 	     :	-webkit-
Chrome for Android, 	     :	-webkit-
Safari, IOS Safari 브라우저 	     :	-webkit-

Firefox 브라우저		     :	-moz-

Opera 브라우저		     :	-o-
------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//51
//필기
//



float width height 컨텐츠 크기

flex width 컨텐츠길이 height 


시멘틱요소 Layout태그들
- 특수케이스 블록레벨
- width 100%, 마진, 패딩 없음



1. header - 문서 또는 섹션에 대한 헤더를 정의.
2. nav - 탐색 링크 집합(메뉴바, 네비게이션)을 정의.
3. section - 문서에서 섹션(내용이나 단락의 집합)을 정의.
4. article - 독립적인 내용을 정의.
5. footer - 문서 또는 섹션에 대한 바닥글 정의. 제작정보나 저작권정보, 기업 정보 표시





flex => 블럭레벨, 블럭레벨들의 수직,수평 위치조정하기 쉽게 해주는 태그 


[justify-content: ]
flex-start(디폴트) => left, top, 
flex-center => 가운데 배치
flex-end => right, botton, [row-reverse]랑 비슷한데 순서가 안바뀜
space-between => 첫번째 애는 스타트에 마지막 애는 엔드에 붙히고 동일한 간격으로 배치
space-around => 모두 다 동일한 간격으로 배치


flex-wrap: [wrap] => 줄바꿈에 대한 속성, 한줄로 정렬하고 부모 요소의 width가 넘으면 밑줄에
flex-wrap: [nowrap](디폴트) => 줄바꿈에 대한 속성, 한줄로 정렬하는데 부모 요소의 width가 넘으면 자식 요소의 사이즈를 줄임, 자식 요소의 사이즈도 다 줄였으면 부모 요소를 넘어감


flex-direction: [row] => 수평방향으로 나열, width 자동조절(컨텐츠 만큼), height 자동조절안됨(부모만큼 쭉)
flex-direction: [column] => 수직방향으로 나열, width 자동조절안됨(100% 그대로), height 자동조절안됨(컨텐츠 만큼)
flex-direction: [row-reverse] => 수평방향, 역순(오-왼) 정렬인데 순서도 바뀜



[line-height: 크기(px)] => 텍스트 줄 간격

[opacity: (0~1 사이 실수)] => 엘리먼트의 투명도




[box-shadow: ] => 그림자효과

/* x축값 | y축값 | color */
예:)
#div1 {box-shadow: 60px -16px teal;}

/* x축값 | y축값 | blur-radius 번짐 | color */
예:)
#div2 {box-shadow: 10px 5px 5px black;}

/* x축값 | y축값 | blur-radius 번짐 | spread-radius 퍼짐 | color */
예:)
#div3 {box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);}

/* inset (내용안으로 그림자 넣기) | x축값 | y축값 | blur-radius 번짐 | color */
예:)
#div4 {box-shadow: inset 50px 10px 3px gold;}

/* 여러개의 그림자를 주고 싶은 경우, 쉼표로 나열 */
예:)
#div5 {box-shadow: 3px 3px red, -1em 0 0.4em olive;]




[background-size: ]
(백그라운드의 이미지를 조절하는 속성)
/* width:~px; height:~px; */
/* cover : 전체 컨테이너를 덮도록 배경 이미지 크기를 조정하는 속성값 */




audio태그 속성들
(특수케이스 인라인레벨요소, width와 height 조절이 가능함)
1. autoplay: 자동재생. 크롬, 엣지, 등 지원 안되는 브라우저가 있음. 파이어폭스 지원됨.
2. controls: 화면에 컨트롤 할 수 있는 막대를 표시함. 재생, 멈춤, 진행바, 볼륨, 진행속도, 등을 표시
3. loop: 반복 재생.
4. muted: 음소거 기능.
5. preload: 페이지가 브라우저에 로드 될 때 오디오 파일이 같이 로드 되어야 하는지 여부와 그 방법을 명시함.
preload="metadata" => 식으로 명시함.
- auto: 페이지가 로드 될 때 브라우저가 오디오 파일을 같이 로드함.
- metadata(디폴트, 권장): 페이지가 로드 될 때 브라우저가 메타데이터(metadata)만 로드함.
- none: 페이지가 로드 될 때 브라우저가 오디오 파일을 로드하지 않음. (이 경우에는 영상의 썸네일이 뜨지 않는다.)

*autoplay속성이 preload속성보다 우선순위가 높다. 즉 autoplay속성이 정의되어 있으면 preload속성은 무시된다.





video태그 속성들
(특수케이스 인라인레벨요소, width와 height 조절이 가능함(크기조절을 하게 되면 해당 크기에 영상비율이 맞춰짐))
영상은 autoplay와 muted를 같이 기술하면 자동재생이 된다. 
src: 미디어 파일 경로를 지정함.
type: 미디어 파일의 형식(타입)을 웹 브라우저에서 미리 알려줌. 해당 파일의 재생 가능 여부를 확인 할 수 있다.
- poster속성: "이미지경로"로 썸네일을 지정 할 수 있는 속성




    <video controls autoplay>
        <source src="../img/clouds_-_111179 (540p).mp4" type="video/mp4">
        <source src="../img/145320 (540p).mp4" type="video/mp4">
        이 브라우저는 video를 지원하지 않습니다.
        <!-- 첫번째 영상을 찾을 수 없으면 두번째 영상을 로드함. -->
        <!-- 만약 두번째 영상도 없으면 마지막 텍스트를 출력함.(단, 영상이 지원되는 브라우저에선 텍스트 출력이 불가능) -->
    </video>




        text-shadow: 값1 값2 값3 값4;
        값1: 텍스트부터 그림자까지의 x축 방향(양수-글자 오른쪽 그림자, 음수: 글자 왼쪽 그림자)
        값2: 텍스트부터 그림자까지의 y축 방향(양수-글자 아래쪽 그림자, 음수: 글자 위쪽 그림자)
        값3: blur효과(= 글자 번짐효과, 양수-모든 방향으로 그림자 번짐효과, 음수-모든 방향으로 그림자 축소, 기본값-0)
        값4: 그림자 색상 지정(한가지 색)

        여러 색상값 지정 형식
        text-shadow: 값1 값2 값3 값4, 값1 값2 값3 값4, 값1 값2 값3 값4, ...;



text-indent: => 들여쓰기(수평) 


        text-align: left; => 왼쪽 정렬
        text-align: right; => 오른쪽 정렬
        text-align: center; => 가운데 정렬
        text-align: justify; => 양쪽 정렬




        [말줄임표]

        - width의 값이 지정되어야 함. 
          예시: width:300px;

        - 줄 넘김이 되지 말아야 함. 
          예시: white-space:nowrap;

        - 넘치는 부분에 대해 감춤처리를 해주어야 함. 
          예시: overflow:hidden;

        - 말줄임표시 기호처리를 해야 함. 
          예시: text-overflow:ellipsis;




[letter-spacing: ] => 글자와 글자 사이의 간격을 조절하는 속성

        /* 글자 사이의 자간: letter-spacing */
        {letter-spacing: 0.2em;}
        {letter-spacing: 0.5em;}
        {letter-spacing: -5px;}

        /* 단어자 사이의 자간: word-spacing */
        {word-spacing: 0.2em;}
        {word-spacing: 0.5em;}
        {word-spacing: 50px;}



*********************************************************form태그 정리**************************************************************

form태그의 입력요소들에 입력한 데이터를 전송하기 위한 조건
1. 반드시 입력요소들이 form태그 안에 들어가 있어야 한다.
2. 입력요소 안에 name속성이 존재해야 한다.
3. form태그 안에 submit이 존재해야 한다.

form태그의 시작엔리먼트에 기술 할 수 있는 속성
1. action 속성 : 폼 안에 입력한 데이터를 전송하기 위한 경로를 기술하는 속성
2. metohd 속성 : 데이터를 전송하는 방식을 기술하는 속성
*get방식 : url뒤에 쿼리스트링 방식으로 값을 name과 value의 쌍으로 전송하는 방식
	대용량 전송 불가 (문자길이 제한이 있다.)
	예시: http://www.a.b/index.jsp?id=admin&pw=1234
*post방식 속성 : 데이터를 body안에(header영역) 숨겨서 전송하는 방식
	name과 value의 쌍으로 전송
	데이터 용량 제한 없음
3. target 속성 : 데이터를 전송 받을 페이지를 보여줄 때 창을 구분하는 방식을 기술
*_self : 기본값(default), 현재 창에서 보여주기
*_blank : 새창(새탭)에서 보여주기
4. autocomplete 속성 : 기존에 입력한 데이터의 이력이 존재하면 동일한 name을 가진 속성에 데이터를 입력할때 아래에 도움말 기능처럼 제공해주는 기능
		기본값 : on
5. <label>태그 : 인라인레벨요소의 머리말이나 꼬리말을 담당하는 태그
	선택하는 영역이 작은 인라인레벨요소를 위한 클릭 영역을 넓혀주는 역할도 있다.


<form>
<input name = "test">
기본타입: text가 숨어있다. type = "text"

<input type = "submit">
기본값 : "제출"값이 숨어있다.

<button>버튼</button>
기본타입 : type = "submit"이 숨어있다.

<button type = "submit">버튼</button>

</form>
<button>버튼</button>
기본타입 : type = "button"이 숨어있다.

<input type="text" name = "a">

<input type="password" name = "b">

<input type="email" name = "c"> 
앞에 글자가 존재@뒤에글자하나라도 존재

<input type="url" name = "d">
http://글자하나라도 존재
https://글자하나라도 존재

<input type="tel" name = "e">

<input type="color" name="color" value="#00ff00">

<input type="radio" name = "f">
단일 선택이 가능한 입력요소
그룹으로 지정하고자 할 경우에는 반드시 name속성의 이름을 동일하게 지정해줘야함
radio버튼에서 name속성이 그룹으로 묶어주는 기능의 역할을 한다.
반드시 value속성이 존재해야 한다. 
(value속성을 기재하지 않을 경우 체크한 값은 모두 "on"값으로 전송되므로 어떤 값을 선택했는지 구분 할 수가 없음)
사용자가 선택할 때 어떤 값인지 구분하기 위한 라벨이나 텍스트가 존재해야 한다.
한번 선택하면 해제 불가

<input type="checkbox" name = "g">
다중 선택이 가능한 입력요소
반드시 value속성이 존재해야 한다. 
(value속성을 기재하지 않을 경우 체크한 값은 모두 "on"값으로 전송되므로 어떤 값을 선택했는지 구분 할 수가 없음)
사용자가 선택할 때 어떤 값인지 구분하기 위한 라벨이나 텍스트가 존재해야 한다.
선택해도 해제 가능

<input type="date" id = "start" name="start" min="1950-01-01" max="2002-08-08">
date는 yyyy-mm-dd형식으로 년,월,일이 표시됨.

<input type="time" value="09:00" name="start1">
<input type="time" value="18:00" name="end1">
time은 오전/오후 시간으로 나뉘어 설정 가능. 값은 24시간제로 표시됨.

<input type="datetime-local" min="2000-01-01T00:00" max="2050-12-31T23:59" value="2016-03-02 09:00" name="start2">
datetime yyyy-mm-dd형식 다음에 시간을 의미하는 T(TimeZone)값이 자동으로 붙음. 뒤에 24시간제로 시간 표시됨.

<input type="number" name = "h"> 
정수값을 입력 할 수 있는 타입

<input type="hidden"  name = "i">
브라우저상에서 안보임, 서버로 value값이 전송됨

<button type = "reset"> - 처음상태로 되돌려라, 초기값으로 되돌려라

autofocus속성 - 자동으로 해당 요소가 선택되게 하는 기능, 첫 실행 후 새로고침을 한번 해야 활성화
readonly속성 - 읽기전용
required속성 - 이 붙은 입력요소에는 반드시 값을 입력해야함
placeholder속성 - 도움말 기능, 값을 입력하면 사라짐
disabled속성 - 비활성화 기능. 브라우저상에서 보임. 서버로 값이 전송되지 않음.


size -> 영어 대문자 기준으로 글자가 깨지지않고 칸에 딱 들어가는 크기




            pattern 속성 : 
            pattern 속성은 input 요소에 입력된 값을 검사하기 위한 정규 표현식(regular expression)을 설정 할 수 있다.
            정규 표현식이란 문자열에서 특정한 규칙을 가지는 문자열의 집합을 찾아내기 위한 검색 패턴을 말한다.
            (유효성검사)

            정규 표현식 사용가능 범위 : 
            input요소의 type속성값이 text, password, email, tel, url인 경우 사용가능

            사파리, 익스플로러 9이하 버전은 지원 안됨.
            1. [a-zA-Z0-9] : 영어소문자, 영어대문자, 숫자 중 개수에 상관없이 사용가능.
            2. [@] : '@' 문자만이 나와야 함.
            3. [.] : '.' 문자만이 나와야 함.
            4. [.]* : '.' 문자가 나와도 되고 나오지 않아도 됨.
            5. [a-zA-Z0-9]* : 영어소문자, 영어대문자, 숫자 중 어느 것이라도 개수에 상관없이 나와도 되고 나오지 않아도 됨.
            6. [0-3]{3} : 숫자는 0~3까지 사용가능하며 3자리 숫자까지만 사용가능.
            자바스크립트의 정규표현식에서 따온 것.
            7. [ㄱ-ㅎ] : ㄱ~ㅎ까지의 자음만.
            8. [ㄱ-ㅎ가-힣] ㄱ~ㅎ까지의 자음포함, 가~힣까지의 한글포함.
            [정규표현식] => 해당 정규표현식으로 1개
            [정규표현식]{숫자} => 해당 정규표현식으로 해당 숫자개
            [정규표현식]+ => 해당 정규표현식으로 여러개
            [정규표현식]* => 해당 정규표현식으로 써도되고 안써도되고



fieldset -> 블록레벨요소, 폼태그 안의 입력요소들을 그룹으로 묶을 때 사용

legend -> 특수블럭레벨, 임대영역-100%, 실제영역-컨텐츠크기만큼이라 text-align:으로도 옮길 수 있다.



textarea의 스타일요소 중 resize => 크기 조절 기능을 조정함
<textarea name="content" id="content" cols="30" rows="10"></textarea>
- cols => (영어대문자 기준)입력창의 가로 한줄에 입력 가능한 칸 크기
- rows => (영어대문자 기준)입력창의 세로줄 개수


border-radius => 테두리 라운드 주는 태그


        input type="image" : submit버튼과 동일한 역할
        버튼을 이미지로 설정 가능
        불필요한 마우스의 클릭 지점의 x,y축 좌표값을 같이 붙여 보낸다
        input요소에서 width, height의 독립 속성은 image 유형에서만 가능하다


datalist 엘리먼트는 입력양식 옵션을 미리 정의하여 보여주는 태그입니다.
<form>
    <input list = "browsers" name = "browsers">
    <datalist id = "browsers">
        <option>Internet Explorer</option>
        <option value="Firefox">
        <option value="Chrome">
        <option value="Opera">
        <option value="Safari">
    </datalist>
    <input type="submit">
</form>
참고:
datalist 태그는 Safari 12.1. 전 버전에서는 지원이 되지 않습니다.

*********************************************************form태그 정리**************************************************************





text-align : 
- 인라인레벨요소의 수평 정렬을 시키는 속성 
- 속성값 : left, center, right
***- 수평정렬을 시키고자 하는 인라인레벨 요소를 감싸고 있는 부모태그에 속성을 기술해주어야 한다.***

vertical-align : 
- 인라인레벨요소의 수직 정렬을 시키는 속성
- 속성값 : top, middle, bottom
***- 수직정렬을 시키고자 하는 인라인레벨 요소에 직접 속성을 기술해주어야 한다.


        {vertical-align: baseline;}
        {vertical-align: top;}
        {vertical-align: middle;}
        {vertical-align: bottom;}	//중요

        {vertical-align: sub;}	//잘안씀
        {vertical-align: super;}	//잘안씀



<<HTML meta tag>>

- http-equiv attribute
<meta http-equiv="refresh" content="n(초)">
이 페이지는 n초마다 새로고침 됩니다.

<meta http-equiv="refresh" content="5;https://www.naver.com">
이 페이지는 5초 후에 네이버로 이동됩니다.



- name attribute
<meta>태그의 name요소는 눈에 직접 보이지는 않아도 해당 문서의 다양한 메타데이터를 정의 할 때 사용합니다.

    <!-- 웹 브라우저의 문자셋(인코딩) 정의 -->
    <meta charset="UTF-8">

    <!-- 검색 시 키워드 설정 -->
    <meta name="keyword" content="HTML, meta, tag, element, reference">

    <!-- 웹 페이지에 대한 설명(description)을 정의 -->
    <meta name="description" content="HTML meta tag page">

    <!-- 문서의 저자(author)를 정의 -->
    <meta name="author" content="Himedia">

    <!-- 버전이 낮은 익스플로러 브라우저를 엣지브라우저처럼 인식하여 호환되도록 하는 방법 -->
    <meta http-equiv="X-UA-Compatible" content="ie=edge">



- 반응형 웹페이지의 조건
<meta name="viewport" content="width=device-width, initial-scale=1.0">
보이는 화면이 내가 보는 디바이스에 맞추는 기능
img {max-width: 100;} 까지 해줘야 깔끔



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//52
//필기
//



<<자바스크립트 (JavaScript)>>


키워드 변수명;
키워드 변수명 = 값;

함수형언어는 자료형을 기술 할 필요가 없다.
값에 따라 자료형이 세팅됨

5버전
var => 전역

6버전
let => 일반 지역
const => 상수(지역)

var num = 5; => 숫자형
var num = 0.5; =>숫자형(실수)
var num = "하늘"; => 문자형
var num ='하'; => 문자형


인라인 스크립트 : 시작 엘리먼트에 이벤트핸들러속성으로 기술하는 형식
내부 스크립트 : <script></script>태그 안에 기술하는 형식
외부 스크립트 : <script>에 src속성을 이용하여 외부 .js파일을 끌어서 사용하는 형식

우선순위 : 가장 마지막에 기술된 함수가 우선순위로 처리된다. (덮어쓰기됨)


        //자바스크립트의 한 줄 주석
        /* 자바스크립트의 여러 줄 주석 */
        // alert함수 형식 => [확인]버튼 하나만 가지고 있는 알림창을 띄워주는 함수
        // window객체(자바스크립트의 최상위 객체)에서 제공되는 함수
        // alert("출력하고자하는 메세지 기술");
        // 자바스크립트는 문자열값을 ""(큰따옴표) 또는 ''(작은따옴표)로 묶어서 처리한다.
        // window.alert("Hello, \nJavaScript~");


        // ALERT("Hello, JavaScript~"); //안됨, script는 대소문자 가림
	alert("Hello, \nJavaScript~");
        // document.write(): body안에 (데이터)를 html형식으로 쓰세요.
        // html태그의 객체화 => document.


        자바스크립트의 변수 선언 형식
        키워드(var(전역), let(지역), const(지역상수)) 변수명; //선언
        키워드(var, let, const) 변수명 = 값; //선언 및 초기화
        자료형 제한이 없다.

//함수명(); => 함수호출문, 객체명점이 없으면 window객체의 함수임

//body안에 (데이터)를 html형식으로 쓰세요.



        /* 
        변수 선언 초기화 재할당(재사용), 재선언
        var 변수명;
        let 변수명 = 값;

        var a; //선언
        a = 1; //초기화
        a = '가나다' //재할당
        var a = 5; //재선언

        var => 전역: 재선언, 재할당
        let => 지역: 재할당
        const => 상수: 둘 다 안됨.

        호이스팅(Hoisting) : 
        [var만 가능, 선언보다 사용을 먼저 했을때]
        해당 지역에서 모든 선언부를 가장 최상단으로
        강제로 끌어올리는 방법
        호이스팅이 가능한 경우 : var변수 선언, 선언적함수로 선언하는 경우만 가능
        */

        // var 예약어 사용
        /* 
        undefined는 변수를 선언하고 값을 할당하지 않은 상태,
        null은 변수를 선언하고 빈 값을 항당한 상태(빈 객체)이다.
        즉, undefined는 자료형이 없는 상태이다.

        undefined: 어떠한 값이 할당되었는지 알 수 없다. 할당이 되어 있지 않은 값
        null: 값이 비어있다 라는 의미, 비어있는 값
        '' 또는 "" : 빈 문자열값
        */


        자바스크립트의 함수 형식
        접근제어자 없음, 리턴타입 없음, 이름만, 매개변수도 이름만
        [선언적 함수] 선언 형식
        function 함수명(매개변수명1, 매개변수명2, ...){
            실행문;
            ...
            [return 값;]
        }

        함수 호출 형식
        함수명(매개인자값1, 매개인자값2, ...);
        // 매개인자값은 매개변수의 개수에 맞춰주지 않아도 된다. 알아서 순서대로 주고 못받은 친구는 null을 받음


        // innerText(값자리에 있는 경우);
        // inner는 설정한 타겟이 있어야함
        // 해당 엘리먼트의 자식 요소 중 텍스트를 가져온다.


        // innerText(공간 자리에 있는 경우):
        // => document.getElementsByClassName("pclass")[0].innerText = 555;
        // <p id="demo" name="pname" class="pclass" onclick="pClick()" style="cursor: pointer;">클릭하세요.</p>
        // 해당 엘리먼트의 자식 요소(클릭하세요.)를 싹 다 지우고
        // 해당 값(555)에 텍스트를 넣는다.


        // document.write() => 함수 안에 존재할땐 innerHTML
        // innerHTML : 
        // inner => pClick()이 호출 되면 body내용을 싹 다 지우고
        // HTML => html형식으로
        // => write => 쓰세요


        // 빈 창 열기
        // prompt() => 한 줄 입력창으로 문자열값을 반환한다.
        // 입력을 안하고, 확인 누르면 => 빈문자열 ""
        // 입력을 안하고, 취소 누르면 => null



        // typeof 변수명|데이터 or typeof(변수명|데이터)
        // : 해당 변수나 데이터의 자료형 확인
        // : 자료형을 문자열로 반환함
        // "string", "function"


//스크립트에선 동등연산자(==)로 모든걸 비교함

// function() {} => 익명함수


        // { } => ┌ object자료형 ┐
        /* 
        javascript object자료형 형식
        {키: 값, 키:값, ....}
        => java의 map자료형과 유사
        => json방식이라고도 함.
        JSON (JavaScript Object Notation: 자바스크립트의 오브젝트자료형 표시형식)
        */


        // Number() 생성자 함수
        // 매개변수를 Number자료형을 바꿔줌 
        // 매개변수가 Number자료형으로 바꿀 수 없는 값일 경우는 NaN(Not A Number)반환


        // Boolean() 생성자 함수
        // 매개인자값으로 0, null, undefined, '', "" 값을 넣을 경우는 false 반환
        // 존재하는 값을 넣을 경우는 true 반환



        // Object자료형: java의 HashMap자료형과 유사함. {중괄호}로 묶음
        // java의 Object자료형과는 다른 개념
        // Object.keys(Object객체명)[인덱스] => 해당 Object객체명의 키값들을 모은 후 해당 인덱스번호의 키를 문자열로 가져옴



        // 자바스크립트에서 "", ''로 묶지 않아도 되는 값: 
        // Boolean값, Number값, 객체



        동치연산자 (비교연산자 중에서 같다라는 연산자 종류)
        일반동치연산자 (==) : 자료형은 보지않고 오로지 값으로만 비교
        완전동치연산자 (===) : 자료형까지 완전하게 모두 일치하는 값으로 비교


        // 자바스크립트에서 "!부정자료형" 형식은 숫자 0 또는 "", null, undefined 값을 제외한 모든 것을 true로 인식한다.
        // Boolean() 생성자 함수로 인식
        // Boolean() 생성자 함수는 매개인자값으로 0, null, undefined, '', "" 값을 넣을 경우는 false 반환 존재하는 값을 넣을 경우는 true 반환






--------------------------------------------------------------------------------------------------------------------------------------------------
//
//53
//필기
//


        Date() : 현재 날짜를 문자열 자료형으로 가져오는 생성자 함수
        자신의 시스템의 설정 시간으로 가져옴.
        Date : 현재 날짜의 정보를 가지고 있는 클래스
        형식 : 
        //오늘 날짜 가져옴.
        var d = new Date();

        //설정한 날짜를 가져옴.
        var d = new Date(milliseconds);
        var d = new Date(dateString);
        var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);

        Date(): 현재시간의 정보를 영문표기법 문자열값으로 반환
        new Date(): 현재시간의 정보에 대한 전반적인 데이터를 담고 있는 객체 생성
        Date.now(): 현재시간의 정보를 긴숫자형값으로 반환





조건문 : if~else문, switch~case문
반목문 : for문, while문, do~while문






--------------------------------------------------------------------------------------------------------------------------------------------------
//
//54, 55
//필기
//



        forEach()형식
        - item : 해당 배열객체의 요소값을 가져오는 변수
        - idx : 해당 배열의 인덱스값을 가져오는 변수
        **요소값,인덱스 변수명은 내가 지어주면 됨
        **empty값(아예 기술한 값이 없다.)이 있으면 해당 요소는 출력에서 제외
        
        배열객체명.forEach(function (요소값변수, 인덱스변수) {
            실행문;
            ...
        });



        // 배열의 길이가 자동으로 증가됨.
        var arr = ["JavaScript"];
        var element = arr[0];

        arr[1] = 10; // arr = ["JavaScript", 10]
        arr[2] = element; // arr = ["JavaScript", 10, "JavaScript"]
        
         // delete: 배열 요소(값)만 삭제됨. 공간은 삭제 안됨. // 원본훼손 됨
        delete arr[2]; // arr = ["JavaScript", 10, ]

         // pop(): 배열의 마지막 인덱스 공간이 삭제됨. // 원본훼손 됨
        arr.pop(); // arr = ["JavaScript", 10]
        
        // push()를 통한 요소 추가 // 원본훼손됨
        arr.push("Script"); // arr = ["JavaScript", 10, "Script"]

        // slice(시작인덱스번호, (마지막인덱스번호 - 1)) // 원본훼손 안됨
        arr = arr.slice(0, 2); // 대입해서 원본훼손(slice함수는 원래 원본훼손 안됨), arr ["JavaScript", 10]

        // length를 통한 요소 추가 // 원본훼손 됨
        arr[arr.length] = 100; // arr = ["JavaScript", 10, 100]

        // 특정 인덱스를 지정하여 요소 추가 // 원본훼손 됨
        arr[10] = "자바스크립트"; // arr ["JavaScript", 10, 100, , , , , , , , "자바스크립트"]


        // charAt(인덱스) : 문자열의 한 글자만 추출

        // Array.isArray() : 배열객체 여부 판별



        // 객체 | 변수 | 데이터 instanceof Array : 배열객체 여부 판별
        // 객체는 type이 object이다.




        함수란(function) : 
        하나의 특별한 목적의 작업을 수행하도록 설계된 독립적인 블록을 말함.
        실행하려면 반드시 호출이 가능하다.
        매개변수의 자료형을 기술 할 필요가 없다.
        호이스팅 처리 됨.
        호이스팅: 아래에 선언된 것을 최상단으로 끌어올리는 기능.

        선언적 함수란 : 기본 함수 선언형식은 온전히 지켜서 선언한 함수를 의미
        
        형식: 
        function 함수명() {
            실행문들;
            ...
        }



        // 호이스팅 영역은 반드시 선언문이 같이 이우러진 script태그 안에서만 가능함




        ** 브라우저의 개발자 도구를 꼭 실행하여 확인해 주세요! **
        익명 함수 : 이름이 없는 함수를 익명함수라고 한다.
        익명함수를 호출하려면 해당 함수를 변수에 대입하여
        (함수가 리터럴로 존재)
        해당 변수를 함수 호출문 식으로 ( 함수객체명() ) 호출하면 된다.

        익명함수 형식: 
        function () {
            자바스크립트 코드들;
            ...;
        }




    지역 함수(local function) : 함수 안에 정의된 내장 함수를 의미. 
    - 포함된 함수 안의 블록 사이에서만 쓰일 수 있다. 
    - 포함된 함수의 실행이 종료되면 지역 함수도 소멸된다.
    - 함수 내부에서 선언된 변수명과 변수값은 함수 외부에서는 사용 할 수 없다.
    
    전역 함수(global function) : 여러 코드 블록에서 동시에 쓰일 수 있는 함수를 말한다.
    함수 밖에서 선언된 변수의 경우 함수 내부의 코드 블록에서도 동시에 사용 할 수 있다.




외부스크립트를 사용하는 경우에는 내부스크립트에 기술하는 내용은 인식하지 못한다. (기술X)


        // 자바스크립트의 즉시실행 함수 형식 : 
        // (function (매개변수 기술 ...) {실행코드 기술; ...})(매개변수개수만큼 기술);


        // arguments : 함수를 호출할때 매개인자의 정보를 배열로 저장하는 객체
        // 자바스크립트에서 제공하는 내장 객체



        // 함수의 매개변수를 일치시키지 않아도 arguments객체를 통해 해당 매개변수를 가져올 수 있다.



            // Infinity : 양의 무한대 값을 나타내는 숫자형 값
            // -Infinity : 음의 무한대 값을 나타내는 숫자형 값
            예) let max = -Infinity;


        // 객체명.toString() : 
        // 해당 객체를 string자료형으로 변환하면서 문자열로 출력해주세요.


        // 선언적 함수를 변수로 받는 방법
        str = myFunction;
        // ( ) => 소괄호에는 실행하라는 의미가 있어서 함수명만 쓰는것. 


        // 자바의 람다식과 유사
        // 화살표 함수는 한 줄 실행문인 경우만 return 생략가능, 중괄호({}) 생략가능

        // const x = function(x, y) {return x * y;}; 를 축약한 형식이다.

        예) const x = (x, y) => x * y;
        예) function x(x, y) {return x * y;}


        javascript object = java Map = json방식
        형식 : {키: 값, 키: 값, ....}
        */
        // this키워드 : 함수의 소유자를 의미함.
        // 이 스크립트에서는 this가 person객체가 됨.
        // object객체의 키와 요소값에 접근하는 방법
        // Object.keys(오브젝트객체명) 키명만 가져오기 => 키만 배열형식으로 반환
        // 요소값 가져오기
        // 1. 오브젝트객체명.키명
        // 2. 오브젝트객체명['키명'] => 키명은 반드시 문자열값으로 기술할 것


        /* 
        이벤트 핸들러 함수 란 : 
        웹문서 내에서 어떠한 행위가 일어날 떄 발생되는 기능을 제어하는 함수를 말함.
        - 해당 이벤트가 발생이 될 때 함수를 실행시킨다.
        - onload : 페이지가 로딩될 때
        - onchange : 값이 변경되었을 때
        - onclick : 마우스를 클릭했을 때

        [window].onload = function() {
            실행코드들;
        };
        값이 변경되는 대상 태그나 객체.onchange = function() {
            실행코드들;
        };
        */

        // window.onload = function() {자바스크립트코드들; ...;}
        // 웹 페이지가 로딩되자마자 실행
        // window. << 생략가능




        forEach()형식
        - item : 해당 배열객체의 요소값을 가져오는 변수
        - idx : 해당 배열의 인덱스값을 가져오는 변수
        **요소값,인덱스 변수명은 내가 지어주면 됨
        **empty값(아예 기술한 값이 없다.)이 있으면 해당 요소는 출력에서 제외
        
        배열객체명.forEach(function (요소값변수, 인덱스변수) {
            실행문;
            ...
        });


        // .forEach 앞에는 배열객체만가능.
        // 매개변수로 함수를 넣어야함. function(요소값변수, 인덱스변수)

// 배열객체.shift() => 해당 배열객체의 0번인덱스 삭제, 원본훼손
// 배열객체.pop() => 해당 배열객체의 마지막 인덱스 삭제, 원본훼손
// 배열객체.splic(시작인덱스번호, 해당번호부터 가져올 개수)
// 배열객체.splic(시작인덱스번호, 해당번호부터 가져올 개수)


        // toFixed([소수점자리수]) : 자리수는 0 ~ 100까지만 가능
        // 없는 자리수는 임의 수(0)로 채움
        // 지정한 소수점자리수 뒤로 더 있으면 반올림해서 반환
        // Math.round(), Math.floor(), Math.ceil() : 모두 정수를 반환함.



<<09_math.html>>

        var maxNum = Math.max(10, 5, 8, 30), 
        minNum = Math.min(10, 5, 8, 30), 

        roundNum = Math.round(num), 
        floorNum = Math.floor(num),
        ceilNum = Math.ceil(num),

        piNum = Math.PI,
        
        absNum = Math.abs(-15),
        powNum = Math.pow(5, 3),
        sqrtNum = Math.sqrt(9),

        rndNum = Math.floor(Math.random() * 10); // 0 ~ 9사이
        rndNum = Math.round(Math.random() * 10); // 0 ~ 10사이


        // substr(시작인덱스번호, 시작인덱스번호의 문자열포함하고 이후로 가져올 문자열의 개수)

        // subString(시작인덱스번호, 마지막인덱스번호(지정값 - 1))
        // : 시작인덱스 ~ 마지막인덱스번호까지의 문자열을 추출함.

        // slice(시작인덱스번호)
        // : 시작인덱스 ~ 끝까지의 문자열을 추출함.
        // slice(시작인덱스번호, 마지막인덱스번호(지정값 - 1))
        // : 시작인덱스 ~ 마지막인덱스번호까지의 문자열을 추출함.

--------------------------------------------------------------------------------------
문서 객체 모델(DOM, Document Object Model)
: XML이나 HTML문서에 접근하기 위한 일종의 인터페이스.

- 문서 내의 모든 요소를 정의
- 각각의 요소에 접근하는 방법을 제공함.
- W3C의 표준 객체 모델임
--------------------------------------------------------------------------------------
ㅁ DOM 계층 구조 [이미지 참고]
https://lifeandit.tistory.com/70
--------------------------------------------------------------------------------------
document객체 : 웹 문서 자체를 의미하는 객체임.
- 웹 페이지에 존재하는 HTML요소에 접근하고자 할 때는, document객체부터 시작해야 한다.
(예외: 입력요소 객체 접근시는 form객체부터 접근 가능)

ㅁ HTML문서를 구성하는 대표적인 노드의 종류
1. 문서 노드(document node) : HTML문서 전체를 나타내는 노드.
2. 요소 노드(element node) : 모든 HTML요소.
**속성(style, 등) 노드를 가실 수 있는 유일한 노드이다.
3. 속성 노드(attribute node) : 모든 HTML요소의 속성은 속성 노드이며, 요소 노드에 관한 정보를 가지고 있다.
4. 텍스트 노드(text node) : HTML문서의 모든 텍스트. => #text로 표기됨.
5. 주석 노드(comment node) : HTML문서의 모든 주석은 주석 노드임. => #comment로 표기됨.

ㅁ HTML DOM에서 노드 간 관계를 나타내는 문서 노드 프로퍼티들
(공백이나 줄바꿈 등도 텍스트노드로 인식이 되어 노드로 인식함)

/*
- 빈 텍스트 노드의 처리
현재 대부분의 주요 웹 브라우저는 모두 W3C DOM 모델을 지원하지만, 그 처리 방식에 있어 약간씩의 차이가 있습니다.
그중에서도 가장 큰 차이점은 띄어쓰기와 줄바꿈을 처리하는 방식입니다.
파이어폭스나 기타 브라우저들은 띄어쓰기나 줄바꿈을 텍스트 노드(text node)로 취급합니다.
하지만 익스플로러는 띄어쓰기나 줄바꿈을 텍스트 노드로 취급하지 않습니다.
따라서 자식 노드나 형제 노드를 이용하여 원하는 노드에 접근하려고 하면 브라우저 간에 차이가 발생하게 됩니다.
*/

1. parentNode : 부모 노드
2. childNodes : 자식 노드 리스트
3. firstChild : 첫 번째 자식 노드
4. lastChild : 마지막 자식 노드
5. nextSibling : 다음 형제 노드
6. previousSibling : 이전 형제 노드
--------------------------------------------------------------------------------------

ㅁ HTML DOM에서 노드 간 관계를 나타내는 요소 노드 프로퍼티들
(태그들만 기준으로 확인함.)
1. parentElement : 부모 요소 노드
2. children : 자식 요소 노드 => 자식요소들을 배열로 가져옴
3. firstElementChild : 첫 번째 자식 요소 노드
4. previousElementSibling : 이전 형제 요소 노드
5. nextElementSibling : 다음 형제 요소 노드
--------------------------------------------------------------------------------------




        // window.onload = function () {
        //     // createElement(태그명) : 웹문서 내에 해당 엘리먼트(태그)를 만들어 준다.
        //     // 객체명.setAttribute("속성명", "속성값") : 해당 객체의 속성을 설정해 준다. 속성이 없으면 속성 생성
        //     // appendChild(객체명) : 웹문서 내의 지정 요소안의 맨 마지막에 자식요소로 해당 객체를 추가해 준다.
        //     // 이전의 객체들(텍스트를 포함한 모든 엘리먼트 요소들)은 유지됨.
        //     var pic = document.createElement("img"); //<img>
        //     pic.setAttribute("src", "../img/history.png"); //<img src="../img/history.png">
        //     document.body.getElementsByTagName("p")[0].appendChild(pic);
        //     // 가장 마지막 자식으로 추가 (지우는거 없음)
        //     // <p>Hello DOM<br><br></p> => <p>Hello DOM<br><br><img src="../img/history.png"></p>
        //     // document.body.appendChild(pic)
        // }



                // 객체.insertBefore(1, 2) => 해당 객체의 자식으로 2번 전에 1번을 추가
                // 객체.insertBefore(1, 2) => 해당 객체의 자식으로 1 = 추가할요소, 2 = 기준점요소


                // 태그객체.cloneNode(true) => 해당태그를 복제해라, 꼭 매개변수로 트루 해줘야 함

                // 객체.appendChild(1) => 해당 객체의 가장 막내 자식으로 





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//56
//필기
//





브라우저 객체 모델(BOM, Browser Object Model) : 
자바스크립트를 이용하면 브라우저의 정보에 접근하거나 브라우저의 여러기능들을 제어할 수 있도록 해주는 객체 모델

window 객체 : 웹 브라우저의 창(window)을 나타내는 객체



        // // **알림창 : alert("메세지");
        // alert("알림창입니다,");

        // // 입력창 : prompt(); || prompt("메세지"); || prompt("메세지", 초기값);
        // var pin = prompt("입력창입니다.");
        // document.write("입력창 값: " + pin + "<br>");

        // // **확인창 : confirm("메세지");
        // var con = confirm("확인창입니다.");
        // // if(con) {// 페이지이동코드 작성} else {return false;}
        // document.write("확인창 값: " + con);


        // window에서 제공하는 무한반복 함수 => setInterval(함수명, 밀리세컨드초);


        // toLocaleTimeString() : 현재 시간을 가져오는 함수. 시스템 내장(한국식) 시간을 가져옴


        window.location.href 의 의미 
    
        1. 대입연산자 기준으로 왼쪽에 위치하는 경우
        window.location.href = "url주소값";
        => 해당 url주소로 페이지를 이동하세요.
    
        2. 대입연산자 기준으로 오른쪽에 위치하는 경우
        ~~~ = window.location.href;
        => 현재 페이지의 url주소값을 가져오세요.

        window.history : 브라우저의 방문기록을 쌓아놓는 객체

        querySelector가 여러개를 가져올때는 0번째 인덱스만 반환한다.
        일치하는 요소가 없으면 null을 반환한다.








제이쿼리

jQuery => 예약어
$( )
jQuery( )
괄호안에 객체는 따옴표 없이 객체명만 써줘야함
괄호안에 선택자는 반드시 따옴표안에 써줘야함 

선택자의 우선순위가 없음, 함수의 우선순위(가장 마지막에 기술된 함수) 기준


제이쿼리를 사용하기 위해 선행되어야 하는 작업
1. 제이쿼리 라이브러리를 연결한다. (네트워크 방식 또는 다운로드 방식)
2. **반드시 즉시실행 함수 안이나 자바스크립트의 함수 안에 기술해야 한다.
3. 반드시 $(....) 또는 jQuery(....)로 시작해야 한다.




<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.js" integrity="sha512-6DC1eE3AWg1bgitkoaRM1lhY98PxbMIbhgYCGV107aZlyzzvaWCW1nJW2vDuYQm06hXrW0As6OGKcIaAVWnHJw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>



    <!-- 네트워크방식 풀버전 -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.js" integrity="sha512-6DC1eE3AWg1bgitkoaRM1lhY98PxbMIbhgYCGV107aZlyzzvaWCW1nJW2vDuYQm06hXrW0As6OGKcIaAVWnHJw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->

    <!-- 네트워크방식 -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.4/jquery.js"></script> -->

    <!-- 다운로드방식 -->
    <!-- <script src="./jquery/jquery-3.6.4.js"></script> -->


--------------------------------------------------------------------------------------------------------------------------------------------------
//자습때 52,53,54, 55, 56일차 html필기 옮기기
//
//57
//필기
//

        제이쿼리는 선택자를 사용하기 위해서는 실행 할 수 있는 환경이 미리 조성되어 있어야만 한다.

        즉시실행 방법
        javascript 즉시실행 함수 형식
        window.onload = function () {소스코드들; ...;}; (중괄호 뒤 세미콜론 생략가능.)
        (function(매개변수들...){실행코드들;...;})(매개변수값들...);

        jquery 형식
        $(document).ready(function(){소스코드들; ...;});
        jQuery(document).ready(function(){소스코드들; ...;});
        $(function(){소스코드들;...;});
        jQuery(function(){소스코드들;...;});

        콜백함수 (= 형식: 자바스크립트의 익명함수 형식)
        매개인자로 존재하면서 실행과 반환을 자동으로 해주는 함수

        실행 순서: 자바스크립트식 즉시실행 함수 > 제이쿼리식 즉시실행 함수
        */

        // 제이쿼리식 즉시실행 함수
        // jQuery(document) => document의 제이쿼리식 객체
        // jQuery(document).ready(익명함수) => ready가 익명함수를 실행하라는 의미


        네트워크 전송 방식 (CDN : Content Delivery Network 또는 Code Delivery Network)
         : 온라인에서 제공하는 제이쿼리 라이브러리 파일을 네트워크를 통해 html에 불러오는 방식임
        3.7.1 : 현재 가장 최신 버전임.



        선택자 사용하기
        형식 : 
        $("선택자") : document처럼 내장 객체(만든객체포함) 및 객체들을 제외하고는 선택자(css의 선택자와 동일)를 기술할 경우 따옴표(큰,작은 다 가능)로 묶어준다.
        addClass() : 해당 선택자에 class속성 추가하기.
        removeClass() : 해당 선택자에 class속성값 제거하기.
        hide() : 해당 선택자 엘리먼트 숨기기(none과 동일). 영역까지 제거함.
        show() : 해당 선택자 엘리먼트 보이기. 엘리먼트 고유 속성 그대로 보여짐.



            // 체이닝 기법: 한 객체에 다양한 메서드를 중중이 이어서 사용하는 방법
            
            .css("css속성명", "속성값")
            .css({"css속성명": "속성값", "css속성명": "속성값",...})


 // parent() : 부모 선택자, 해당 요소의 부모 요소만 선택함.

/* 속성값에 !important를 붙이게 되면 css, script 모두 적용하고 맨 마지막에 적용되게 함 */

            // children() : 선택한 요소의 모든 자식 요소들을 선택함.
            // children("매개변수로 들어가는 선택자들") : 
            // 선택한 요소의 모든 자식 요소 중 매개변수에 설정한 태그 요소들만 선택함.

            // prev() : 바로 이전 요소(형) 선택자. 바로 앞 요소(형) 선택자.

            // "선택자 + 다음선택자" => 만약 기술한 다음선택자와 실제 다음선택자의 태그가 다르다면 적용하지 못한다.


            // next() or $("선택자 + 다음 선택자") : 선택한 요소의 바로 다음 요소(동생)를 선택함


            // prevAll() : 바로 이전(앞, 형) 요소들 모두 선택.
            // prevAll("선택자") : 바로 이전(앞, 형) 요소들 중 해당 요소들만 선택.


            // nextAll() : 바로 다음(뒤, 동생) 요소들 모두 선택.
            // nextAll("선택자") : 바로 다음(뒤, 동생) 요소들 중 해당 요소들만 선택.

            // $().siblings() : 해당 객체만 제외하고 모든 형제들 선택.
            // $().siblings("선택자") : 해당 객체만 제외하고 모든 형제들 중 해당 요소들만 선택.


            // $("선택자").prevUntil("형요소명") : 
            // 선택자 요소부터 지정한 형 요소까지 그 사이에 있는 요소들 선택.(나와 기준점태그는 미포함)


            // $("선택자").nextUntil("동생요소명") : 
            // 선택자 요소부터 지정한 동생 요소까지 그 사이에 있는 요소들 선택.(나와 기준점태그는 미포함)


            // $("선택자").closest("선택자")
            // ($)해당 요소의 조상(부모 포함) 요소들 중 가장 가까운 (closest)해당 요소를 선택.


        /* CSS는 순서를 1부터 셈 */
        /* #menu li:nth-of-type(even) {background-color: yellow;} */



            // $("선택자:~~") => 해당 선택자까지는 css선택자이고 :(콜론)부터는 jq선택자이다.


            // $("#menu li:odd") == $("#menu li:nth-of-type(even)")

            // eq(인덱스번호(0부터)) : 인덱스번호에 해당되는 요소 선택


            // lt(인덱스번호(0부터)) : 인덱스번호보다 작은, 이전 요소 모두 선택(자신 제외)

            // gt(인덱스번호(0부터)) : 인덱스번호보다 큰, 이후 요소 모두 선택(자신 제외)


            // attr("속성명", "속성값") : 해당 요소에 해당 속성과 값을 설정한다.
            // attr("속성명") : 해당 요소에 해당 속성의 값을 가져오라는 의미. 값이 정적 속성만 가능 (동적x)

            // val("값") : 해당 요소에 value 속성의 값을 설정한다.
            // val() : 해당 요소에 value 속성의 값을 가져오라는 의미.


            // after("요소") : 해당 요소 뒤에(바로 (다음)동생으로) 추가할 요소(html형식)를 넣는다.

            // before("요소") : 해당 요소 앞에(바로 (전)형으로) 추가할 요소(html형식)를 넣는다.

            // unwrap() : 선택한 요소의 부모 요소를 삭제한다.
            // wrapInner() : 선택한 요소의 자식 요소를 감싼다.



            // text("변경할 내용") : 해당 요소의 컨텐츠(가장 최종적인 인라인요소 = 텍스트포함)를 변경할 내용으로 바꾼다. 
            // => javascript의 공간자리 innerText와 동일

            // text() : 해당 요소의 자식요소중 텍스트만 모두 가져와라 
            // => javascript의 값자리 innerText와 동일

            // :first => 앞서 가져온 태그들 중 처음꺼 하나만
            // $("#divBox1 li:first").text("첫번째 내용"); //공간자리

            // :last => 앞서 가져온 태그들 중 마지막꺼 하나만
            // $("#divBox1 li:last").text("마지막 내용"); //공간자리


            // nth-child(번호n) : 번호 1부터. 번호에 해당되는 요소를 선택함.
            // 인덱스는 맨 처음 요소를 0부터 세지만, 번호는 맨 처음 요소를 1부터 셈.
            // n은 인덱스와 동일하게 0부터 셈.
            // nth-child : 정방향(위 -> 아래)
            // nth-last-child : 역방향(아래 -> 위)


            $("#wrap a[href^=https]").css({"color": "green"}); // ^=값 => 값으로 시작하는
            $("#wrap a[href$=net]").css({"color": "blue"}); // $=값 => 값으로 끝나는
            $("#wrap a[href*=google]").css({"color": "black"}); // *=값 => 값이 포함되는


            // :hidden 탐색선택자 : 엘리먼트의 속성이 display: none인 태그만 인지함.

        <p style="display: none;">내용2-1</p> <!-- 안보이는데 영역도 없음 -->
        <p style="visibility: hidden;">내용2-2</p> <!-- 안보이는데 영역은 있음 -->


            // :contains(문자열) => 문자열 포함여부 확인 선택자
            // :has(요소명) => 해당 요소를 가지고 있는지의 여부 확인 선택자
            // contents() => 자식(후손포함안됨)으로 존재하는 엘리먼트(태그)들
            // not("선택자") => 해당 선택한 요소가 아닌 것
            // end()가 붙은 타겟을 기준으로 하나 전단계의 타겟을 가져옴 




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//58
//필기
//


            // 이벤트핸들러 함수는 이벤트 객체(e)와 이벤트를 발생시킨 요소(this)를 가지고 있다.
            /* 
            이벤트 객체 사용하는 방법
            1. function의 매개인자로 객체를 생성하여 사용하는 방법
            예시 : 
            function(e){
                let t = e.target;
            }

            2. 자바스크립트의 event 내장객체를 사용하는 방법
            예시 : 
            function(){
                let t = event.target;
            }
            */


                // .click(function(e){});
                // e.target과 this는 자바스크립트 객체이므로
                // jquery힘수를 적용하려면 jquery형식으로 변경해주어야 한다.
                // 예: $(e.target), $(this)


            // slice(시작인덱스, 마지막값-1인덱스) : 시작인덱스요소부터 (마지막값-1인덱스)까지의 요소 선택
            // 요소명.only-child : 단 하나인 자식(외동)으로 존재하는 요소를 의미


            $("선택자").find("요소 또는 선택자") : 선택한 요소의 하위(자식, 자손) 요소를 필터링(검색)할 때 사용.
            $("선택자").filter("callback 또는 요소 또는 선택자") : 자기 자신의 레벨에서 형제 요소를 필터링(검색) 할 때 사용


                       .filter(function(i, o){});
                // 단 아이템매개변수는 생략 가능하지만 인덱스 매개변수는 생략불가
                // 첫번째 매개변수 => 인덱스값, 두번째 매개변수 => 아이템(요소)
                // 자바스크립트의 forEach()와 매개변수 순서 반대임



            // clone() : 해당 선택요소 복사
            // remove() : 해당 요소 제거 (자식, 자손까지 모두 다)
            // empty() : 해당 요소의 하위 요소를 모두 제거
            // append(요소) : 해당요소를 기준요소의 막내자식으로 추가

        $("선택한 요소").replaceWith("새요소") : 선택한 요소를 새요소로 변경함.
        $("새요소").replaceAll("선택한 요소") : 선택한 요소를 새요소로 변경함.




        attr() : HTML의 속성(attribute)을 핸들링 함. 정적인 속성을 제어.
        attr("속성명") : HTML Element에 있는 속성 정보를 string으로 가져온다.
        attr("속성명", "속성값") : 해당 요소의 속성 정보를 속성값으로 설정(변경)한다.
        removeAttr("속성명") : 해당 요소의 속성을 제거한다.


        prop() : JavaScript의 프로퍼치(property)를 핸들링 함. 동적인 속성을 제어.
        prop("속성명") : 프로퍼티는 JavaScript에서 사용하는 속성 정보를 가져오므로 HTML의 정보와 일치하기도 하고 일치하지 않을 수 있다.
        prop("속성명", "속성값") : 해당 요소의 속성 정보를 속성값으로 설정(변경)한다.

        // prop("checked") : 체크된 상태인지 여부를 true, false로 반환



            map 방식, json(=JavaScript Object Notation) 방식 :
            - 자바스크립트의 오브젝트를 표기하기 위한 표기법으로 {}(중괄호)안에 
            key : value 형식으로 나열하는 방법이다.
            자바스크립트의 오브젝트를 표현하는 표기법이다.
            형식: {key: value, key: value, ...} => 자요형-object, 표기방법-json



            /*   정적이벤트와 동적이벤트
            정적이벤트 : 이미 존재하는 엘리먼트에 이벤트를 등록하는 박식
            동적이벤트 : 스크립트를 통해 생성된 엘리먼트에 이벤트를 등록하는 방식
            (이벤트 상속 포함)
            */
            // click() : 클릭이벤트를 처리하고자 할 때. (정적이벤트)


            /*   동적이벤트(라이브 이벤트) 등록방식
            $(지정자의 부모이상급요소).on(이벤트속성, 이벤트를 발생시킬 타겟(선택자=지정자), 콜백함수) : on함수를 이용.
            선택자를 해당 이벤트가 발생 될 지정자보다 선택자를 상위 요소(부모,조상)로 해야 한다.



        제이쿼리객체.html() :   => 자바스크립트의 innerHTML(값자리)
        제이쿼리객체의 자식 요소들(태그, 텍스트포함)을 html형식으로 가져오세요.
        제이쿼리객체.html("소스코드") :   => 자바스크립트의 innerHTML(공간자리)
        제이쿼리객체의 자식요소를 모두 지우고 그 안의 자식으로 넣는데, html형식으로 넣으세요.

        제이쿼리객체.text() :   => 자바스크립트의 innerText(값지리)
        제이쿼리객체의 자식 요소들 중 텍스트만 가져오세요.
        제이쿼리객체.text("문자열값") :   => 자바스크립트의 innerText(공간지리)
        제이쿼리객체의 자식요소를 모두 지우고 그 안의 자식으로 넣는데, 문자열로 넣으세요.



            // keyup() : 키보드 버튼을 눌렀다떼자마자 이벤트 실행



            콜백함수 형식 = 익명함수 형식
            function([매개변수...]){실행문; ...}

            on함수 호출 형식
            1. 한 개의 이벤트만 적용 : on("이벤트속성자", 콜백함수);
            2. 여러 개의 이벤트를 적용 : 
            on({
                "이벤트속성자1": 콜백함수1,
                "이벤트속성자2": 콜백함수2, 
                ...
            });
            3. 여러 개의 이벤트에 한 개의 기능을 적용
            on("이벤트속성자1 이벤트속성자2 ...", 콜백함수);



            /* hover함수 형식 : 
            $("선택자나 해당 요소").hover(
                마우스포인터가 들어와 있는 상태의 콜백함수
                [, 마우스포인터가 영역을 벗어난 경우의 콜백함수]
            );
             */


예시)
            $("h1").on({
                // 마우스를 눌렀을떄
                "mousedown": function(){
                    $(this).css("color", "red");
                }
                // 마우스를 눌렀을떄
                ,"mouseup": function(){
                    $(this).css("color", "black");
                }
            });
    
            $("h2").on({
                // 마우스 포인터가 선택 영역에 들어갔을 경우
                "mouseover": function(){
                    $(this).css("color", "hotpink");
                } 
                // 마우스 포인터가 선택 영역에서 나갔을 경우
                ,"mouseleave": function(){
                    $(this).css("color", "black");
                }
            });

                // preventDefualt() : 이벤트를 발생시킨 객체의 기본 이벤트를 차단



            // $("선택자 또는 해당 요소").append("요소");
            // : 선택된 요소의 맨 막내자식으로 추가 하는데 html형식으로 추가하세요.



            // each()함수 형식
            // $.each(배열객체명, 콜백함수);
            // $(배열객체명).each(콜백함수);
            // each()함수 안의 콜백함수 형식
            // function(idx[, obj]){
            //     실행문;
            //     ...
            // }





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//59
//필기
//

            $("부모선택자 또는 부모요소").append("추가할 막내자식 요소");
            $("추가할 막내자식 요소").appendTo("부모선택자 또는 부모요소");

           // appendTo() : 선택된 요소를 해당 요소의 마지막에 추가한다.


            // $("부모선택자 또는 부모 요소").prepend("추가할 자식요소")
            // : 선택된 부모 요소의 첫번째 자식으로 html형식으로 추가한다.


            // $("추가할 자식요소").prependTo("부모선택자 또는 부모 요소")
            // : 선택된 부모 요소의 첫번째 자식으로 html형식으로 추가한다.


            // 그룹선택자의 엘리먼트들이 html요소의 인덱스에 맞춰 오름차순으로 정렬됨.
            var $searchEles = $("p, span, div.simpletext1");



            // reverse() : 배열의 순서를 역순으로 가져오기, 원본훼손




            // join("구분 문자열") 함수 : 배열 요소값을 "구분 문자열"로 연력하여 문자열 값으로 반환.
            // 인수값이 있을 경우 기본적으로 "구분 문자열"로 추가됨.
            // 연결값이 없을 경우(예: 마지막 연결 값) "구분 문자열" 적용되지 않음.
            // result => [span, p, div, body, html]
            // result.join(", ") => span, p, div, body, html    마지막값 다음엔 "구분 문자열" 적용 안됨


            형식 : $.map(배열객체, 콜백함수);	jQuery.map(배열객체, 콜백함수);
            - 해당 배열객체에서 값을 받아 콜백함수를 통해 반환받은 값으로 새로운 배열을 만든다.
            콜백함수(callback) : 매개변수로 함수를 전달하는 것을 말하며, 전달받은 함수를 함수의 내부에서 실행시킨다.




            // 형식 : $.grep(배열객체, function(요소, 인덱스){return Boolean값;});
            // $.grep() 함수는 배열 요소를 조건에 따라 필터링하여 제거한다.
            // 이 조건은 함수로 구성되고 배열의 요소와 인덱스를 인자로 갖는다.
            // 즉, 특정 로직에 의해 true가 되는 결과들만 반환됨.


            // inArray(value, array)
            // : 배열에 해당 값이 있으면 해당 요소의 인덱스 반환, 없으면 -1 반환

            // isArray(array) : 배열 객체인지 아닌지의 여부 판단. boolean으로 값 반환


            merge(배열객체1, 배열객체2) : 
            배열객체1에 배열객체2 요소를 모두 붙여서 배열객체1을 새로운 배열로 반환함.
            중복값 제거 안됨.
            순서는 배열객체1이 먼저 이후 배열객체2가 나중으로 정렬됨.


            // $("요소선택자").index(선택요소)
            // : 요소선택자들 중에서 선택요소의 인덱스 번호를 반환함. (0부터)


            is("탐색선택자") : 선택자의 상태에 따라 boolean값을 반환함
            탐색선택자로 올 수 있는 값
            :checked - 체크된 상태인지
            :selected - 선택된 상태인지

            :visible - 보이는 요소인지
            :hidden - 숨겨진 요소인지

            :visible, :hidden 탐색자 - (display: none;) 속성만 감춰진 속성으로 인지함



            // on("이벤트속성자", 콜백함수) 정적함수
            $("#rel_site").on("change", function(){
                $(".txt").text($(this).val());
            });


            // 자바스크립트식
            // document.getElementById("rel_site").onchange = function(e){
            //     document.getElementsByClassName("txt")[0].innerText = e.target.value;
            // };


onchange : 해당 값이 변경된 후 blur상태(포커스 아웃)일 때 값 변경이 인지된다.


            // bind() : on()함수와 유사한 기능을 처리. 2개 이상의 이벤트를 연결할 때 사용함.
            // $("#button1").bind({
            //     "click": button1_clicked ,
            //     "mousedown": button1_down , 
            //     "mouseup": button1_up
            // });


//hasClass("클래스명") => 해당클래스명이 있으면 true, 없으면 false



                /* 속성명:
                객체로 사용시 -(대시)제거 카멜기법으로 표기.
                css속성명 그대로 사용하는 경우는 따옴표로 묶어줌.


                // "mousewheel" 또는 "wheel"로 가능. 현재 "wheel"로 사용하라 권장
                // event.originalEvent.wheelDelta : 마우스의 위, 아래 스크롤 값을 가져온다.
                // 음수인 경우 : 마우스 스크롤 내림
                // 양수인 경우 : 마우스 스크롤 올림
                // **브라우저 종류에 따라 휠을 올릴때 스크롤이 올라가는 값의 범위가 다를 수 있다.


                // event.which : 마우스 클릭 위치의 값을 가져온다.
                // 1: 마우스 좌클릭, 2: 휠클릭, 3: 마우스 우클릭




            // fadeIn([duration][, easing][, complete])
            // - 선택한 요소를 서서히 나타나게 하는 기능
            // duration(시간) : fast(대락: 200) | slow(대략: 600) | 숫자값 입력(1/1000초)
            // 입력값이 없을 경우 기본값 400으로 설정됨.

            // easing(모양-시간당 속도 함수값) : "swing"(기본값) | "linear"
            // swing : 시작과 끝은 느리게, 중간은 빠른 속도로
            // linear : 일정한 속도로

            // complete : 실행할 함수 (지정한 duration의 시간이 끝나면 실행)

            // fadeIn => 안보이는 요소만 가능(display: none;)
            // fadeOut => 보이는 요소만 가능
            // fadeToggle => 안보이는 요소는(display: none;) fadeIn, 보이는 요소는 fadeOut


            // animate({스타일속성}, 적용시간 | 가속도 | 콜백함수) : 다양한 동적효과를 적용 할 수 있다.
            // 스타일속성명은 -를 제외하고, 카멜기법으로 표기.


            opacity: 0; /* opacity(투명도): 0=투명, 1=불투명 */
            transition: all 1s; /* all => 모든 애니메이션, 1s => 모든 애니메이션을 1초실행 */
            /* 해당 요소에 애니메이션이 적용된다면 해당 애니메이션을 제어하는 속성 */


            const loop = true; // 애니메이션 반복여부를 설정합니다, (true로 설정 할 경우, 요소가 화면에서 사라질 때 다시 숨겨집니다.)


                    // 요소의 위치 정보를 가져옵니다.
                    const rect = $el[0].getBoundingClientRect(); /* getBoundingClientRect() => 자바스크립트함수, 해당 객체의 위치정보를 가지고 있는 함수 */


                // checkLength(name, "사용자이름", 3, 16);

                // checkRegexp(name, /^[0-9A-Z\s가-힣]+$/g, "이름은 영문자, 한글만 가능합니다.");


                // valid = valid && checkRegexp(name, /^[0-9A-Z\s가-힣]+$/g, "이름은 영소문자, 숫자만 가능합니다.");
                // i: 대소문자 구분안하고 처리, g: 대소문자 엄격히 구분. 완전일치


     ex07_02.html
 // 정규식 참고 사이트 : 
 // 정규식 참고 사이트 : 








--------------------------------------------------------------------------------------------------------------------------------------------------
//
//60
//필기
//


js => 단일 객체로 가져옴. this: 내 객체 하나만
jq=> $(this) => 하나라도 배열 객첼고 가져옴.



스타일시트와 스크립트 기술 권장 순서
- 스타일 : 인라인, 내부, 외부
- 스크립트 : 인라인, 내부, 외부

1. 외부 라이브러리 스타일시트
2. 외부 내가 만든 스타일시트
3. 외부 라이브러리 스크립트(제이쿼리 라이브러리)
3-1. 외부 라이브러리 스크립트(제이쿼리UI 라이브러리)
4. 외부 내가 만든 스크립트
5. 내부 내가 만든 스타일시트
6. 내부 내가 만든 스크립트
7. 인라인 스타일시트, 인라인 스크립트는 원하는 곳에 지정




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//61
//필기
//



<<부트스트랩>>
4.6버전
링크복사
주로 클래스로 되어있음 .클래스명 으로 변경사항 가져올 수 있다는 것 



<!-- 컨테이너는 내용물을 채워 넣는 데 사용되며 두 가지 컨테이너 클래스를 사용할 수 있다.
    .container 클래스 : 고정 너비 컨테이너를 제공한다.
    .container-fluid 클래스 : 뷰포트의 전체 너비를 제공한다.


.container사이즈(기준-브라우저의 width) : 
(브라우저가 576px 미만이면) xs : 100%, 
(브라우저가 576px 이상, 768px 미만이면) sm : 540px, 
(브라우저가 768px 이상, 992px 미만이면) md : 720px, 
(브라우저가 992px 이상, 1200px 미만이면) lg : 960px, 
(브라우저가 1200px 이상이면) xl : 1140px




            <!-- data-속성명="속성값" : 속성을 만드는 방법, .attr("date-속성명"), .getAttribute("date-속성명")으로 사용할수 있음 -->


        <!-- form태그에 novalidate키워드가 있으면 form태그의 입력요소에 required가 있어도 무시하고 submit해줌 -->
        <!-- form태그에 novalidate를 쓰는 이유는 입력요소에 required의 디폴트 알림창을 방지하기 위함 -->


                부트스트랩에서
                form태그에 was-validated클래스가 있을때 
                valid-feedback클래스가 있는 요소는 show()
                invalid-feedback클래스가 있는 요소는 hide()


                // Array.prototype.filter.call(매개변수, 콜백함수) : 
                // 콜함수(call())를 쓰는데 매개변수를 Array객체로 바꾸고(prototype) 필터링(filter) 하는 식


                    // checkValidity() : 폼태그안에 required, (min, max, url, email,)등 유효성 속성이 있니?
                    // form태그 안에 유효성체크 값이 잘 처리되면 true, 안됐으면 false


                    // 캡쳐링-true(자식에서 조상까지 이벤트 전파), 버블링-false-(디폴트)(조상에서 자식까지 이벤트 전파)



        offset : number => 스크롤 위치를 계산할 때 상단에 추가할 픽셀.(디폴트 10px, 딱 붙었을때를 원하면 0으로 설정해야함)
        activate : 스크롤 추적이 새 항목을 선택할 때 발동한다.



    <!-- 아이콘 참고 사이트 : https://www.w3schools.com/icons/icons_reference.asp -->
    <!-- i태그로 아이콘이미지를 사용 할 수 있음. -->
    <!-- i태그는 인라인레벨의 글자요소이기 때문에 아이콘이미지의 색상을 바꾸려면 color를 사용해야함 -->

        <!-- data-toggle="modal" => 안보이는건 보이게 하고, 드롭다운의 토글이랑은 다르게 뒷배경을 누르면 꺼지는 기능이 있음 -->
        <!-- data-dismiss="modal" => 모달창을 닫아라 -->



        flex-basis : 지정하지 않을때 = 컨텐츠 크기

        flex-grow : 0 [기본값]
        : 아이템을 어떻게 채울지의 여부, flex-grow: 1; => 아이템들을 남는 공간 없이 채워서 배치

        flex-shrink : 1 [기본값]
        : 너비에 관한 것. 아이템들이 갖고 있던 크기가 줄어들 수 있는가에 대한 속성
        : 공간이 줄어들때 여백이 사라짐 => 각 아이템들의 크기가 조율됨
        : flex-shrink: 0; 일때 => 정해진 크기 고수 => 영역 밖으로 벗어나 잘리는 아이템이 생김
        : flex-shrink: 1; 일때 [기본값] => 박스가 작아지면 아이템 기본 크기가 줄어듬
        : 2이상의 값일 땐 크기를 줄이는 빠르기로 인식




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//62
//필기
//





=======================================================================================
버전정보
---------------------------------------------------------------------------------------------------------------------------------------
Servlet Spec	JSP Spec		EL Spec		WebSocket Spec		Authentication (JASPIC)Spec	
---------------------------------------------------------------------------------------------------------------------------------------
4.0		2.3		3.0		1.1			1.1
---------------------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------------------
Apache Tomcat Version	Latest Released Version	Supported Java Versions
---------------------------------------------------------------------------------------------------------------------------------------
9.0.x			9.0.86			8 and later
---------------------------------------------------------------------------------------------------------------------------------------
=======================================================================================


jsp 톰캣 설치, 경로설정, 환경패스설정, startup실행



JSP(Java Server Page)
HTML코드에 JAVA코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구(기술)를 말한다. html언어 만으로는 database를 연결하거나 끌어오는 방법도 어렵고, 동적인 기능을 구현하는 것도 한계가 있어 이 부분을 보완하여 나온 기술이 jsp기술이다. jsp는 apache tomcat과 같은 웹어플리케이션서버(was - Web Application Server)에서 제공하는 기술이다.



jsp에서 제공되는 대표 기본 태그 종류 (jsp태그안에 jsp태그 못씀)

1. 선언태그(=선언부, declaration) : 전역변수 선언, 전역메소드 선언, 등을 기술할 때 사용하는 태그
형식 : <%! %> (클래스안쪽 이라 생각, 멤버필드)

2. 지시태그(=지시부, direction) : jsp페이지의 언어 설정, 인코딩 설정, 에러페이지 설정, 라이브러리 추가, 다른 페이지 연결, 등 전반적인 페이지에 대한 속성을 지시할 때 사용하는 태그
형식 : <%@ %>

3. 실행태그(=실행부, scriptlet) : jsp페이지 내의 전반적인 실행코드를 기술, 반복문, 조건문, 출력문, 지역변수 선언, 등등
형식 : <%  %> (메소드안쪽 이라 생각, 지역)

4. 표현태그(=표현부, expression) : out.print() 또는 out.println() 메소드를 태그로 표현한 것. 세미콜론을 절대 쓰지 않는다. 출력할 값만을 넣을 수 있다.
형식 : <%=값%>

5. 주석태그(=comment) : jsp태그를 무료화 시키거나 코드에 영향을 끼치지 않는 도움말 등을 기술할 때 사용하는 태그
형식 : <%-- 주석처리 내용 --%>

6. 동적태그(=action tab) : 자바빈(javaBean)사용 및 연결 동작과 관련된 기능을 기술할 때 사용하는 태그
형식 : <jsp:액션명 /> 또는 <jsp:액션명 필요한코드 기술></jsp:액션명>





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//63
//필기
//



액션태그 : jsp의 스크립트태그가 아닌 자신만의 태그를 이용하여 jsp내에서 어떠한 동작을 하도록 지시하는 태그

형식 : <jsp:액션태그명 속성명="속성값" 속성명="속성값" ... />
형식 : <jsp:액션태그명 속성명="속성값" 속성명="속성값" ... >필요한 컨텐츠</jsp:액션태그명>

<forward와 include차이>

jsp:forward (페이지 이동 방식 방법)
 : jsp페이지는 buffer사이즈를 설정하지 않으면 기본으로 8kb를 가진다. 출력 내용이 8kb가 넘게 되면 버퍼를 비우고(화면으로 출력) 하는데, forward는 버퍼에 쌓인 내용을 기본적으로 모두 제거하므로, 출력되는 내용이 없게 된다. 따라서 이동하는 페이지의 내용만 표시가 된다.

jsp:include
 : 해당 파일을 모두 처리하여 반환된 결과물(html로 컴파일 된 것)만 받아옴. 따라서 include에 선언된 메소드, 변수, 등을 사용할 수 없다.

@include
 : include된 파일의 소스코드를 그래도 해당 페이지로 포함시키는것. 따라서 include에 선언된 메소드, 변수, 등을 사용할 수 있다. include된 순서에 따라 사용 가능여부가 달라질 수 있다.


<<데이터 전송 방식 : >>
=> url이동 됨.
- get방식: url뒤에 쿼리스트링(QueryString)방식으로 데이터를 전송하는 방식
**쿼리스트링: url뒤에 ?키(name)=value&키(name)=value 형식으로 데이터를 전송하는 방법, 데이터 용량이 제한적이다.

- post방식: 데이터를 body(header부분)부분에 키(name)=값(value)의 쌍으로 데이터를 전송하는 방법, 데이터 용량이 무제한이다.

<<페이지 이동 방식 : >>
- 포워딩(forwarding):
현재의 url을 변경하지 않고 전송해야 하는 데이터를 담아서 보낼 수 있는 방식

- 리다이렉팅(redirecrting):
현재의 url이 이동하는 페이지의 url로 변경됨.
데이터를 전송할 수 없다.
데이터를 전송하기 위해서는 쿼리스트링 방식이나 다른 방법으로 전송을 해야만 한다.




자바빈즈(DTO, VO = 자바의 데이터 전송객체와 동일)
 : 데이터를 저장하여 요청하는 곳에 데이터를 전송하는 역할을 하는 데이터 구조체 클래스
- html의 form요소의 name속성, 데이터베이스 테이블의 컬럼명과 일치시켜주는 것이 좋다.

자바빈즈 작성 규칙
- 기본 생성자가 있어야 함
- 모든 멤버 변수의 접근제어자는 private
- 모든 멤버 변수에 접근 가능한 public getterr, setter메소드가 존재해야 함.

jsp:useBean 액션태그
자바빈즈나 빈 객체 또는 자바 내장 패키지를 사용하기 위한 태그
형식 : <jsp:useBean id="객체명" class="경로포함.클래스명" scope="영역" />
예시 : <jsp:useBean id="person" class="com.test.Person" />
위의 예시를 자바 코드로 변경하면ㄱ
------------.java파일(클래스)------------
package com.test;
class Person{ }
------------.jsp(파일)------------
<%@ page import="com.test.Person" %>
<% Person person = new Person(); %>
또는
<% com.test.Person person = new com.test.Person(); %>
----------------------------------

id : 객체명이라고 생각하면 된다.
class : 경로포함.클래스명 까지 기술, 경로의 시작은 대부분 src아래의 pakage명부터 기술.
scope : 범위, 영역을 의미함. 기본값은 page임.

---scope속성의 범위 값 (객체의 생명주기) : 
- page : 해당 페이지가 클라이언트에게 서비스를 제공하는 동한 유효. 
(생략값 - 디폴트값)
- request : 클라이언트의 요청이 처리되는 동안 유효. 
(요청을 주는 곳에서 요청을 처리하고 응답을 완료하기 전까지 살아있는 객체.)
- session : 세션이 유지되는 동안 유효. 
(해당 도메인에 연결이 된 순간부터 해당 도메인을 열어 놓은 전체 브라우저 창이 닫길 동안까지 유효한 객체. 단, 세션객체를 강제로 삭제하는 경우는 제외)(연결된 세션을 강제로 끌때까지 살아있는 객체. )
- application : 웹 어플리케이션이 실행되고 있는 동안 유효.
(웹 서버가 꺼지기 전까지 유효)


jsp에서 제공하는 내장객체에는 null값이 없음 (request에는 기본적으로 session아이디, 해당url, 등등)

전송받은 데이터를 꺼내려면 전송받은 데이터를 담은 객체에서 꺼내야함

**파라미터로 전송하는 데이터는 request객체에 담김



<<파일을 생성 또는 추가하는 우선 순위>>
1. lib 파일들 (.jar) : src/main/webapp/WEB-INF/lib 폴더 한에 추가
2. class 파일들 (.java) : src/main/java => 패키지 필요한 경우는 해당 패키지까지 추가
3. html, jsp, css, js 파일들
4. web.xml에 필요한 코드들 추가



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//64
//필기
//


예시: http://localhost:8090/jspfirst/08_05_03_request03.jsp?id=admin

URI(Uniform Resources identifier) : 통합자원식별자
=> http://localhost:8090/jspfirst/08_05_03_request03.jsp?id=admin

URL(Uniform Resources Locator) : 통합자원의 위치자
=> http://localhost:8090/jspfirst/08_05_03_request03.jsp (=URI)

URN(Uniform Resources Name) : 통합자원의 이름
=> /jspfirst/08_05_03_request03.jsp (=URI)

context : 웹서버로 요청한 데이터의 애플리케이션명(=프로젝트명)(프로젝트단위)
=> /jspfirst

path : 경로
=> /jspfirst/08_05_03_request03.jsp

Query String : path 경로에 문자열형식으로 이름과 값의 쌍으로 데이터를 전송하는 방식 또는 부분(=파라미터들이 된다.)
=> ?id=admin

Protocol : http

Host이름 : localhost

Port : 8090





<<response 객체란>>
request가 요청 정보를 담고 있는 객체라면 response객체는 응답 정보를 담고 있는 객체이다.

- 헤더 정보 입력 기능 : 헤더값을 추가 하거나 설정하는 기능(대부분 캐시 제어)
- 리다이렉트 기능 : 페이지 이동 기능

*forward 와 redirect의 차이
: forward는 URL변경은 그대로 유지되며, 내용만 이동한 페이지의 내용대로 출력된다.
또한 param액션태그를 이용하여 파라미터 전송을 할 수 있다.

: redirect는 URL변경이 되며, 이동하는 페이지로 바로 이동된다.
파라미터 전송이 되지 않는다. 말 그대로 페이지를 이동 하는 기능만 수행한다.
따라서 파라미터를 전송하려면 쿼리스트링 방식으로만 가능하다.


실행부(스크립트릿)에 기술.
형식 : response.sendRedirect("이동할 페이지 주소 문자열 값");





<<application 기본 객체>>
: 웹 어플리케이션 전반에 걸쳐 사용되는 정보를 담고 있다.
jsp:useBean이라는 액션태그에 scope는 어플리케이션으로 설정되어 있으면 해당 객체의 생명주기는 웹서버가 꺼지기 전까지 라는 의미.

- 초기설정 정보 읽기
- 서버 정보 읽기
- 웹 어플리케이션이 제공하는 자원(파일)을 읽어올 수 있다.

서블릿에 대한 규약 설정은 xml설정파일에서 한다.
web.xml파일
- 웹 어플리케이션을 위한 설정 정보를 담고 있는 파일임.
- WEB-INF폴더에 위치해야 한다.(다른 폴더에 있는 경우 인식하지 못함)
- 웹서버가 실행되면 가장 먼저 읽어들이는 경로가 web.xml파일이다.



web.xml파일은 웹서버가 구동이 되면 가장먼저 확인되는 파일

요청, 응답 사이에 설정이 서블릿





jsp scope에 관련된 내장객체 : 

page : 한 페이지 내의 전반적인 정보를 읽어오거나 설정할 수 있는 객체
request : 요청을 주는 곳에서 요청을 받는 곳 사이에 살아있으면서 파라미터들이나 전반적인 요청 정보를 읽어오거나 설정할 수 있는 객체
session : 브라우저가 꺼질 때까지 살아있으면서 자원을 설정하거나 읽어 들일 수 있는 객체
application : 웹서버가 구동이 되는 순간(어플리캐이션이 실행되는 순간) 생성되면서 웹서버가 종료되는 순간(어플리케이션이 종료되는 순간)까지 살아있는 객체면서 어플리케이션의 전반적인 정보를 읽어오거나 설정할 수 있는 객체



위 4개의 객체가 공통적으로 가지고 있는 부분은 Attribute임
속성 설정하는 방법
해당내장객체명.setAttrubute("name명 문자열로", 값자리);
값은 모든 자료형 가능

속성 가져오는 방법
해당내장객체명.setAttrubute("name명 문자열로");
=> 단, 데이터를 Object로 포장하여 가져온다.
=> 해당 데이터를 변수로 받기 위해서는 해당 데이터의 원래 자료형으로 다운캐스팅 해서 받아야 한다.
=> 값이 없는 경우 null값을 반환한다.




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//65
//필기
//



jsp 에러페이지의 우선순위와 에러페이지 지정 형태

에러페이지를 여러 방법으로 지정할 경우의 우선순위
1. page내의 try~catch문으로 지정한 설정
2. page디렉티브의 errorPage속성에 지정한 에러페이지
(에러의 세부 내용을 살펴보길 원한다면 에러페이지로 지정된 곳에 isErrorPage속성을 설정 해주어야 한다.)
3. web.xml파일의 error-page설정 중 exception-type설정으로 지정한 페이지
4. web.xml파일의 error-page설정 중 error-code설정으로 지정한 페이지
5. 설정한 에러페이지가 없으면 브라우저의 기본 에러페이지


에러페이지 작성 시 요령
1. 404, 500등의 에러는 web.xml파일에 설정
2. 전용 에러페이지가 필요한 경우 page디렉티브로 설정
3. exception타입에 대한 (NullPointException, 등) 설정은 try문, exception객체, web.xml파일, 등으로 설정




web.xml파일에 작성 하는 방법

  <error-page>
  	<exception-type>패키지경로포함.익셉션클래스명까지기술(공백절대안됨)</exception-type>
  	<location>(contextpath가있어요라는의미의슬래시=>)/error/에러파일명</location>
  </error-page>
  <error-page>
  	<error-code>코드숫자값</error-code>
  	<location>(contextpage가있어요라는의미의슬래시=>)/error/에러파일명</location>
  </error-page>

  코드 조각 자동 포함 기능 설정
  jsp-property-group : jsp의 프로퍼티를 포함
  url-pattern : 프로퍼티를 적용할 jsp파일의 url패턴을 지정
  include-prelude : url-pattern태그에 지정한 경로안의 모든 jsp파일의 맨 처음 부분에 해당 파일을 삽입함.
  include-coda : url-pattern태그에 지정한 경로안의 모든 jsp파일의 맨 마지막 부분에 해당 파일을 삽입함.





<<파일을 전송하기 위한 조건>>
0. **가장 먼저 파일을 업로드하기 위한 라이브러리를 추가해야 한다.
1. input 태그의 type="file"인 속성을 사용해야한다.
2. form태그에 반드시 method속성의 값이 post여야만 한다.
3. form태그에 반드시 enctype="multipart/form-data" 속성을 기술해주어야 한다.




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//66
//필기
//





<<데이터 전송 방식 : >>
=> url이동 됨.
- get방식: url뒤에 쿼리스트링(QueryString)방식으로 데이터를 전송하는 방식
**쿼리스트링: url뒤에 ?키(name)=value&키(name)=value 형식으로 데이터를 전송하는 방법, 데이터 용량이 제한적이다.

- post방식: 데이터를 body(header부분)부분에 키(name)=값(value)의 쌍으로 데이터를 전송하는 방법, 데이터 용량이 무제한이다.



<<페이지 이동 방식 : >>
- 포워딩(forwarding):
현재의 url을 변경하지 않고 전송해야 하는 데이터를 담아서 보낼 수 있는 방식

- 리다이렉팅(redirecrting):
현재의 url이 이동하는 페이지의 url로 변경됨.
데이터를 전송할 수 없다.
데이터를 전송하기 위해서는 쿼리스트링 방식이나 다른 방법으로 전송을 해야만 한다.



<<파일을 전송하기 위한 조건>>
0. **가장 먼저 파일을 업로드하기 위한 라이브러리를 추가해야 한다.
1. input 태그의 type="file"인 속성을 사용해야한다.
2. form태그에 반드시 method속성의 값이 post여야만 한다.
3. form태그에 반드시 enctype="multipart/form-data" 속성을 기술해주어야 한다.




<<jsp scope에 관련된 내장객체>>
//모든 객체는 공통적으로 Attribute를 가지고 있음

1. pageContext : 한 페이지 내의 전반적인 정보를 읽어오거나 설정할 수 있는 객체
2. request : 요청을 주는 곳에서 요청을 받는 곳 사이에 살아있으면서 파라미터들이나 전반적인 요청 정보를 읽어오거나 설정할 수 있는 객체
**(다른 객체와는 다르게 Parameter의 영역을 가지고 있다.)
3. session : 브라우저가 꺼질 때까지 살아있으면서 자원을 설정하거나 읽어 들일 수 있는 객체
4. application : 웹서버가 구동이 되는 순간(어플리캐이션이 실행되는 순간) 생성되면서 웹서버가 종료되는 순간(어플리케이션이 종료되는 순간)까지 살아있는 객체면서 어플리케이션의 전반적인 정보를 읽어오거나 설정할 수 있는 객체



<<파일을 생성 또는 추가하는 우선 순위>>
1. lib 파일들 (.jar) : src/main/webapp/WEB-INF/lib 폴더 한에 추가
2. class 파일들 (.java) : src/main/java => 패키지 필요한 경우는 해당 패키지까지 추가
3. html, jsp, css, js 파일들
4. web.xml에 필요한 코드들 추가





<<cos.jar>>
- 장점 : 
파일을 업로드하기가 쉽다. MultipartRequest객체만 생성하면 파일을 바로 업로드 할 수 있다.
동일한 이름의 파일이 동일한 경로에 존재할 경우 리네임 처리를 쉽게 할 수 있다.

- 단점 : 
여러개의 파일을 multiple로 업로드 하는 경우 파일명을 각각 떼어오기가 어렵다.
존재하지 않는 폴더로 경로를 설정해도 자동 생성이 되지 않는다.
(단, macOS 운영체제인 경우는 자동으로 폴더 생성이 됨)


<<commons-fileupload.jar>>
- 장점 : 
여러개의 파일을 multiple로 업로드 하는 경우 파일명을 각각 떼어오기가 쉽다.
존재하지 않는 폴더로 경로를 설정해도 자동으로 폴더를 생성해준다.

 -단점 : 
파일을 업로드하는 로직이 cos.jar보다 복잡하다.
동일한 이름의 파일이 동일한 경로에 존재할 경우 에러가 발생된다.


<<Part>>
- 장점 : 
여러 개의 파일을 한꺼번에 업로드처리 하기가 쉽다.
동일한 이름의 파일이 동일한 경로에 존재하는 경우 마지막 업로드된 파일로 덮어쓰기가 된다.

- 단점 : 
존재하지 않는 디렉토리인 경우 자동생성이 되지 않는다.
추가해야하는 라이브러리들이 많다.





<Context allowCasualMultipartParsing="true" path="/">
<Resources cachingAllowed="true" cacheMaxSize="100000" />




JSTL (jsp standard tag library) : jsp 표준태그 라이브러리

jsp의 기본스크립트 태그, jap:액션태그, 등으로 처리할 수 없는 확장 기능을 사용하거나 아니면 위의 태그들로 기술했던 것을 자신이 만든 태그명으로 기능을 사용하고자 하는 경우 사용할 수 있는 태그를 제공하는 라이브러리


1. jstl을 사용하기 위해서는 먼저 jstl라이브러리를 추가해야 한다.
2. (jsp파일에 상단에 기술 권장) 
<%@ taglib prefix="태그명(영어소문자로만 기술권장)" uri="태그라이브러리의 uri경로 기술" %>
3. 사용형식
<prefix에 설정한 태그명:사용할태그종류명 ....></prefix에 설정한 태그명:사용할태그종류명>
<prefix에 설정한 태그명:사용할태그종류명 .... />



<<EL (Expression Language) : 표현 언어>>

형식 :  ${표현하고자 하는(브라우저에 출력하고자 하는) 값 또는 객체, 등을 기술}
=> jsp 기본 스크립트에서 설정한 변수나 객체는 끌어올 수 없다.
=> jsp 기본 스크립트 안에서는 사용할 수 없다.
=> 끌어올 수 있는 객체나 변수의 범위 : 
- jsp 기본 스크립트 안에서 request나 pageContext, 등과 같은 jsp내장객체를 통해 설정한 Attribute값 (setAttribute값)
- jsp:액션태그로 만든 객체나 변수
- jstl태그로 만든 객체나 변수




<<<<<<<<<<<<jsp이클립스 필기들>>>>>>>>>>>>

// 	out => body에서 출력해라는 jsp의 내장객체 out임

	<%@ include file="06_07_include01_header.jsp" %>
	<!-- 해당 파일의 코드를 그대로 가져와라(페이지 속성 지시태그는 중복 안됨, 사라짐) -->

// 지역변수이기 때문에 브라우저에서 새로고침 할때마다 재선언 됨
// 선언태그에서 선언된 변수를 실행태그에서 사용 가능
// 실행태그에서 선언된 변수를 선언태그에서 사용 불가

<!-- 	property : 멤버 변수명을 의미함. -->
	<jsp:setProperty property="id" name="memberBean" value="2"/>
<!-- 	name => 세팅할 객체명, property => 세팅할 객체의 멤버필드명, value => 세팅할 값 -->

	jsp:param 액션태그로 전송한 데이터는 request영역을 공유하며, <br>
	데이터 전송은 눈에 보이지는 않지만 쿼리스트링방식처럼 url뒤에 key=value형식으로 붙여 보낸다.


<% request.setCharacterEncoding("utf-8"); %>
<!-- 인코딩 설정하는 방법이고, -->
<!-- post방식으로 전송할때 요청을 받는곳에서만 인코딩 설정이 필요하다. -->


// request의 데이터영역에 저장된 데이터(post방식)의 인코딩만 설정할 때 사용함.
// get방식은 인코딩 안됨. get방식은 방식에 따라 웹페이지의 인코딩이나 브라우저의 인코딩으로 적용됨

request.getParameter() : 한 개의 인자값만들 가져오는 경우 사용한다. 
request.getParameterValues() : 여러 개의 인자값을 가져오는 경우 사용한다.
request.getParameterNames() : 인자값에 매칭되어 있는 name속성값을 가져온다. 동일한 속성명은 1개만 가져온다.

<%-- 	<jsp:setProperty name="memberBean" property="*"/> --%>
<!-- 	property="*"로 설정하기 위해서는 1. 폼요소의 name속성, 2. dto클래스의 멤버필드명, 3. 데이터베이스의 컬럼명을 일치 시켜줘야함

<!-- 	jsp:setProperty property="id", name="memverBean", param="user_id" -->
<!-- 	조합 => memberBean.setId(request.getParameter("user_id")); -->
<!-- 	=> memberBean.setId(1); -->

	<jsp:setProperty name="memberBean" property="name" param="name"/>
<!-- 	jsp:setProperty property="name", name="memverBean", param="name" -->
<!-- 	조합 => memberBean.setName(request.getParameter("name")); -->
<!-- 	=> memberBean.setName("홍길동"); -->


	<jsp:setProperty name="memberBean" property="hobby" param="hobby"/>
<!-- 	jsp:setProperty property="hobby", name="memverBean", param="hobby"  -->
<!-- 	조합 => memberBean.setHobby(request.getParameterValues("hobby")); -->
<!-- 	request.getParameterValues("hobby") => request객체에 담아놓은 내가 고른 hobby의 value값으로 새로운 배열객체를 보냄 -->
<!-- 	com.dto.MemberBean에 멤버필드로 있던 private String[] hobby = new String[3];의 값이 바뀜(length3에서 새로보낸 배열의 length로) -->
<!-- 	=> memberBean.setHobby("hobby"); -->


// 	에러 코드표 참조 사이트 : https://developer.mozilla.org/ko/docs/Web/HTTP/Status

// 	out.flush(); // 버퍼를 내보내라(비워라), 출력해라
// 	out.clear(); // 버퍼를 삭제해라, 지울게 없으면 에러(오류: 이미 배출되어 버린 버퍼를 폐기하려는 시도)
// 	out.clearBuffer(); // 버퍼에 삭제할게 있으면 삭제하고, 없으면 그냥 넘어가라



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//67
//필기
//



<!-- EL은 에러를 잘 내지않는다. 선언되지 않은 변수는 표현하지 않는다. -->


/* request.getLocale() => 요청객체의 브라우저에 설정된 언어를 가져오세요(지역을 가져오세요) */


- EL의 좋은점 getter메소드를 호출할때 get과 실행소괄호()를 떼고 부를수 있다.
예):
<%
Thermometer thermometer = new Thermometer();
request.setAttribute("t", thermometer);
%>
정보: ${t.info}
테스트: ${t.str}
|
|
public class Thermometer {
	public String getStr() {return "getStr테스트";}
	public String getInfo() {return "온도계 변환기 1.1";}
}

- EL의 좋은점 static메소드는 따로 객체생성을 하지 않고도 부를수 있다.



**********jstl에서는****core태그****choose(if-else)*******forEach*****out*****
******EL******기억하기********





<<세션, 쿠키 : 웹서버와 클라이언트간의 상태를 지속적으로 유지하는 방법>>

- 세션 : 웹서버에 저장됨
=> 보안성이 높으며, 웹서버 메모리 용량내에 저장가능함.

- 쿠키 : 클라이언트에 저장됨
=> 암호화가 되지 않아 보안성이 낮다
=> 웹서버는 웹브라우저가 전송한 쿠키를 사용해 필요한 데이터를 읽어올 수 있다.
=> 유효기간 미 설정시 웹브라우저에 저장(웹브라우저 닫을때 삭제)
=> 유요기간 설정시 사용자의 PC에 저장됨(유효기간이 지나면 자동으로 삭제)
=> 쿠키는 그 크기가 하나에 4KB 이하로 제한이 되어 있으며, 총 300개까지 정보를 저장할 수 있다.
     따라서, 최대로 저장 가능한 쿠키의 용량은 1200KB 즉 1.2MB이다.





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//67
//필기
//


<<14_01_session 예제>>

http://localhost:8090/jsptwo/14_01_session01_process.jsp?id=admin&passwd=1234


	session.invalidate();
	// 세션객체에 접근해서 저장되어 있는 모든 정보들을 유효하지 않게 해라
	// 로그아웃 처리 기능에 사용



필터(Filter)란 : 
요청(Request)과 응답(Response)에 대한 정보들을 변경할 수 있게 개발자들에게 제공하는 서블릿 컨테이너를 말함.
- javax.servlet 패키지에서 제공하는 Filter인터페이스를 이용함.

요청(Request) 필터 : 
- 인증(사용자인증)
- 요청 정보를 로그 파일로 작성
- 암호화 인코딩 작업 등의 기능을 처리

응답(Response) 필터 : 
- 응답 결과 데이터 압축
- 응답 결과에 내용 추가/수정
- 총 서비스 시간 측정



필터를 사용하기 위한 선행 조건
1. 필터클래스를 만들어야 한다.
조건 : 반드시 javax.servlet.Fileter 인터페이스를 상속받은 클래스를 만들어 주어야 한다.
구성 : 
초기에 실행되는 메소드(init()), 
실제로 요청한 url에 부합되면 실행되는 실행메소드(doFilter()), 
필터객체가 소멸되기 전에 실행되는 종료메소드(destroy)())로 구성된다.

jsp는 필터를 만들때 기본이 어노테이션 기반으로 만들어지므로, 
어플리케이션으로 명시적인 필터를 구현하라면 web.xml파일에 직접 Filter태그를 이용하여 필터 설정을 해주어야만 한다.


--------------------------------------------------------------------------------------------------------------------------------------------------
//
//68
//필기
//



filterName = "Filter01"
urlPatterns = {"이 주소"}
클라이언트에서 이 주소로 요청이 들어오면 필터한테 먼저 걸림
그리고 doFilter() 실행

필터는 여러개에 필터클래스에 동일한 urlPatterns을 설정할 수 있다.
예를들어
A => 이 주소
B => 이 주소
C => 이 주소
이때 A, B, C 필터클래스 모두 거친 후 요청하고, A, B, C 필터클래스 모두 거친 후 응답한다.
대부분 web.xml에 구현된 순서대로 진행됨


웹서버가 실행될때(톰캣이 켜지는 순간) 필터객체 생성됨
init메소드는 필터객체가 생성될때 한번만 실행됨


  <filter>
  	<filter-name>Filter01</filter-name>
  	<filter-class>com.filter.AuthenFilter</filter-class>
  </filter>
  
  <filter-mapping>
  	<filter-name>Filter01</filter-name>
  	<url-pattern>/18_01_filter01_process.jsp</url-pattern>
  </filter-mapping>



먼저
필터객체 생성 => <filter></filter>

톰캣이 켜지고 클라이언트에서 <filter-mapping>안의 <url-pattern>에 해당하는 주소로 요청이 들어오면 
<filter-name>에 해당하는 필터를 실행하고, 
<filter-class>에 해당하는 클래스에 doFilter메소드 실행됨

init메소드는 웹서버가 켜질때(시작될때) 딱 한번 호출된다.


dofilter메소드에서
PrintWriter writer = response.getWriter(); 
// PrintWriter객체에 response.getWriter()를 주면 body에 써라는 의미

destroy메소드는 웹서버가 종료될때, 필터가 삭제될때 실행됨


필터는 어노테이션기반이 있고 web.xml기반이 있는데 
어노테이션기반이 우선순위가 더 높다.

web.xml기반 필터는 객체 필터
어노테이션기반 필터는 소스코드적 필터


필터객체 생성 => <filter>
필터 생성 =><filter-name>
필터 클래스 연결 => <filter-class>

필터 조건 생성 => <filter-mapping>
실행필터 이름 => <filter-name>
실행필터 조건 => <url-pattern>


Calendar calendar = Calendar.getInstance(); 
// 현재시간의 전반적인 정보를 가져와라, Calendar는 객체생성이 안되기 때문에 스태틱메소드를 호출해서 만듬


PrintWriter는 response객체로 얻어오게되면 body에 출력하세요이다
PrintWriter를 객체로 생성하게될때 파일객체를 받게 되면 해당 파일객체에 출력하세요이다.


append
new FileWriter(파일경로) => 해당 파일을 만들어라. 똑같은 파일이 있으면 덮어쓰기됨
new FileWriter(파일경로, true) => 해당 파일을 만들어라. 해당 파일이 있으면 해당 파일의 뒤에 이어서 써라

autoFlush
new PrintWriter(파일객체) => close()될때까지 buffer에 모아뒀다가 한번에 출력
new PrintWriter(파일객체, true) => 출력할게 있을때마다(출력메소드 호출마다) 출력


request.getRemoteAddr() =>  IPv6를 발급 (IPv4(127.0.0.1))



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//69
//필기
//


많이 보게될  RequestDispatcher 기억하기
리퀘스트객체를 담아 보낼수있음



API란 (Application Programming Interface)
: 어플리케이션 소프트웨어의 개발 및 통합에 사용되는 정의 및 프로토콜(규칙) 세트
: 쉽게 말하면 API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체임. (인터페이스의 집합체)



	<jsp:useBean id="addrVO" class="com.dto.AddrVO"/>
	<jsp:setProperty property="*" name="addrVO"/>
	<!-- 해당 addrVO객체의 멤버필드명과 input요소네임값이 같으면 *로 모든 멤버필드의 setter메소드를 파라미터를 매개변수로 호출함 -->
	<!-- jsp:setProperty는 빈문자열값을 받게되면 값이 설정되지 않음. -->

===========================
https://mvnrepository.com/		|
https://mvnrepository.com/		|
https://mvnrepository.com/		|
https://mvnrepository.com/		|
https://mvnrepository.com/		|
자료다운				|
===========================


오라클과 연결하기
C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib






. 드라이버 설치
(소스코드에 기술)
Class.forName('패키지경로포함.클래스명까지기술');
=> Class.forName("oracle.jdbc.driver.OracleDriver");
=> (ojdbc6.jar)자르파일 압축해제 후 oracle안에 jdbc안에 driver안에 OracleDriver.Class파일
=> OracleDriver.Class파일 = 오라클에 접속 할 수 있는 클래스파일


. Connection 객체 얻어오기 (필요한 사항(문자열값으로): url, username, password)
데이터베이스의 접속, 데이터베이스와 연결하는 통로를 열어두는 기능
**username = "오라클의 사용자 계정명" => "test 또는 TEST"
**password = "1111"
**url => 형식 : jdbc:데이터베이스종류:[오라클인경우는드라이버버전까지:]@호스트명:포트번호:전역데이터베이스명(SID);
(오라클서버가 설치되어 있는 url)
=> "jdbc:oracle:thin:@localhost:1521:xe"
=> "jdbc:oracle:thin:@127.0.0.1:1521:xe"



Class.forName("oracle.jdbc.driver.OracleDriver");

java.sql.Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","test","1111");




<<JDBC(Java DataBase Connection)>>
자바와 데이터베이스를 연동하는 기술.
**오라클 연동에 관련 된 인터페이스들은 java.sql패키지 안에 들어있다.
java.sql.Connection : 데이터베이스의 계정과 비번, url정보를 담고 있는 객체
java.sql.Statement : 데이터베이스의 SQL명령을 담을 수 있는 객체
java.sql.PreparedStatement : 데이터베이스의 SQL명령을 담을 수 있는 객체
java.sql.ResultSet : SELECT 명령을 실행 후 가져오는 데이터의 결과 집합(레코드들의 묶음 => 인스턴스들)을 가리키고 있는 오라클의 커서와 동일한 기능을 가진 객체



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//70
//필기
//




<<DBCP(DataBase Connection Pool) :>>
자바와 데이터베이스를 연결하는 기술 중 하나. 객체를 요청할 때 생성하는 것이 아니라 먼저 일정량의 연결객체를 만들어 놓고 요철이 들어오는 즉시 객체를 보내고, 사용이 완료되면 자동으로 다시 받는 기능을 가진 기술임.

1. webapp/WEB-INF/lib 폴더 안에 ojdbc6.jar파일을 추가한다.
2. webapp/META-INF 폴더 안에 context.xml파일을 생성한다.

<Context>
    <Resource name="jdbc/설정할dbcp객체명" auth="Container" type="javax.sql.DataSource" username="사용자계정명" password="비밀번호" driverClassName="데이터베이스 드라이버 클래스 경로(패키지포함.클래스명까지)" factory="웹서버의 DBCP클래스 경로(패키지포함.클래스명까지)" url="해당 드라이버의 경로값" maxActive="500" maxIdle="100" />
</Context>

**DBCP2버전으로 업그레이드 되면서 속성이 maxActive가 아닌 maxTotal로 변경됨.



<<예시 :>>

<Context>
    <Resource name="jdbc/OracleDB" auth="Container" type="javax.sql.DataSource" username="test" password="1111" driverClassName="oracle.jdbc.driver.OracleDriver" factory="org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory" url="jdbc:oracle:thin:@localhost:1521:XE" (maxActive="500" 또는 maxTotal="500") maxIdle="100" />
</Context>

<Context>
    <Resource name="jdbc/OracleDB" auth="Container" type="javax.sql.DataSource" username="test" password="1111" driverClassName="oracle.jdbc.driver.OracleDriver" factory="org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory" url="jdbc:oracle:thin:@localhost:1521:XE" maxTotal="500" maxIdle="100" />
</Context>



- Resource name="jdbc/OracleDB" : 
공유할 리소스 이름 정의, name이 키 이므로 이것을 이용해서 자원을 얻어갈 수 있다.

- auth="Container" : 
클라이언트에서 리소스를 얻어갈 때 인증을 톰캣 컨테이너에서 관리하겠다는 의미임.

- type="javax.sql.DataSource" : 
데이터 타입 지정 (고정값). 얻어갈때 DataSource.getConnection()메소드를 통해 얻어갈 수 있다.

데이터베이스 정보 기술 ㄱ 
- username="test" 
- password="1111" 
- driverClassName="oracle.jdbc.driver.OracleDriver" 
- url="jdbc:oracle:thin:@localhost:1521:XE"

- factory="org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory" :
DBCP API를 사용하여 DBCP로 DataSource를 얻어갈 수 있도록 객체를 생성하는 부분이다.

- maxActive="500" 또는 maxTotal="500" : (디폴트-8)
동시에 제공할 수 있는 최대 connection개수를 말한다.

- maxIdle="100" :
현재 서비스되고 있는 connection객체를 제외한 connectionpool에 여유로 남길 수 있는 최대 connection개수를 지정하는 부분이다.




	<!-- <error-page> -->
	<!-- <exception-type>패키지경로포함.익셉션클래스명까지기술(공백절대안됨)</exception-type> -->
	<!-- <location>(contextpath가있어요라는의미의슬래시=>)/error/에러파일명</location> -->
	<!-- </error-page> -->
	<!-- <error-page> -->
	<!-- <error-code>코드숫자값</error-code> -->
	<!-- <location>(contextpage가있어요라는의미의슬래시=>)/error/에러파일명</location> -->
	<!-- </error-page> -->


	<!-- 코드 조각 자동 포함 기능 설정 -->
	<!-- jsp-property-group : jsp의 프로퍼티를 포함 -->
	<!-- url-pattern : 프로퍼티를 적용할 jsp파일의 url패턴을 지정 -->
	<!-- include-prelude : url-pattern태그에 지정한 경로안의 모든 jsp파일의 맨 처음 부분에 해당 파일을 
		삽입함. -->
	<!-- include-coda : url-pattern태그에 지정한 경로안의 모든 jsp파일의 맨 마지막 부분에 해당 파일을 삽입함. -->




<<header.jsp 예제>>

// HTTP 1.0.
response.setHeader("Pragma", "no-cache"); 
/* 캐시를 담아놓는 속성, 캐시지움 */


// Proxy : Client와 Server 사이에 위치하여 요청을 중계하는 역할을 하는 서버
response.setHeader("Expires", "0"); 
/* 쌓이는 데이터 유효기간 지정 속성, 만료처리 */


// HTTP 1.1.
response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate"); 
/* 전반적인 캐시의 내용을 관리하는 속성, 저장안함 캐시지움 유효성다시체크 */




-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
-----------------------------------------------------------------------------------------------------------

유알엘패턴 / 컨텍스트패스가 있습니다

a태그, form태그의 액션속성, 자바스크립트에 태그(location.href='')의 / 컨텍스트패스를 없애라

-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//71
//필기
//



서블릿(Servlet)이란

- 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
- 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트이다.
- html을 사용하여 요청에 응답한다.
- MVC 패턴에서 Controller로 이용된다.
- HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.
- 서블릿을 자바로 구현 된 CGI라고 함
**CGI(= Common Gateway Interface) 란 : 서버와 애플리케이션 간에 데이터를 주고 받는 방식

=================================================================================

어노케이션이란
- @를 이용한 주석, 자바코드에 주석을 달아 특별한 의미를 부여한 코드
(클래스, 메소드, 변수 등 모든 요소에 선언이 가능)
- 메타데이터(실제데이터가 아닌 Data를 위한 데이터) 라고도 불리고 JDK5부터 등장
- 코드에 정보를 추가하는 정형화된 방법.

=================================================================================

<<web.xml로 서블릿 설정하기>>

<servlet>
	<servlet-name>서블릿명</servlet-name>
	<servlet-class>경로포함.클래스명</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>사용할 서블릿명</servlet-name>
	<url-pattern>서블릿으로 처리할 url</url-pattern>
</servlet-mapping>



<<어노테이션으로 서블릿 설정하기>>
@WebServlet(urlPatterns - "/url패턴")

url매핑 규칙
1. /foo/bar/*	servlet1
2. /baz/*		servlet2
3. /catlog		servlet3
4. *.jsp		servlet4

요청경로
1. /foo/bar/index.html	1번패턴 일치 - 요청처리 서블릿: servlet1
2. /foo/bar/index.jsp	1번패턴 일치 - 요청처리 서블릿: servlet1
3. /baz			2번패턴 일치 - 요청처리 서블릿: servlet2
4. /baz/index.html		2번패턴 일치 - 요청처리 서블릿: servlet2
5. /catlog			3번패턴 일치 - 요청처리 서블릿: servlet3
6. /catlog	/index.jsp		4번패턴 일치 - 요청처리 서블릿: servlet4
7. /index.jsp		4번패턴 일치 - 요청처리 서블릿: servlet4






DAO(Data Access Object) : 데이터베이스에 접근하기 위한 SQL명령문을 담고 있는 객체

DTO(= VO) : Data Transfer Object(데이터를 전송하는 객체) = Value Object(데이터를 저장하는 객체)




서블릿객체는 url패턴으로 요청이 처음 들어왔을때 객체가 생성됨

서블릿은 하나의 url패턴에 하나의 서블릿만 연결 가능.

서블릿은 동일한 url패턴으로 여러개의 서블릿 생성이 불가능. 에러남



<servlet>
<servlet-name>now</servlet-name>
<servlet-class>com.controller.NowServlet</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>now</servlet-name>
<url-pattern>/NowPage</url-pattern>
</servlet-mapping>




많이 보게될  RequestDispatcher 기억하기
리퀘스트객체를 담아 보낼수있음




1. ojdbc6 라이브러리 추가
2. jstl-1.2 라이브러리 추가
3. dbcp 라이브러리 추가



-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
-----------------------------------------------------------------------------------------------------------

유알엘패턴 / 컨텍스트패스가 있습니다

a태그, form태그의 액션속성, 자바스크립트에 태그(location.href='')의 / 컨텍스트패스를 없애라

-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------


------------------------------------------------------------
a태그의 href속성
form태그의 action속성
javascript의 location.href로 설정하는 url
response.sendRedirect로 설정하는 url
ajax에서 설정하는 url값

=> /의 의미 : contextPath를 삭제하라는 의미
=> ./의 의미 : 나와 동일한 위치라는 의미
------------------------------------------------------------

------------------------------------------------------------
서블릿이나 필터에 처리하는 url패턴형식
RequestDispatcher로 설정하는 url패턴형식

=> /의 의미 : 앞에 contextPath까지 존재한다는 의미
------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------
//
//72
//필기
//
//**jsptwo프로젝트의 11_01_fileupload01_process.jsp파일에 file업로드 필기 중요



아작스
비동기이동방식
대표적으로 부분갱신


아작스(Ajax)란 : 
페이지 전체를 모두 로딩하지 않고 필요한 부분에 대해서만 갱신을 할 수 있도록 하는 기술을 의미함.
데이터는 json방식의 데이터, xml데이터, html데이터, text파일 등을 주고 받을 수 있다.

**단, 다른 서버로의 전송은 해당 서버에 권한이 없는 경우 데이터를 주고 받을 수 없다.
**이진데이터(바이트 형식의 데이터)를 주고 받을 수 없다. (.class파일 못읽음)
**반드시 요청은 서버로만 보낼 수 있다.


javascript방식 (XMLHttpRequest객체 사용)
jQuery방식 ($.ajax() 함수 사용)

비동기통신이 이루어지는 순서
1. 클라이언트의 요청 (비동기통신에 필요한 객체 생성 및 연결, 전송까지 포함)
2. 서버에서의 응답
3. 클라이언트에 응답 도착 (비동기통신 적용)

[ javascript방식 ]
1. XMLHttpRequest객체 생성
예: var xhttp = new XMLHttpRequest();

2. 서버로 보낼 요청 데이터의 타입 설정 및 연결 : open()
예: xhttp.open("데이터전송방식", "요청url주소", 비동기여부);
데이터전송방식 : GET, POST
요청url주소 : /test.do 등
비동기여부(비동기화여부=async) : true, false 중 선택
(true : 비동기방식, false : 동기방식)

3. 서버로 데이터 전송하기 : send();
예: xhttp.send(); 또는 xhttp.send(보낼데이터가 있는 경우 데이터를 담을 수 있다.);

**readState 속성 : 객체의 상태를 나타내는 속성
- 0 (UNSET) : 비동기객체가 생성된 상태
- 1 (OPEND) : open()메소드가 정상적으로 실행된 상태
- 2 (HEADERS_RECEIVED) : 데이터가 서버로 모두 send되어 해당 요청의 응답이 도착만 된 상태
- 3 (LOADING) : 데이터를 클라이언트의 브라우저로 응답하기 위해 준비하는 처리 단계
- 4 (DONE) : 요청한 데이터가 모두 응답할 준비가 된 상태

**status 속성 : 응답 결과 상태를 나타내는 코드값
예시 : 
- 200 : 정상 (요청 정보가 존재한다는 의미)
- 404 : 비정상 (요청 페이지가 존재하지 않는다는 의미)
... 등등

**onreadystatechange 속성 : 비동기 객체의 상태가 변경이 될 때마다 실행되는 속성

-----------------------------------------------------------------------

[jQuery 형식]
**반드시 jQuery라이브러리가 먼저 등록되어야 한다.
$.ajax({ json형식의 옵션 설정 });

예시 : 
$.ajax({ 
	url : "요청할 url주소",
	type : "데이터전송방식-GET 또는 POST 등",
	data : {전송할 파라미터의 "key" : "value" 속성으로 json방식으로 설정},
	async : true(기본값) 또는 false,
/*
비동기여부
async : true => 비동기방식 : 요청을 보낸 후 응답결과와는 상관없이 다음 방식이 동작하는 방식
async : false => 동기방식 : 요청을 보낸 후 응답결과를 받아야만 다음 동작이 이우러지는 방식
*/
	cache : true 또는 false,
/* 데이터를 주고 받을 때 데이터를 저장할지(true), 저장하지 않을지(false) 여부 */
	
	dataType : "json",
/* 서버에서 데이터를 어떤 자료형으로 받아올지의 여부
"json", "text/html" 등등이 있다. 기술하지 않는 경우는 자동으로 알아서 자료형 인식해 옴.*/

	contentType : "application/form-data, ~~~",
/*
클라이언트에서 서버로 보내는 데이터의 자료형을 어떤 형식으로 보낼지 지정하는 속성,
지정하지 않는 경우 form데이터(파라미터)로 자동인식됨.
*/
	success : function(변수명){ /* 변수명: 성공시에 반환 받을 데이터를 담음. */
		// 성공할때 처리할 로직, 
		// 성공이라 하면 readState 속성이 4(DONE)이고, status 속성이 200일 때를 말함.
		},
	error : function([변수명, ...]){ /* 예) state : 객체 */ 
		// 에러 발생시 처리할 로직
		}
}); // $.ajax 선언끝



-----------------------------------------------------------------------------------------------------------------------
자바스크립트식 예시 : 

	function loadDoc() {
		var xhttp = new XMLHttpRequest(); // 비동기통신을 하기위한 객체생성
		
		if (this.readyState == XMLHttpRequest.UNSET) { 
			document.getElementById("status").innerHTML = currentState;
			if (this.readyState == 4 && this.status == 200) {
				document.getElementById("demo").innerHTML = xhttp.responseText;
			}
		};

 		// 형식 : open(전달방식, URL주소, 동기여부);
		// xhttp.open("GET", "ajax_info.txt", true);
		xhttp.open("GET", "Gesipan/test.do", true);
		
		xhttp.send();
	}
-----------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------
제이쿼리식 예시 : 
(보내는 데이터가 없을때 load() 함수를 사용함)

	function loadDoc() {
 		// $("#demo").load("ajax_info.txt");
		$("#demo").load("Gesipan/test.do");
	}
-----------------------------------------------------------------------------------------------------------------------


ajaxFile2.jsp
필기


=======================================================================
집에서 추가
이클립스 실행 및 환경설정 하기
1. c:\eclipse폴더 안의 eclipse.exe파일 클릭하여 실행하기
2. Workspace경로는 [Browse...]버튼 클릭하여 c:\jwork 폴더 찾아서 설정한 후 [ Launch ] 클릭
3. welcome탭 닫기
4. 맨 상단의 Window메뉴 클릭 > Preferences 클릭
5. Preferences 창의 좌측 메뉴에서 Java 메뉴 확장하기 
   > Installed JREs 확장하지말고 그냥 클릭
   > 기존의 jre선택 후 우측 [Remove]클릭하여 삭제 후  [Add...]클릭
   > Standard VM 선택 후 [Next] 클릭
   > JRE home : C:\Program Files\Java\jdk-11 까지 선택하면 [JRE name, JRE system libraries] 자동으로 내용 생성됨.
   > JRE name : jdk-11
   > JRE system libraries : C:\Program Files\Java\jdk-11\lib\jrt-fs.jar
   > [Finish] 클릭하면 창 닫기고 [Preferences] 창에 추가한 내용이 들어가 있는 것이 확인되면 [Apply and Close] 클릭
6. 맨 상단의 Window메뉴 클릭 > Preferences 클릭
7. Preferences 창의 좌측 메뉴에서 General메뉴 확장하기
   > Workspace 메뉴 확장하지 말고 그냥 클릭 
   > Text file encoding 부분의 Other선택하면 활성화되는 선택창에서 [UTF-8]선택 후 [Apply] 클릭
8. Preferences 창의 좌측 메뉴에서 General메뉴 확장하기
   > Web Browser 메뉴 클릭 
   > [v]Use external web browser선택
   > External web browsers에서 [Chrome]선택 후 [Apply] 클릭
9. Preferences 창의 좌측 메뉴에서 Web메뉴 확장하기
   > 뒤에 Files가 붙은 메뉴[CSS Files, HTML Files, JSP Files]만 확장하지 말고 그냥 클릭
   > Encoding 부분을 UTF-8로 변경 후 [Apply]
10. [Apply and Close] 클릭하여 Preferences창 닫기


Apache Tomcat 사이트 들어가서 9버전 -> 64비트 다운로드 -> 다운로드 폴더에서 복사하기 -> c드라이브에 붙여넣기 후 알아서 압축 풀기 -> apache-tomcat-9.0.86 폴더가 생김 -> 기본 포트번호 8080인데 오라클의 포트번호랑 중복되므로 변경해야함
conf -> server.xml -> 메모장으로 열기 ->   <Service name="Catalina">의 Connector port="8080"을 8090으로 변경 -> 시스템변수에 새로 추가 변수이름 : CATALINA_HOME
변수값 : C:\apache-tomcat-9.0.86 (디렉토리찾기에서 폴더까지만 선택)
=======================================================================








./users/deleteForm.html?delId<%=mcuser.getId()%>


--------------------------------------------------------------------------------------------------------------------------------------------------
//
//84
//필기
//

데이터베이스 연결 객체 (oracle | mariadb)
- url : 포트번호 = 1521  | 3306
      전역데이터베이스 = xe  |  samp
      jdbc:oracle:thin:@localhost: 1521:xe  |  jdbc:mariadb://@localhost:3306/samp

- username : test  |  root

- password : 1111  |  1111



<<<MariaDB / MySQL>>>
포트번호 3306

계정명은 대소문자 가림, 안에 데이터베이스 안에서는 대소문자 안가림

계정 접근 후

<<데이터베이스 생성 형식>> (계정의 권한을 계정안에 데이터베이스들이 상속받음)
CREATE DATABASE 데이터베이스명 DEFAULT CHARACTER SET UTF8;
CREATE DATABASE 데이터베이스명 DEFAULT CHARSE=UTF8;
**데이터베이스이름(url뒤에 오라클때의(xe) 자리에 들어감)

CREATE DATABASE SAMP DEFAULT CHARACTER SET UTF8;


<<데이터베이스 접근 형식>>
USE SAMP	(한줄명령어)


<<테이블 생성 형식>>
CREATE TABLE 테이블명(
컬럼명 자료형(사이즈) 제약조건들,
컬럼명 자료형(사이즈) 제약조건들,
....,
컬럼명 자료형(사이즈) 제약조건들
) DEFAULT CHARACTER SET UTF8;
또는
) DEFAULT CHARSET=UTF8;

CREATE TABLE STUDENT(
    ID INT NOT NULL,
    NAME VARCHAR(10) NOT NULL,
    GENDER ENUM('남자', '여자') NOT NULL,
    ADDRESS VARCHAR(50) NOT NULL,
    BIRTHDAY DATE NOT NULL,
    PRIMARY KEY (ID)
    ) DEFAULT CHARSET=UTF8;


<<계정의 데이터베이스들을 보여줘 형식>>
SHOW DATABASES;

+--------------------+
| Database               |
+--------------------+
| information_schema  |
| mysql              	    |
| performance_schema |
| samp           	    |
| sys               	    |
+--------------------+

<<데이터베이스의 테이블들을 보여줘 형식>>
SHOW TABLES;





INSERT INTO STUDENT VALUES (1, '홍길동', '남자', '서울', '1999-10-26');
INSERT INTO STUDENT VALUES (2, '황진이', '여자', '경기', '1991-12-31');
INSERT INTO STUDENT VALUES (3, '전우치', '남자', '인천', '1989-2-10');
INSERT INTO STUDENT VALUES (4, '강백호', '남자', '강원', '1995-11-4');
INSERT INTO STUDENT VALUES (5, '나엄지', '여자', '충남', '1982-11-16');
INSERT INTO STUDENT VALUES (6, '설까치', '남자', '경북', '1997-10-1');
INSERT INTO STUDENT VALUES (7, '추사랑', '여자', '전남', '1985-1-1');
INSERT INTO STUDENT VALUES (8, '삼둥이', '남자', '제주', '1981-2-3');



SELECT 컬럼들... | * --(5)
FROM 테이블명 --(1)
WHERE 조건들 --(2)
GROUP BY 그룹으로 묶을 컬럼들 --(3)
HAVING 그룹BY 조건들 --(4)
ORDER BY 정렬시킬 컬럼명 [asc] | desc --(6)
LIMIT절 (페이징지정값) --(7)


-- LIMIT절 사용법
//함수형식, OFFSET => 건너띄는값, LIMIT => 가져올 행 수의 개수 값
LIMIT OFFSET값, LIMIT값 => LIMIT 1, 3
//기본형식
LIMIT 값 OFFSET 값  => LIMIT 3 OFFSET 1



오라클의 페이징처리--------------------------------------------------------
SELECT * FROM
(SELECT a.* ROWNUM rm FROM
(SELECT * FROM 테이블명 WHERE 조건 ORDER BY절) a)
WHERE rm BETWEEN START(시작행번호)값 AND END(종료행번호)값
------------------------------------------------------------------------------


한줄만 가져올때
SELECT * FROM STUDENT LIMIT 0, 1;
SELECT * FROM STUDENT LIMIT 1;






AUTO_INCREMENT 제약조건
 : 1씩 자동 증가하도록 해주는 숫자값을 가지고 있는 제약조건
 : 반드시 해당 테이블의 PRIMARY KEY로 설정된 정수값 컬럼에만 사용가능;
 : 컬럼레벨 방식으로만 기술 가능.



CREATE TABLE STUDENT(
    ID INT PRIMARY KEY AUTO_INCREMENT,
    NAME VARCHAR(10) NOT NULL,
    GENDER ENUM('남자', '여자') NOT NULL,
    ADDRESS VARCHAR(50) NOT NULL,
    BIRTHDAY DATE NOT NULL
    ) DEFAULT CHARSET=UTF8;




SELECT ID, NAME, ADDRESS,
CASE ADDRESS
WHEN '서울' THEN '02'
WHEN '경기' THEN '031'
WHEN '인천' THEN '032'
WHEN '강원' THEN '033'
WHEN '충남' THEN '041'
WHEN '경북' THEN '054'
WHEN '전남' THEN '061'
ELSE '064'
END AS CITYNUM
FROM STUDENT;


CREATE TABLE CITY AS
SELECT ADDRESS,
CASE ADDRESS
WHEN '서울' THEN '02'
WHEN '경기' THEN '031'
WHEN '인천' THEN '032'
WHEN '강원' THEN '033'
WHEN '충남' THEN '041'
WHEN '경북' THEN '054'
WHEN '전남' THEN '061'
ELSE '064'
END AS CITYNUM
FROM STUDENT;


INSERT INTO STUDENT (ID, NAME, GENDER, ADDRESS, BIRTHDAY) VALUES (20, '구길동', '남자', '독도', '1989-02-23');
INSERT INTO STUDENT (NAME, GENDER, ADDRESS, BIRTHDAY) VALUES ('구길동', '남자', '독도', '1989-02-23');

ALTER TABLE CITY MODIFY ADDRESS VARCHAR(55) PRIMARY KEY;







SELECT S.*, C.*
FROM STUDENT S
JOIN CITY C
USING (ADDRESS); 또는 ON S.ADDRESS = C.ADDRESS;



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//85
//필기
//



스프링프레임워크란 : SpringFramework

자바 기반의 빈객체 생성이나 생명주기관리, 의존성 주입, 제어의 역행, AOP등을 제공해주는 프레임워크를 말한다.

- IoC (Inversion of Controller) : 제어의 역행.
개발자가 일일이 설정해주고 직접 관리하던 것을 프레임워크로 제어나 관리를 넘겨버리는 것을 제어의 역행이라고 한다.

- 의존성 주입 (Dependency Injection) : 
개발자가 일일이 객체를 생성해서 필요한 부분에 객체를 보내거나 받는 작업을 처리하던 것을 스프링프레임워크의 컨테이너가 처리하도록 하는것.

- 의존성 검색 (Dependency Lookup) : 
필요한 기능을 알아서 검색해오는 기능

- AOP (Aspect Orientied Programming) : 관심지향 프로그래밍




<<스프링 프레임워크 프로젝트 생성시 알아두기>>


Maven(메이븐)방식으로 형상관리 진행
형상관리란 : 파일이나 문서, 라이브러리 등의 버전을 관리하는 것을 형상관리라고 한다.

형상관리 방법 : 
Maven방식 : 태그 형식으로 라이브러리 버전을 관리하는 방식 
Gradle 방식 : json형식으로 라이브러리 버전을 관리하는 방식


프로젝트 생성방법 : 
Dynamic Web Project생성 (Perspective Mode - JavaEE) => 생성한 프로젝트에서 마우스 우버튼 메뉴에 있는 configure => Convert to Maven Project로 변환해 주어야 한다.

** 반드시 프로젝트 생성 시 가장 처음에 생성되는 패키지는 3단 이상이 되어야 한다.

Maven프로젝트 설정 시 나오는 창에서 
Group ID부분에 들어가야 하는 값은 3단 패키지명 중 2단까지 기술 
(예: com.kr.co 까지 일때 -> com.kr)
Group ID : com.kr
Artifact ID : co => 이 부분이 나중에 프로젝트의 contextPath가 되는 부분임.
Name : 프로젝트명 기술하는 자리
**나머지는 디폴트값 그대로 두면 됨. 


Bean(빈) : 스프링 프레임워크에서 만드는 모든 객체를 빈이라고 한다.

빈 객체를 생성하는 방법 : pom.xml에서 만들거나 어노테이션으로 만드는 방법 두가지가 있다.


<<빈 객체 생성 방법>>
src -> main폴더 안에 resources 폴더 생성하기
resources 폴더 안에 스프링 빈 설정 파일 생성하기


스프링 빈 설정 파일의 경로
1. src/main/resources
2. src/main/wabapp/WEB-INF



<bean id="객체명" class="패키지경로포함.클래스명까지" />
명명규칙 : 영어소문자, 공백x, 카멜기법, 특수문자 _ $
<bean name="객체명" class="패키지경로포함.클래스명까지"></bean>
명명규칙 : 공백만 제외하고 다 가능

java코드 => 패키지경로포함.클래스명까지 객체명 = new 기본생성자호출문();




TVMain예제

factory => 
객체명(Bean) : http://stv || 자료형 : Samsung, TV
=>즉시로딩, 
객체명(Bean) : ltv || 자료형 : Lg, TV
=>지연로딩, 


scope 속성 : singleton(디폴트값), prototype(new)
로딩방식 속성 (lazy-init값 : true, false(디폴트값)) => 객체 생성 시점
즉시로딩 (pre-loading) : lazy-init="false" 인 경우(기술안함)
=> 스프링 컨테이너가 구동될때 객체 생성을 한다.(미리 객체 준비)

게으른로딩=지연로딩 (lazy-loading) : lazy-init="true" 인 경우 
=> getBean()메소드로 객체를 얻을 때 생성된다.





// GenericXmlApplicationContext 파일시스템이나 클래스 경로에 있는 xml설정 파일을 로딩하여 구동하는 컨테이너 클래스
// GenericXmlApplicationContext이 인식하는 경로 : src/main/resources/ 까지 자동으로 인식함.

AbstractApplicationContext factory = new GenericXmlApplicationContext("applicationContext.xml");

*************
// ㄴ위 코드가 하는 일
// 1. 스프링 컨테이너 구동
// 2. Spring Bean Configuration file을 읽어들인다.
// 3. 빈 설정 파일에 기술되어 있는 빈 객체를 생성하여 컨테이너에 모아둔다.
// 4. 객체를 주입해야 하는 부분에 자동으로 객체 주입을 진행한다.


예제 :
<bean name="http://stv" class="com.kr.co.Samsung" init-method="initSamsung" destroy-method="destroySamsung"/>
name = 빈객체명, class = 자료형(패키지경로포함.클래스명까지), init-method = 객체생성 후 가장 먼저 실행되는 메소드, destroy-method = 객체생성 후 할일이 끝나면 마지막에 실행되는 메소드







// AnnotationConfigApplictionContext 자바 설정 정보를 읽어오는 클래스
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppContext.class);

@Lazy만 기술되면 lazy-init="true" (게으른로딩=지연로딩)

예: @Bean @Lazy


ctx => 
객체명(Bean) : stv || 자료형 : Samsung, TV
=>즉시로딩, 싱글톤

객체명(Bean) : greeter || 자료형 : Greeter
=>즉시로딩, prototype

객체명(Bean) : greeter1 || 자료형 : Greeter
=>지연로딩, 싱글톤

객체명(Bean) : inter || 자료형 : Integer
=>즉시로딩, 싱글톤




two프로젝트 예제
스프링 컨테이너 객체 : factory
객체명(Bean) : sony
자료형 : SonySpeaker, Speaker
즉시로딩, 싱글톤

객체명(Bean) : apple
자료형 : AppleSpeaker, Speaker
즉시로딩, 싱글톤

객체명(Bean) : tv
자료형 : SamsungTV, TV
SamsungTV(sony)로 객체생성
즉시로딩, 싱글톤





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//86
//필기
//

DAO(Data Access Object) : 데이터베이스에 접근하기 위한 SQL명령문을 담고 있는 객체
DTO(= VO) : Data Transfer Object(데이터를 전송하는 객체) = Value Object(데이터를 저장하는 객체)



객체를 생성할 수 있는 클래스 종류

**xml파일에서 component scan에 대한 설정을 해주어야 한다.
1. namespace에서 context태그에 대한 네임스페이스를 선택 (저장)
2. <context:component-scan base-package="경로(패키지)" [lazy-init="ture"]></context:component-scan>
예시: com.spring.biz, com.spring.comp, com.spring.sett

경로값: com.spring.*, com.spring.comp

DAO클래스, DTO(=VO)클래스, Controller클래스, Service클래스(비즈니스클래스 = 서비스로직 : 직접처리하는 일 없이 남에게 시키기만 하는 클래스)

@Component 어노테이션
위의 클래스들 중에서 DAO, Controlloer, Service 클래스들을 제외한 나머지 클래스들을 객체화 시킬 때 사용하는 어노테이션
위치 : 클래스명 위에 위치함. (기술함)

형식 : 
@Component 만 기술 할 경우 : 
자동으로 객체명이 생성됨. 클래스명을 가져와서 앞 글자만 소문자로 변경한 것을 객체명으로 인식함.

@Component("객체명") : 
객체명으로 지정해 준 이름을 객체명으로 인식함.

==============================================================

**@Service : 비즈니스 로직을 처리하는 Service클래스 객체를 의미
- 인터페이스를 상속받은 impl클래스에 기술

**@Repository : DAO클래스 객체를 의미
- DAO클래스에 기술
(DAO(Data Access Object) : 데이터베이스에 접근하기 위한 SQL명령문을 담고 있는 객체)

**@Controller : Controller클래스 객체를 의미
- 사용자 요청을 제어하는 클래스에 기술

==============================================================

DI(Dependency Injection) : 의존성 주입
스프링 컨테이너가 직접 객체들 사이에 의존관계를 처리하는 것을 의미함.

byType : 자료형으로 주입하는 방식
@Autowired
- 주로 변수 위, 매개변수가 있는 메소드의 위에 기술함.
- 해당 어노테이션이 기술된 변수나, 매개변수의 자료형으로 생성된 객체가 있는지 확인하여 존재하는 경우 자동으로 해당 객체를 주입시킨다.
예시:
@Autowired
Speaker speaker;

==============================================================

@Inject
@Autowired와 동일한 기능을 하는 어노테이션

@Resource
@Autowired와 동일한 기능을 하는 어노테이션

==============================================================

byName : 객체명으로 검색하여 해당 자료형을 주입하는 방식
@Qualifier("객체명")
- @Autowired와 같이 사용됨. 동일한 자료형인 객체가 2개 이상 존재할 경우 @Autowired만으로 처리를 할 수 없기 때문에 이 부분을 보완하여 같이 사용하는 어노테이션이다.

@Named("객체명")
- @Inject와 같이 사용됨. 동일한 자료형인 객체가 2개 이상 존재할 경우 @Inject만으로 처리를 할 수 없기 때문에 이 부분을 보완하여 같이 사용하는 어노테이션이다.

@Resource(name="객체명")
- @Autowired + @Qualifier("객체명")를 합쳐놓은 어노테이션이다.
- @Inject + @Named("객체명")를 합쳐놓은 어노테이션이다.

==============================================================

의존성주입 어노테이션들의 위치
주입이 되어야 하는 대상의 위에 기술, 
1. 멤버필드 위에 기술
2. 메소드 위에 기술 (대상: 매개변수)
3. 메소드의 매개변수 앞에 기술 (대상: 해당 매개변수)

*자료형으로 주입하는 방식(byType)에서 컨테이너에 생성된 객체들 중 해당 자료형이 2개 이상 존재하면 에러가 난다.
해결법 - 1. 해당 자료형의 객체를 1개로 줄임, 2. byName방식으로 변경


two/com.springbook.annot 예제
factory => 
빈객체명 : apple
자료형 : AppleSpeaker, Speaker
즉시로딩, 싱글톤


빈객체명 : sony
자료형 : SonySpeaker, Speaker
즉시로딩, 싱글톤

빈객체명 : tv
자료형 : LgTV, TV
즉시로딩, 싱글톤
자동주입 : 




드라이버
오라클 : ojdbc6.jar => 11.2.0.4
<!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc6 -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc6</artifactId>
    <version>11.2.0.4</version>
</dependency>

MariaDB : mariadb-java-client => 2.7.3
<!-- https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-client -->
<dependency>
    <groupId>org.mariadb.jdbc</groupId>
    <artifactId>mariadb-java-client</artifactId>
    <version>2.7.3</version>
</dependency>

MySQL : mysql-connector-java => 8.0.25
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.25</version>
</dependency>







three/com.springbook.biz 예제
container => 

빈객체명 : boardDAO
자료형 : BoardDAO
즉시로딩, 싱글톤
자동주입 : 


빈객체명 : boardService
자료형 : BoardServiceImpl, BoardService
즉시로딩, 싱글톤
자동주입 : dao => BoardDAO





four/com.springbook.annot 예제
factory => 

빈객체명 : apple
자료형 : AppleSpeaker, Speaker
즉시로딩, 싱글톤

빈객체명 : tv
자료형 : LgTV, TV
즉시로딩, 싱글톤
자동주입 : speaker => apple

빈객체명 : stv
자료형 : SamsungTV, TV (생성자로 멤버필드초기화: SonySpeaker, 170000)
즉시로딩, 싱글톤
자동주입 : 



four/com.springbook.setterannot 예제
factory => 

빈객체명 : apple
자료형 : AppleSpeaker, Speaker
즉시로딩, 싱글톤

빈객체명 : tv
자료형 : LgTV, TV
즉시로딩, 싱글톤
자동주입 : speaker => apple

빈객체명 : stv
자료형 : SamsungTV, TV (생성자로 멤버필드초기화: SonySpeaker, 170000)
즉시로딩, 싱글톤
자동주입 : 

빈객체명 : sony
자료형 : SonySpeaker, Speaker
즉시로딩, 싱글톤

빈객체명 : intval
자료형 : Integer
즉시로딩, 싱글톤



*자료형으로 주입하는 방식(byType)에서 컨테이너에 생성된 객체들 중 해당 자료형이 2개 이상 존재하면 에러가 난다.
- 해결법
1. 해당 자료형의 객체를 1개로 줄임, 2. byName방식으로 변경
2. 중복되는 객체들 중 하나에 @Primary 어노테이션을 추가해준다.


//@Configuration
@ComponentScan("com.springbook.component")

어노테이션 방식 컨테이너 생성시 @ComponentScan만 해주면 @Configuration의 기능을 품고있어서 따로 기술하지 않아도 됨


four/com.springbook.component 예제
factory => 

빈객체명 : apple
자료형 : AppleSpeaker, Speaker

빈객체명 : sony
자료형 : SonySpeaker, Speaker
@Primary

빈객체명 : stv
자료형 : SamsungTV, TV
자동주입 : speaker => sony, price => price

빈객체명 : price
자료형 : int, Integer

빈객체명 : tv
자료형 : LgTV, TV
지연로딩, prototype






◆AOP(Aspect Oriented Programming) : 관점지향프로그래밍 또는 관심분리프로그래밍
종단관심(핵심관심), 횡단관심(공통관심) 중 횡단관심을 표현하는 방법이며, 런타임(실행시점)에 프록시 객체를 생성하여 공통기능을 삽입하는 방식임. AOP는 프록시 객체(Aspect)를 자동 생성하여 사용한다.

**대상 객체 : 핵심 기능을 실행하는 객체를 말함
**프록시 : 핵심 기능은 다른 객체가 실행하도록 하고, 부가적인 기능(공통적인 기능)을 제공하는 객체를 말함.
**Advice : 공통로직을 기술한 클래스를 말함.
**JoinPoint : Pointcut이 될 수 있는 모든 후보 지점을 말함. (지정한 경로 클래스의 모든 메소드)
**Pointcut : JoinPoint중 공통로직이 적용되는 실제 지점을 의미함. (지정한 클래스안의 메소드 중 패턴에 일치하는 메소드)
**Aspect : advice 와 pointcut 결합 및 적용 시점 정의. (메소드가 실행되기 전, 후/ 에러가 나는 경우/ 에러 없이 모무 완료 되는 경우 등의 시점을 말함)
**Weaving : 공통로직이 실제로 적용(삽입)되는 과정을 말함. (적용한 시점에 해당 공통로직(공통메소드)이 실행 되는 과정을 말함.)


◆AOP에 필요한 선수작업
**pom.xml에서 springframework-version버전과 비슷한 시기에 출시된 aspectj-version버전을 확인하여 설정할 것.
<properties>
	...
	<org.aspectj-version>1.9.7</org.aspectj-version>
	...
</properties>

1. maven repository에서 aspectjweaver (1.9.7버전으로)라이브러리 다운받기
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>${org.aspectj-version}</version>
    <scope>runtime</scope>
</dependency>

2. Spring Bean Configuration File(xml) 파일의 namespace에서 aop선택 후 저장

3. Spring Bean Configuration File(xml) 파일에 기술 할 내용

형식(xml방식) :
aop관련 advice, point, aspect 태그 기술할 것

-- advice 객체 생성
<bean id="공통로직객체명" class="패키지경로포함.공통로직클래스명"></bean>

-- aop 설정
<aop:config>
	-- pointcut 설정
	<aop:pointcut id="포인트컷객체명" expression="execution(포인트컷 패턴 지정)"/>

	-- aspect 설정 : advice와 pointcut 결합 및 적용 시점 정의
	<aop:aspect ref="공통로직객체명">
		<aop:시점기술 pointcut-ref="포인트컷객체명" method="공통로직클래스에 있는 메소드명" />
	</aop:aspect>
</aop:config>

형식(annotation방식) :
<context:component-scan base-package="공통로직클래스들이존재하는패키지경로"></context:component-scan>
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

4. 이 부분은 어노테이션 방식만 처리할 것
- advice클래스의 클래스명 위에 @Service와 @Aspect 기술할 것
- advice클래스의 메소드위에 시점관련 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @After("execution(* com.springbook.biz..*impl.*(..))")

- 만약 pointcut 따로 advice 따로 지정할 경우
--- pointcut에 해당되는 클래스 생성 후 클래스명 위에 @Aspect만 기술한 후에
--- pointcut에 해당되는 클래스의 메소드위에 @Pointcut 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @Pointcut("execution(* com.springbook.biz..*impl.get*(..))")

--- advice 클래스의 클래스명 위에 @Service와 @Aspect 기술할 것
- advice 클래스의 메소드 위에 시점관련 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @Before("PointcutCommon.allPointcut()")
위의 경우 해당 메소드가 static이 아니어도 클래스명.메소드()로 접근가능하다.


◆AOP 동작 시점
1. before : 포인트컷으로 지정한 메소드(비즈니스로직)가 실행되기 전에 실행됨.
2. after종류 : 
-> after-returning : 포인트컷으로 지정한 메소드(비즈니스로직)가 정상적으로 실행완료되면 실행됨. 
(리턴할 데이터가 있는 경우 returning속성 사용)

-> after-throwing : 포인트컷으로 지정한 메소드(비즈니스로직) 실행 중 예외 발생 시 실행됨. 
(try~catch문에서 catch문과 동일한 기능, 예외처리 할 데이터가 있는 경우 throwing속성 사용)

-> after : 포인트컷으로 지정한 메소드(비즈니스로직)가 완료되면 실행됨.
(try~catch~finally문에서 finally에 해당 됨.)

3. around : 포인트컷으로 지정한 메소드(비즈니스로직)가 실행되기 전과 후에 실행됨.
- 포인트컷 메소드의 실행전과 후에 모두 실행되어야 하므로 포인트컷의 메소드를 객체화시킨(ProceedingJoinPoint클래스로 정보를 담아놓는다.) 정보를 가지고 있으며, around공통로직에서 해당 포인트컷 메소드가 실핼되는 위치를 proceed()메소드로 지정해주어야 한다.

//JoinPoint : 포인트컷 메소드의 정보를 담는 클래스
//getSignature() : 포인트컷 메소드의 메소드명, 매개변수들의 정보를 가져옴.
//getName() : getSignature() 메소드가 가진 정보 중 메소드 명만 가져옴.
//getArgs() : getSignature() 메소드가 가진 정보 중 매개변수 정보만 가져옴.


◆AOP execution 명시적 표현식 (패턴)

- 형식 : 
execution([수식어패턴] 리턴타입패턴 [경로포함클래스명패턴.]메소드패턴(파라미터패턴))

1. 수식어패턴 : 생략가능. AOP는 (public, private가 있지만) public만 가능함. 따라서 디폴트(public)값 임.

2. 리턴타입패턴 : 
void -> 리턴타입없음
Long -> 리턴타입이 Long형임
* -> 모든 리턴타입 (void포함)

3. 경로포함클래스명패턴 : 생략가능
예시 : com.springbook.biz로 시작하는 패키지 또는 하위 패키지까지 포함, 그리고 그 안에 클래스명이 impl로 끝나는 클래스인 경우
=> com.springbook.biz..*impl

4. 메소드패턴
예시 : com.springbook.biz로 시작하는 패키지 또는 하위 패키지까지 포함, 그리고 그 안에 클래스명이 impl로 끝나는 클래스안의 모든 메소드인 경우 => com.springbook.biz..*impl.*()
모든 메소드인 경우 : *() => 이름이 set으로 시작하는 모든 메소드인 경우 : set*()


5. 메소드의 파라미터 패턴 : 
예시 : set*(..) : 파라미터가 0개 이상인 경우
예시 : set*(*) : 파라미터가 1개인 경우
예시 : set*(*,*) : 파라미터가 2개인 경우
예시 : set*(Integer, ..) : 첫번째 파라미터 타입이 Integer이고 한 개 이상의 파라미터를 갖는 경우

==> execution(public * com.springbook.biz..Impl.get*(..))
==> execution(* com.springbook.biz..Impl.get*(..))
==> execution(* get*(..))



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//87
//필기
//



five/ com.springbook.biz.common 예제

container =>

빈객체명 : log4j
자료형 : Log4jAdvice

빈객체명 : testDAO
자료형 : TestDAO

빈객체명 : testService
자료형 : TestImpl
자동주입 : td => testDAO

aop설정 =>
공통로직객체(Advice) : log4j => 메소드명 : printLogging
포인트컷 : execution(* com.springbook.aop..*Impl.set*(*,*))
시점 : before






five / com.springbook.biz.board 예제
container => 

빈객체명 : boardDAO
자료형 : BoardDAO

빈객체명 : boardService
자료형 : BoardServiceImpl, BoardService
자동주입 : dao => boardDAO(BoardDAO)




<<AOP의 포인트컷 around시점>>
지정된 포인트컷메소드가 실행되면 around메소드가 실행되고
어라운드메소드에는 오브젝트로 포인트컷메소드를 담아야함
그리고 around메소드에서 proceed()를 호출해야 이때 포인트컷메소드가 실행된다.
(com.springbook.biz.common/AroundAdvice 예제 참고)





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//88
//필기
//



◆AOP에 필요한 선수작업
**pom.xml에서 springframework-version버전과 비슷한 시기에 출시된 aspectj-version버전을 확인하여 설정할 것.

1. maven repository에서 aspectjweaver (1.9.7버전으로)라이브러리 다운받기

2. Spring Bean Configuration File(xml) 파일의 namespace에서 aop선택 후 저장

3. Spring Bean Configuration File(xml) 파일에 기술 할 내용

4. 이 부분은 어노테이션 방식만 처리할 것
- advice클래스의 클래스명 위에 @Service와 @Aspect 기술할 것
- advice클래스의 메소드위에 시점관련 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @After("execution(* com.springbook.biz..*impl.*(..))")

- 만약 pointcut 따로 advice 따로 지정할 경우
--- pointcut에 해당되는 클래스 생성 후 클래스명 위에 @Aspect만 기술한 후에
--- pointcut에 해당되는 클래스의 메소드위에 @Pointcut 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @Pointcut("execution(* com.springbook.biz..*impl.get*(..))")

--- advice 클래스의 클래스명 위에 @Service와 @Aspect 기술할 것
- advice 클래스의 메소드 위에 시점관련 어노테이션 기술 및 포인트컷 표현범위 지정할 것
예: @Before("PointcutCommon.allPointcut()")
위의 경우 해당 메소드가 static이 아니어도 클래스명.메소드()로 접근가능하다.



**advice 객체 생성
<bean id="공통로직객체명" class="패키지경로포함.공통로직클래스명"></bean>

**aop 설정
<aop:config>
	-- pointcut 설정
	<aop:pointcut id="포인트컷객체명" expression="execution(포인트컷 패턴 지정)"/>

	-- aspect 설정 : advice와 pointcut 결합 및 적용 시점 정의
	<aop:aspect ref="공통로직객체명">
		<aop:시점기술 pointcut-ref="포인트컷객체명" method="공통로직클래스에 있는 메소드명" />
	</aop:aspect>
</aop:config>


****************************
포인트컷메소드 => execution으로 설정한 메소드(들)


<<AOP의 포인트컷 around시점>>
지정된 포인트컷메소드가 실행되면 around메소드가 실행되고
어라운드메소드에는 오브젝트로 포인트컷메소드를 담아야함
그리고 around메소드에서 proceed()를 호출해야 이때 포인트컷메소드가 실행된다.
(com.springbook.biz.common/AroundAdvice 예제 참고)

//JoinPoint : 포인트컷 메소드의 정보를 담는 클래스
//getSignature() : 포인트컷 메소드의 메소드명, 매개변수들의 정보를 가져옴.
//getName() : getSignature() 메소드가 가진 정보 중 메소드 명만 가져옴.
//getArgs() : getSignature() 메소드가 가진 정보 중 매개변수 정보만 가져옴.



어라운드 빼고 나머지 시점에서는 포인트컷메소드를 공통로직메소드의 매개변수에 JoinPoint로 받을 수 있다.
어라운드는 포인트컷메소드를 어라운드 공통로직메소드의 매개변수에 ProceedingJoinPoint로 받을 수 있다.

에프터리터닝은 aop설정에서 returning="robj" 를 설정해주고 에프터리터닝 공통로직메소드의 매개변수로 받을 수 있다.
에프터스로잉는 aop설정에서 throwing="exceptObj" 를 설정해주고 에프터스로잉 공통로직메소드의 매개변수로 받을 수 있다.




***************************************
classpath: => src/main/resources
***************************************


JdbcTemplate클래스 객체에서 제공되는 메소드

insert, delete, update 의 경우
"sql 쿼리문 문자열", "쿼리문 안의 바인드변수에 넣어야 할 값들을 직접 나열하거나, Object[] 자료형으로 모아서 넣을 수 있다."

<insert, delete, update>
=> int update(String sql, Object... args); //직접 나열하는 방법
=> int update(String sql, Object[] args); //배열로 담는 방법

<select(count(*) 데이터 1줄)>
=> int queryForInt(String sql);
=> int queryForInt(String sql, Object... args);
=> int queryForInt(String sql, Object[] args);

<select(ResultSet 데이터 1줄)>
=> Object queryForObject(String sql, RowMapper<T> rowMapper);
=> Object queryForObject(String sql, RowMapper<T> rowMapper, Object... args);
=> Object queryForObject(String sql, RowMapper<T> rowMapper, Object[] args);

<select(ResultSet 데이터 여러줄)>
=> List query(String sql, RowMapper<T> rowMapper);
=> List query(String sql, RowMapper<T> rowMapper, Object... args);
=> List query(String sql, RowMapper<T> rowMapper, Object[] args);

<**select(1줄, list모두)데이터 empty값 오류 예외처리 필요>
===========================================================
1. EmptyResultDataAccessException 또는 IncorrectResultSizeDataAccessException으로 예외처리 해 줄 것
2. jdbcTemplate.query(String sql, RowMapper<T> rowMapper).isEmpty()로 조건문 처리 할 것




<<스프링 프레임워크>>
스프링 프레임워크를 이용할 때는 정해진 규칙대로 진행해야 한다.
(**그림판, 노트필기 참조)

스프링 프레임워크에서는 artifact-id가 컨텍스트패스가 됨 (3단패키지중 마지막패키지)



<<Spring프레임워크의 MVC구조>>
- DispatcherServlet : 유일한 서블릿 클래스, 모든 클래스의 요청을 가장 먼저 처리하는 Front Controller이다.
- HandlerMapping : 클라이언트의 요청을 처리할 Controller를 매핑한다.
- Controller : 실질적인 클라이언트의 요청을 처리한다.
- ViewResolver : Controller가 리턴한 View이름으로 실행될 jsp경로를 완성해준다.
(경로가 외부에 노출되지 않도록 해주는 기능도 가지고 있다.)

차후 어노테이션 기반의 @Controller처리를 이용하면 해당 Controller객체에서 HandlerMapping과 Controller, View이름 설정까지 모두 처리를 한다.

DispatcherServlet로 설정할 수 있는 파일 => 스프링 빈 설정 파일(.xml)이면서 반드시 프레젠테이션레이어(presentationLayer)에 존재하는 스프링 빈 설정 파일이어야 한다.



import 		org.springframework.web.servlet.DispatcherServlet;


DispatcherServlet만들기

1. 프레젠테이션레이어단에 SpringBean Configuration File을 생성한다.
2. src/main/webapp/WEB-INF/web.xml파일에 dispatcherServlet객체를 생성하여 연결해준다.

형식 : 
<servlet>
	<servlet-name>객체명</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>스프링빈설정파일경로</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>객체명<servlet-name>
	<url-pattern>url패턴</url-pattern>
</servlet-mapping>


예 : 
<servlet>
	<servlet-name>action</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/config/presentation-layer.xml</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>action<servlet-name>
	<url-pattern>*.do</url-pattern>
</servlet-mapping>



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
<<*****스프링 프레임워크로 웹프로젝트를 만들때 순서>>

1. 필요한 라이브러리에 대한 dependency를 설정(추가)한다.
2. 필요한 .java 파일들을 만든다. (src/main/java폴더 안에 들어가는 파일들)
3. 프로퍼티스 파일, 스프링 빈 설정 파일들을 만든다. (프레젠테이션레이어, 비즈니스레이어 모두)
(=> 객체생성관련(데이터베이스객체, ...), 자동주입관련, aop관련, 등 설정)
4. webapp안의 view관련 파일들 생성 (jsp, css, js, html, 등등...)
5. WEB-INF안의 web.xml파일에 설정할 내용들 기술
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//89
//필기
//


***************************************
classpath: => src/main/resources
***************************************

***********************************************************************************
web.xml 설정 순서
1. 필터
2. 서블릿
3. 에러페이지
4. 웰컴파일리스트

스프링프레임워크의 기본 페이지이동 방식 => 포워딩 방식 (url이 바뀌지 않고, 데이터를 보냄)

스프링에서 제공하는 model(모델)객체는 request객체라고 생각하면 된다.
***********************************************************************************


<<web.xml로 서블릿 설정하기>>

<servlet>
	<servlet-name>서블릿명</servlet-name>
	<servlet-class>경로포함.클래스명</servlet-class>
</servlet>

<servlet-mapping>
	<servlet-name>사용할 서블릿명</servlet-name>
	<url-pattern>서블릿으로 처리할 url</url-pattern>
</servlet-mapping>

-------------------------------------------------------------------------------------------------------------------------------
+++++++++++++++예시: seven프로젝트++++++++++++++++++++++++++++++++++++++++++++++++++++
-------------------------------------------------------------------------------------------------------------------------------
<!-- business layer의 classpath경로에 있는 Spring Bean Configuration File연결하는 방법1 -->
<import resource="classpath:applicationContext.xml"/>

<!-- HandlerMapping 등록 -->
<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
	<property name="mappings">
		<props>
			<prop key="/login.do">login</prop>
			<prop key="/getBoardList.do">getBoardList</prop>
			<prop key="/getBoard.do">getBoard</prop>
			<prop key="/insertBoard.do">insertBoard</prop>
			<prop key="/updateBoard.do">updateBoard</prop>
			<prop key="/deleteBoard.do">deleteBoard</prop>
			<prop key="/logout.do">logout</prop>
		</props>
	</property>
</bean>

<!-- Controller 등록 -->
<bean id="login" class="com.springbook.view.user.LoginController"/>
<bean id="getBoardList" class="com.springbook.view.board.GetBoardListController"/>
<bean id="getBoard" class="com.springbook.view.board.GetBoardController"/>
<bean id="insertBoard" class="com.springbook.view.board.InsertBoardController"/>
<bean id="updateBoard" class="com.springbook.view.board.UpdateBoardController"/>
<bean id="deleteBoard" class="com.springbook.view.board.DeleteBoardController"/>
<bean id="logout" class="com.springbook.view.user.LogoutController"/>

<!-- ViewResolver 등록 -->
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="prefix" value="/WEB-INF/"/>
	<property name="suffix" value=".jsp"/>
</bean>
-------------------------------------------------------------------------------------------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-------------------------------------------------------------------------------------------------------------------------------


DispatcherServlet만들기

1. 프레젠테이션레이어단에 SpringBean Configuration File을 생성한다.
2. src/main/webapp/WEB-INF/web.xml파일에 dispatcherServlet객체를 생성하여 연결해준다.

형식 : 
<servlet>
	<servlet-name>객체명</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>스프링빈설정파일경로</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>객체명<servlet-name>
	<url-pattern>url패턴</url-pattern>
</servlet-mapping>


예 : 
<servlet>
	<servlet-name>action</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/config/presentation-layer.xml</param-value>
	</init-param>
</servlet>
<servlet-mapping>
	<servlet-name>action<servlet-name>
	<url-pattern>*.do</url-pattern>
</servlet-mapping>






**스프링프레임워크에서 제공하는 Resolver클래스로 객체를 만들 경우 정해진 객체명으로 만들어줘야 한다.

viewResolver객체를 생성하는 순간 모든 url은 해당 viewResolver객체를 거치게 된다.

그래서 viewResolver객체를 거치지 않게 하는 방법으로 
내가 리턴하는 url문자열의 맨 앞에 "redirect:"을 기술 해주어야 한다. (= 컨트롤러에서 url문자열을 기술할 때 맨 앞에 "redirect:"을 기술 해주어야 한다.)



********************************************
DispatcherServlet : 
요청과 응답의 전반적인 제어를 처리하는 스프링에서 유일한 서블릿 컨트롤러(= Front Controller, Main Controller)를 말함
- 유일한 서블릿 클래스, 모든 클라이언트의 요청을 가장 먼저 처리하는 Front Controller이다.

1. XmlWebApplicationContext 스프링컨테이너 구동


2. Spring Bean Configuration File들을 읽어서 객체 생성 및 설정 처리
=> Controller, DAO, HandlerMapping, ViewResolver객체, 등 생성
=> 의존성 주입 처리, DB객체 생성, 등
3. 요청과 응답에 대한 제어 관리
=> 핸들러맵핑, 컨트롤러 연결, 뷰리졸버 연결처리
----------------------------------------------------------------------------------

ContextLoaderListener 클래스
=> web.xml이 구동되면서 실행되는 서블릿컨테이너가 실행시키는 클래스
=> 기본적으로 설정이 되어 있는 것이 없으면 /WEB-INF/applicationContext.xml 파일을 읽어들인다. (없는 경우 에러남)
=> <context-param>태그로 설정한 Spring Bean Configuration 파일이 있으면 해당 파일을 읽어서 객체 생성 및 설정, 등을 처리한다.
=> 해당 컨테이너를 루트 컨테이너라고 한다.
----------------------------------------------------------------------------------

HandlerMapping : 
디스패쳐 서블릿에서 요청url을 핸들러 맵퍼에 보내면 해당 url에 맵핑이 되어 있는 Controller클래스를 찾아서 디스패쳐 서블릿으로 반환하는 기능을 담당함.
- 클라이언트의 요청을 처리할 Controller맵핑

Controller : 실질적인 클라이언트의 요청을 처리

ViewResolver :
- Controller가 리턴한 View이름으로 실행될 .jsp 경로 완성
요청이 모두 완료 된 후에 디스패쳐 서블릿에서 클라이언트로 응답을 완료하기 전, 어떤 페이지를 보내야 하는지 해당 페이지가 들어있는 경로를 찾아서 정확한 경로를 완성하여 디스패쳐 서블릿으로 보내는 기능을 담당함.

viewResolver객체를 생성하는 순간 모든 url은 해당 viewResolver객체를 거치게 된다.
그래서 viewResolver객체를 거치지 않게 하는 방법으로 
내가 리턴하는 url문자열의 맨 앞에 "redirect:"을 기술 해주어야 한다. (= 컨트롤러에서 url문자열을 기술할 때 맨 앞에 "redirect:"을 기술 해주어야 한다.)
"redirect:"를 사용하게 되면 페이지 이동방식도 리다이렉팅 방식으로 처리 됨. (데이터 못보냄, url 바뀜, 스프링프레임워크는 기본 페이지 이동방식이 포워딩방식임)

형식 :
<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="prefix" value="/맨 앞에 붙일 url 경로 기술/"/>
	<property name="suffix" value="맨 뒤에 붙일 url 경로 기술"/>
</bean>
----------------------------------------------------------------------------------

ModelAndView 클래스 : 
Controller에서 처리한 데이터를 Model객체에 담고, 응답할 경로 및 페이지 이동방식을 지정하는 역할을 함.
**반드시 해당 클래스로 객체 생성을 하여 사용할 수 있다.
ModelAndView mav = new ModelAndView();

=> 해당 클래스로 만든 객체는 request객체로 만들어진다.
=> ***해당 객체를 통해 mav.addObject(key, value) 메소드를 지정하는 것은 *request.setAttribute(key, value); 로직과 동일한 기능을 한다.***

=> 데이터 담기 형식 : 모델앤뷰객체명.addObject(key, value);
=> url경로 설정 및 페이지 이동방식 설정 형식 : 모델앤뷰객체명.setViewName("[redirect:]url경로 기술");

Model : 데이터를 저장하는 역할 => request객체
View : 응답을 보낼 url의 전체경로 또는 ViewResolver로 보낼 일부 경로를 기술, 페이지 이동방식(포워딩 또는 리다이렉팅)을 지정
----------------------------------------------------------------------------------

스프링프레임워크에서 제공하는 인코딩필터 생성하기
객체명 : characterEncoding
클래스 : org.springframework.web.filter.CharacterEncodingFilter
파라미터명 : encoding, 파라미터값 : UTF-8
url-pattern : *.do
----------------------------------------------------------------------------------


***WEB-INF : 절대 외부에서 직접 접근할 수 없다. 페이지 이동은 포워딩으로만 접근 할 수 있다.




스프링컨테이너 (서블릿컨테이너) : 
1. 객체명 : boardDAODBCP		자료형 : BoardDAODBCP			자동주입 : jdbcTemplate
2. 객체명 : boardService		자료형 : BoardServiceImpl, BoardService	자동주입 : boardDAODBCP
3. 객체명 : userDAODBCP		자료형 : UserDAODBCP			자동주입 : jdbcTemplate
4. 객체명 : userService		자료형 : UserServiceImpl, UserService		자동주입 : userDAODBCP
5. 객체명 : dataSource		자료형 : BasicDataSource			
6. 객체명 : jdbcTemplate		자료형 : JdbcTemplate			



-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
-----------------------------------------------------------------------------------------------------------

유알엘패턴 / 컨텍스트패스가 있습니다

a태그, form태그의 액션속성, 자바스크립트에 태그(location.href='')의 / 컨텍스트패스를 없애라

-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------


------------------------------------------------------------
a태그의 href속성
form태그의 action속성
javascript의 location.href로 설정하는 url
response.sendRedirect로 설정하는 url
ajax에서 설정하는 url값

=> /의 의미 : contextPath를 삭제하라는 의미
=> ./의 의미 : 나와 동일한 위치라는 의미
------------------------------------------------------------

------------------------------------------------------------
서블릿이나 필터에 처리하는 url패턴형식
RequestDispatcher로 설정하는 url패턴형식

=> /의 의미 : 앞에 contextPath까지 존재한다는 의미
------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------




스프링프레임워크 프로젝트 만드는 순서

1. dependency 추가
2. java파일들 생성
3. 프로퍼티스 파일, 스프링 빈 설정 파일 생성
4. view (persentation-layer에 관련된 파일들 생성), html, jsp, css, js, ... 등등
5. web.xml안에 들어갈 내용 기술




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//90
//필기
//


프레젠테이션단과 비즈니스레이어단의 스프링빈설정파일 연결 방법 

1. 프레젠테이션단에서 import로 읽어들이는 방법
2. web.xml에서 컨텍스트-파람 + 리스트너 태그를 이용하는 방법
  	<context-param>
  		<param-name>contextConfigLocation</param-name>
  		<param-value>classpath:applicationContext.xml</param-value>
  	</context-param>
	<필터 기술>
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>



@RequestMapping : 핸들러맵퍼 기능
예: @RequestMapping("url") => 해당 url로 요청이 들어오면 get방식이든, post방식이든 달린 메소드를 실행함
정식형식 : @RequestMapping(value = [ { ] "url1" [ , "url2" ][ , method = RequestMethod.POST] )
속성이 2개 이상이면 반드시 정식형식으로 기술 해야함
리퀘스트객체를 자동으로 생성함
달린 메소드의 리턴값에 url이 있으면 페이지를 이동시켜줌


@GetMapping : 
@GetMapping(value = "/login.do") == @RequestMapping(value = "/login.do", method = RequestMethod.GET)
리퀘스트객체를 자동으로 생성함


@PostMapping : 
@PostMapping(value = "/login.do") == @RequestMapping(value = "/login.do", method = RequestMethod.POST)
리퀘스트객체를 자동으로 생성함



컨트롤러 객체 안에 있는 맵핑어노테이션 객체 안에 메소드의 매개변수 => 커맨드 객체(command object)

커맨드 객체(command object) : 클라이언트에서 보내는 데이터를 자동으로 맵핑시켜 데이터를 담아오는 객체 (매개변수 vo)



@RequestParam(value = "파라미터명"[ , defaultValue = "값", required = false ])
value에 정해진 이름의 파라미터가 있으면 가져오고 없으면 생성, 
(required = false) - 이 이름의 파라미터를 전송해도 되고 안해도 되고 
(defaultValue = "값") - value이름의 파라미터가 없으면 해당값으로 값을 지정함



// request객체에 Attribute로 담기위한 정식형식
model.addAttribute("객체명", 값);
// 위치 : 데이터를 담아야 하는 곳에


@ModelAttribute("객체명") 객체선언문
// 위치 : 매개변수의 선언문 앞에


=> 둘다 request.setAttribute("객체명", 값); 과 같음





@SessionAttributes("board") : 
@SessionAttributes는 객체를 미리 생성할 수 없다.
반드시 model.addAttribute("객체명", 값)으로 되어있는 정식 형식으로 만든 model객체가 실행이 되어야만 그때 객체가 생성된다.

@SessionAttributes("board") => 현재 null인 상태

model.addAttribute("board", 값) => 세션에 설정된 이름과 동일한 이름으로 만들어진 model정식 객체가 있으면 그때 SessionAttribute는 new를 실행하여 데이터를 담을 공간을 생성한다. (@ModelAttribute("board")는 new 발생을 시키지 못한다.)
동일한 이름의 model.addAttribute로 생성된 객체 정보를 그대로 똑같이 복사해서 데이터를 담는다.


=> 이후 부터는 동일한 이름의 model객체와 session객체는 상호감시가 이루어진다.




@SessionAttributes("board") => 현재 null인 상태
session.attribute("board", null);

<<model.addAttribute("board", boardService.getBoard(vo)) 하는 일 >>
: 동일한 이름의 세션객체를 new발생시켜 공간을 할당받고, 데이터를 전달하는 기능까지 가지고 있다.
1. request에 attribute로 board객체를 생성하고 값으로 boardService.getBoard(vo)를 담는다.
2. 자신과 동일한 이름을 가진 session객체를 찾아서 new를 발생시킨다.
session.attribute("board", new ~);
공간이 생성되면 request에 담은 board객체의 데이터를 그대로 복사해서 세션객체에 담는다.
session.attribute("board", boardService.getBoard(vo));


@ModelAttribute("board") BoardVO vo : 동일한 이름의 세션에 데이터를 전달하는 기능만 가지고 있다. new 발생은 시키지 못한다.




@ModelAttribute("객체명")
=> @Controller 클래스 안의 메소드단에 @ModelAttribute("객체명")가 있으면 @Controller 클래스 안의 메소드가 호출 될때 @ModelAttribute("객체명")가 있는 메소드가 먼저 실행된다.





-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
-----------------------------------------------------------------------------------------------------------

유알엘패턴 / 컨텍스트패스가 있습니다

a태그, form태그의 액션속성, 자바스크립트에 태그(location.href='')의 / 컨텍스트패스를 없애라

-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------


------------------------------------------------------------
a태그의 href속성
form태그의 action속성
javascript의 location.href로 설정하는 url
response.sendRedirect로 설정하는 url
ajax에서 설정하는 url값

=> /의 의미 : contextPath를 삭제하라는 의미
=> ./의 의미 : 나와 동일한 위치라는 의미
------------------------------------------------------------

------------------------------------------------------------
서블릿이나 필터에 처리하는 url패턴형식
RequestDispatcher로 설정하는 url패턴형식

=> /의 의미 : 앞에 contextPath까지 존재한다는 의미
------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------




===========================================================

스프링프레임워크 프로젝트 만드는 순서

1. dependency 추가
2. java파일들 생성
3. 프로퍼티스 파일, 스프링 빈 설정 파일 생성
4. view (persentation-layer에 관련된 파일들 생성), html, jsp, css, js, ... 등등
5. web.xml안에 들어갈 내용 기술

===========================================================



내가 데이터를 담아가거나 전송하기 위해 필요한 것 => controller
controller를 타기 위해 필요한 것 => url-pattern
url-pattern을 설정하기 위해 필요한 것 => servlet
servlet을 만들기 위해 필요한 것 => 스프링 빈 설정 파일
스프링 빈 설정 파일을 만들기 위해 필요한 것 => 객체생성, 자동주입에 관련된 클래스 생성




<<스프링프레임워크 파일업로드 방법>>
파일업로드로직에 필요한 선수작업 : commons-fileUpload, commons-io 이용할 예정

1. 형상관리파일(pom.xml)에 dependenct commons-fileUpload 관련 설정만 추가할 것

<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>

2. Spring Bean Configuration File에 파일업로드 객체 생성하기
생성 전 BoardVO클래스에 해당 file객체에 대한 멤버필드와 filename을 받을 멤버필드를 추가해준다. (getter, setter 포함)
=> 
private MultipartFile uploadFile;
private String filename;-

형식 : id="multipartResolver"는 반드시 이 이름으로 지정해주어야 한다. 이름을 변경하거나 다른 이름으로 지정 안됨.

<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	<property name="maxUploadSize" value="500000"></property>
	// setMaxUploadSize => 업로드할 파일들의 최대 용량을 지정하는 메소드
</bean>

3. jsp파일에 input type="file" 태그 기술
form태그의 method="post"으로 설정, enctype="multipart/form-data"으로 설정할 것

4. Controller객체에 있는 insertBoard메소드 안에 파일업로드 로직을 구현한다.

5. BoradRowMapper클래스에 filename이름 가져오는 로직 추가, board테이블에 filename컬럼 추가
alter table board add filename varchar(500);

6. BoardDAODBCP클래스의 insert, delete, getBoard, 등의 로직에 filename에 대한 로직 추가 구현하기




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//91
//필기
//


-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
-----------------------------------------------------------------------------------------------------------

유알엘패턴 / 컨텍스트패스가 있습니다

a태그, form태그의 액션속성, 자바스크립트에 태그(location.href='')의 / 컨텍스트패스를 없애라

-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------


------------------------------------------------------------
a태그의 href속성
form태그의 action속성
javascript의 location.href로 설정하는 url
response.sendRedirect로 설정하는 url
ajax에서 설정하는 url값

=> /의 의미 : contextPath를 삭제하라는 의미
=> ./의 의미 : 나와 동일한 위치라는 의미
------------------------------------------------------------

------------------------------------------------------------
서블릿이나 필터에 처리하는 url패턴형식
RequestDispatcher로 설정하는 url패턴형식

=> /의 의미 : 앞에 contextPath까지 존재한다는 의미
------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url
-----------------------------------------------------------------------------------------------------------



===========================================================

스프링프레임워크 프로젝트 만드는 순서

1. dependency 추가
2. java파일들 생성
3. 프로퍼티스 파일, 스프링 빈 설정 파일 생성
4. view (persentation-layer에 관련된 파일들 생성), html, jsp, css, js, ... 등등
5. web.xml안에 들어갈 내용 기술

===========================================================



<<스프링프레임워크 파일업로드 방법>>
파일업로드로직에 필요한 선수작업 : commons-fileUpload, commons-io 이용할 예정

1. 형상관리파일(pom.xml)에 dependenct commons-fileUpload 관련 설정만 추가할 것

<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>

2. Spring Bean Configuration File에 파일업로드 객체 생성하기
생성 전 BoardVO클래스에 해당 file객체에 대한 멤버필드와 filename을 받을 멤버필드를 추가해준다. (getter, setter 포함)
=> 
private MultipartFile uploadFile;
private String filename;

형식 : id="multipartResolver"는 반드시 이 이름으로 지정해주어야 한다. 이름을 변경하거나 다른 이름으로 지정 안됨.

<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	<property name="maxUploadSize" value="500000"></property>
	// setMaxUploadSize => 업로드할 파일들의 최대 용량을 지정하는 메소드
</bean>

3. jsp파일에 input type="file" 태그 기술
form태그의 method="post"으로 설정, enctype="multipart/form-data"으로 설정할 것

4. Controller객체에 있는 insertBoard메소드 안에 파일업로드 로직을 구현한다.

5. BoradRowMapper클래스에 filename이름 가져오는 로직 추가, board테이블에 filename컬럼 추가
alter table board add filename varchar(500);

6. BoardDAODBCP클래스의 insert, delete, getBoard, 등의 로직에 filename에 대한 로직 추가 구현하기






<<스프링프레임워크 아작스>>

제이쿼리 라이브러리
제이슨심플 라이브러리
젝슨 라이브러리 (제이슨배열, 제이슨오브젝트 간소화)


ajax 데이터 주고 받기

1. jackson-databind 라이브러리 추가하기
artifactId : jackson-databind // version : 2.12.6
- POJO기반의 데이터를 js에서 받아들일 수 있는 json데이터로 변환해준다.

2. presentation layer단의 Spring Bean Configuration파일에 mvc네임스페이스를 추가해준다.

3. presentation layer단의 Spring Bean Configuration파일에 
<mvc:annotation-driven /> 태그를 추가해준다.
**반드시 persentation layer단에 추가할 것.
business layer단의 Spring Bean Configuration파일에 추가하는 경우 제대로 실행이 안될 수 있다.

데이터를 웹페이지로 내보내는 것으로 presentation layer단을 기본으로 인식한다.
이 태그가 있어야 @ResponseBody어노테이션이 적용된다.

4. ajax데이터를 받는 맵핑메소드의 @RequestMapping어노테이션의 위나 아래에 @ResponseBody어노테이션을 기술해 주어야 한다.

@ResponseBody => 해당 메소드의 return부를 제이슨객체로 파싱해서 success함수의 매개변수에 보내줌

============================================================================
아작스(Ajax)란 : 
페이지 전체를 모두 로딩하지 않고 필요한 부분에 대해서만 갱신을 할 수 있도록 하는 기술을 의미함.
데이터는 json방식의 데이터, xml데이터, html데이터, text파일 등을 주고 받을 수 있다.

**단, 다른 서버로의 전송은 해당 서버에 권한이 없는 경우 데이터를 주고 받을 수 없다.
**이진데이터(바이트 형식의 데이터)를 주고 받을 수 없다. (.class파일 못읽음)
**반드시 요청은 서버로만 보낼 수 있다.


javascript방식 (XMLHttpRequest객체 사용)
jQuery방식 ($.ajax() 함수 사용)

비동기통신이 이루어지는 순서
1. 클라이언트의 요청 (비동기통신에 필요한 객체 생성 및 연결, 전송까지 포함)
2. 서버에서의 응답
3. 클라이언트에 응답 도착 (비동기통신 적용)

[ javascript방식 ]
1. XMLHttpRequest객체 생성
예: var xhttp = new XMLHttpRequest();

2. 서버로 보낼 요청 데이터의 타입 설정 및 연결 : open()
예: xhttp.open("데이터전송방식", "요청url주소", 비동기여부);
데이터전송방식 : GET, POST
요청url주소 : /test.do 등
비동기여부(비동기화여부=async) : true, false 중 선택
(true : 비동기방식, false : 동기방식)

3. 서버로 데이터 전송하기 : send();
예: xhttp.send(); 또는 xhttp.send(보낼데이터가 있는 경우 데이터를 담을 수 있다.);

**readState 속성 : 객체의 상태를 나타내는 속성
- 0 (UNSET) : 비동기객체가 생성된 상태
- 1 (OPEND) : open()메소드가 정상적으로 실행된 상태
- 2 (HEADERS_RECEIVED) : 데이터가 서버로 모두 send되어 해당 요청의 응답이 도착만 된 상태
- 3 (LOADING) : 데이터를 클라이언트의 브라우저로 응답하기 위해 준비하는 처리 단계
- 4 (DONE) : 요청한 데이터가 모두 응답할 준비가 된 상태

**status 속성 : 응답 결과 상태를 나타내는 코드값
예시 : 
- 200 : 정상 (요청 정보가 존재한다는 의미)
- 404 : 비정상 (요청 페이지가 존재하지 않는다는 의미)
... 등등

**onreadystatechange 속성 : 비동기 객체의 상태가 변경이 될 때마다 실행되는 속성
============================================================================


*************
@ResponseBody => 해당 메소드의 return부를 자바스크립트로 받을수 있게 자동변환하여 
		  아작스의 success함수의 매개변수로 보내줌
*************

============================================================================




<<MyBatis>>

================================
<mapper namespace="BoardDAO">
  <select id="selectBlog" resultType="com.springbook.biz.board.BoardVO">
    SELECT * FROM BOARD WHERE SEQ = #{seq}
  </select>
</mapper>
================================

<mapper>
namespace => 맵퍼객체명

<select>
id => 쿼리문객체명
resultType => 패키지경로포함 클래스명(vo클래스)

마이바티스 바인드변수 처리 => #{ }

================================


<!-- MyBatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.7</version>
</dependency>

<!-- MyBatis-Spring -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.0.6</version>
</dependency>




<<MyBatis>>
자바와 데이터베이스를 연결해주는 연동 프레임워크 중 하나임.
원래 Apache에서 개방되어 iBatis라는 프레임워크였으나 Google이 인수하면서 Mybatis로 명칭 변경됨.

- 간단한 자바코드로 데이터베이스 연동을 처리할 수 있다.
- SQL명령을 자바소스코드에서 분리하여 XML파일로 관리함.

1. mybatis 라이브러리 추가하기
artifactId : mybatis / version : 3.5.7
artifactId : mybatis-spring / version : 2.0.6

<!-- MyBatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.7</version>
</dependency>

<!-- MyBatis-Spring -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.0.6</version>
</dependency>

2. 비지니스 레이어단에 XML File 선택 후 파일이름.xml입력 후 생성

3. Mapper XML파일 만들기
https://blog.mybatis.org/ 접속 -> Products탭 클릭 
-> Products 테이블의 Project컬럼의 MyBatis 3에 대응되는 Links컬럼의 값 중 docs 글씨를 클릭한다.
-> 좌측 메뉴에서 두번째의 Getting Strated 메뉴 클릭
-> Exploring Mapped SQL Statements 부분에 있는 소스코드만 복사해서 붙여넣기 한다.
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
  <select id="selectBlog" resultType="Blog">
    select * from Blog where id = #{id}
  </select>
</mapper>

-> mapping파일은 Mapper XML Files메뉴 참고, configuration 파일은 Configuration XML 메뉴를 참고하면 된다.

4. Config File 만들기
-> https://blog.mybatis.org/ 접속 -> Products탭 클릭 
-> Products 테이블의 Project컬럼의 MyBatis 3에 대응되는 	Links컬럼의 값 중 docs 글씨를 클릭한다.
-> 좌측 메뉴에서 두번째의 Getting Strated 메뉴 클릭
-> Building SqlSessionFactory from XML 에서 소스 복사
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="${driver}"/>
        <property name="url" value="${url}"/>
        <property name="username" value="${username}"/>
        <property name="password" value="${password}"/>
      </dataSource>
    </environment>
  </environments>
  <mappers>
    <mapper resource="org/mybatis/example/BlogMapper.xml"/>
  </mappers>
</configuration>
=========================================
2~4번의 다른 방법 

	1. https://sourceforge.net/projects/java-orm-plugin/

	2. Java ORM Plugin for Eclipse > Download > JavaORMPlugin.zip파일(69kb) 다운로드 

	3. zip파일 압축 해제 > JavaORMPlugin/plugins > JavaORMPlugin_1.0.0.201411180016.jar 만 복사

	4. C:/sts-bundle/sts-3.9.17.RELEASE/plugins 폴더 안에 JavaORMPlugin_1.0.0.201411180016.jar파일

	   붙여넣기
=========================================




--------------------------------------------------------------------------------------------------------------------------------------------------
//
//92
//필기
//


비지니스 레이어단의 스프링빈설정파일에 기술

	<!-- MyBatis -->
	<!-- 여기서 마이바티스 mapper, config 파일 둘 다 읽음 -->
	<bean id="sqlsession" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="configLocation" value="classpath:sql-map-config.xml" />
	</bean>




<resultMap type="내가 처리할 자료형(config파일의 typeAlias)" id="객체명">

	// id태그는 해당 테이블의 primary key로 지정된 컬럼 기술
	<id property="해당 컬럼과 동일한 vo멤버필드(대소문자 가림)" column="컬럼명(대문자 권장-db는 대소문자 안가리기 때문)" />
	// 사용할 컬럼 추가시 result태그로 기술
	<result property="해당 컬럼과 동일한 vo멤버필드(대소문자 가림)" column="db컬럼명" />



<<마이바티스 메소드구현 방법>>
//1. 마이바티스 객체(데이터베이스(MariaDB)정보, sql정보, 마이바티스정보) 자동주입 처리
@Autowired
SqlSessionTemplate mybatis;

//2. 컨트롤러객체로 실행될 메소드 기술 후 sql문 실행 메소드 형식
예(insert) : mybatis.insert("맵퍼네임스페이스.sql태그id"[ , 컨트롤러에서 받은 매개변수 ]);





클라이언트가 보는 view페이지(.html 또는 .jsp파일이 html로 컴파일 된 페이지)에서 요청(url)이 들어오면
요청url패턴을 들고 Filter객체 먼저 들림 (*url패턴 설정)
요청url패턴을 들고 Servlet객체 들림, 요청url패턴에 해당하는 Controller객체를 찾아줌 (*url패턴 설정)
Controller객체에서 Service객체의 메소드를 호출(일을 시킴) (*Service객체 생성)
Service객체에서 sql문이 연결된 DAO객체의 메소드를 호출 (*DAO객체 생성)
DAO객체에서 데이터베이스의 sql문을 실행하기 위한 데이터베이스정보를 담고 있는 **Mybatis객체 생성, 
Mybatis객체 생성 후 <<마이바티스 메소드구현 방법>>으로 기술



***
Mybatis객체를 이용하기 위해 비즈니스레이어단에 객체를 생성해야함
Mybatis객체는 org.mybatis.spring.SqlSessionTemplate으로 만들어야 하는데 
먼저 여기에 데이터베이스객체와 Mybatis설정파일을 담아야 해서 
이 두가지를 담을 객체 생성 - 자료형은 org.mybatis.spring.SqlSessionFactoryBean이고 객체명은 sqlsession으로
해당 객체의 프로퍼티로 dataSource(데이터베이스객체)와 configLocation(Mybatis설정파일-classpath:sql-map-config.xml)을 기술
(*DataBase연결 객체 생성, *Mybatis Configuration 객체 생성)
(*Mybatis Configuration안에 Mybatis Mapper객체(SQL쿼리문)를 연결해야하므로 *Mybatis Mapper 객체 생성)
그리고
이 객체를 담는
<bean class="org.mybatis.spring.SqlSessionTemplate">
	<constructor-arg ref="sqlsession" />
</bean> 를 비즈니스레이어단에 생성.
*************



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//93
//필기
//


프젝회의

--------------------------------------------------------------------------------------------------------------------------------------------------
//
//94
//필기
//



url패턴
? => 한 문자와 일치
* => 경로 세그먼트 내에서 0개 이상의 문자와 일치
** => 경로 끝까지 일치하는 0개 이상의 경로 세그먼트
★★★참고★★★: *과 달리 **는 AntPathMatcher패턴 **끝에서만 지원된다.
/pages/{**} 가능
/pages/{**}/details 불가능

예시
1.  /pages/t?st.html 패턴인 경우 :  
예시:  /pages/test.html(일치)  /pages/tXst.html(일치) /pages/toast.html(불일치)

2. /resources/*.png 패턴인 경우 : /resources/ 디렉토리안에 있는 모든 .png파일과 일치

3. /resources/** 패턴인 경우 :  /resources/ 디렉토리를 포함하여 모든 파일 및 하위 경로안에 있는 폴더 파일까지 모두
예시:  /resources/image.png 또는  /resources/css/spring.css




<<레스트풀api 예제 web.xml>>

	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

	<!-- 서블릿은 최초 요청이 들어올때 초기화 된다. -->
	<!-- 그래서 맨처음 호출한 서블릿을 호출한 유저는 보통 시간보다 시간이 오래걸리는데, -->
	<!-- 이것을 방지하는 방법이 load-on-startup 태그이며, 숫자가 0보다 크면 서버가 스타트되면서 서블릿을 초기화 한다. -->
	<!-- 대부분 숫자는 0이나 1을 사용한다. 0은 default값(서블릿이 호출될때 초기화진행)으로 생략가능하다. -->



디폴트 서블릿 실행이 톰캣서버의 디폴트 서블릿으로 실행되는게 아니라
내가 설정한 서블릿으로 실행하는 방법
1. 톰캣설정에서 path를 "/"로 바꿔준다.



css, js, img, 등 서블릿을 타지 않아야 하는 파일들을 걸러주는 작업이 필요
1. WEB-INF안에 resources폴더를 만들고 이 안에 모아준다.
2. 프레젠테이션 레이어단 스프링 빈 설정 파일에 <resources mapping="" location="" /> 태그 기술
**
<resources 
mapping="location속성의 별칭(url-pattern처럼 별칭으로 타야함)/(** = 앞경로 다음에 폴더일 경우, * = 앞경로 다음에 파일일 경우)" 
location="(/ = 컨택스트패스가 있음)걸러줄 파일 경로" />







url => http://localhost:8090/biz/test.do?id=admin
contextpath => http://localhost:8090/biz
path => /test.do
파라미터 => ?id=admin


<<레스트풀 api방식>>
 : url주소를 통해서 자원을 주고받는 방법.
pathvariable => 보안을 높히고 url을 새로 재정의한다.

pathvariable을 설정하면 예를들어 /test.do/id/admin/...


Pathvariable 예제  /pathvar/page/two, /pathvar/page/one, 등
형식 : 
// ( /pathvar/page/one )
1. url을 받는 controller에서 @RequestMapping("/pathvar/page/{var}") 식으로 설정
2. public String page(@PathVariable("var") String v) { 식으로 매개변수로 설정
[2. public String page(@PathVariable String var) { 식으로 매개변수로 설정]
3. 매개변수 String v가 "one"을 받게 됨
4. 해당 메소드 실행부에서 if (v.equals("one"))  returnUrl = "pathvar/page1"; 식으로 경로설정을 한다.





<<인터셉터란(interceptor)>>
컨트롤러(Controller)의 '핸들러(Handler)'를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할수 있는 객체

interceptor 란 단어는 '낚아채다'라는 의미이다. 
해당 단어의 의미와 같이 사용자 요청에 의해 서버에 들어온 Request 객체를
컨트롤러의 핸들러(사용자가 요청한 url에 따라 실행되어야 할 메서드, 이하 핸들러)로 도달하기전에 낚아채서 개발자가 원하는 추가적인 작업을 한후 핸들러로 보낼수 있도록 해주는것이 인터셉터 이다.
(**추가적인 작업으로는 로그인체크, 권한 체크 등이 있다.)

1) preHandle()
컨트롤러가 호출되기 전에 실행됨
컨트롤러가 실행 이전에 처리해야 할 작업이 있는경우 혹은 요청정보를 가공하거나 추가하는경우 사용
실행되어야 할 '핸들러'에 대한 정보를 인자값으로 받기때문에 '서블릿 필터'에 비해 세밀하게 로직을 구성할수 있음
리턴값이 boolean이며, 
리턴 값이 true 인 경우: 실행되어야 하는 컨트롤러로 돌려준다.
false인 경우 컨트롤러와 남은 인터셉터를 중단.

2) postHandle()
핸들러가 실행은 완료 되었지만 아직 View(대부분 jsp파일들)가 생성되기 이전에 호출된다.
ModelAndView 타입의 정보가 인자값으로 받는다. 
따라서 Controller에서 View 정보를 전달하기 위해 작업한 Model 객체의 정보를 참조하거나 조작할수 있다.
preHandle() 에서 리턴값이 false인경우 실행되지않음.
적용중인 인터셉터가 여러개 인경우, preHandle()는 역순으로 호출된다.
비동기적 요청처리 시에는 처리되지않음.



인터셉터가 구동이 되려면 컨트롤러가 발동되는 url요청이 들어와여 한다.
인터셉터 => url요청이 들어오면 서블릿을 거쳐 컨트롤러로 가기 전에 들리는 곳

내가 처리한 요청에 대해서 필요에 따라 막아내기 위함.

예를들어 로그인 했을때 맞지 않는 데이터일때 컨트롤러로 못가게 하는 작업이 많이 쓰임
맞는 데이터가 들어오면 ture
맞지 않는 데이터가 들어오면 false


형식 : 
	<interceptors>
		<interceptor>
			<mapping path="/*" />
			<mapping path="/main*" />
			<mapping path="/join*" />
			<exclude-mapping path="/login*" />
			<exclude-mapping path="/join*" />
			<exclude-mapping path="/home*" />
			<exclude-mapping path="/front/**" />
			<exclude-mapping path="/resources/" />
			<exclude-mapping path="/pathvar/**" />
			<beans:bean class="com.my.web.interceptor.Interceptor" />
		</interceptor>
	</interceptors>

	<mapping path="/*" />
	mapping => 해당경로로 url요청이 들어오면 무조건 인터셉터를 타라는 태그

	<exclude-mapping path="/login*" />
	exclude-mapping => 해당 경로로 url요청이 들어오면 인터셉터를 타지말라는 태그

	<beans:bean class="com.my.web.interceptor.Interceptor" />
	마지막에 인터셉터 객체 생성까지

/main* => main으로 시작되는 파일 하나
/pathvar/** => pathvar폴더 밑에 모든 





--------------------------------------------------------------------------------------------------------------------------------------------------
//
//95
//필기
//



스프링-SECURITY-WEB  암호화 사용시

스프링 프레임워크 버전이랑 스프링-SECURITY-WEB 버전 맞아야함


Spring Security Web » 5.2.15.RELEASE 
https://mvnrepository.com/artifact/org.springframework.security/spring-security-web/5.2.15.RELEASE


--------------------------------------------------------------------------------------------------------------------------------------------------
//
//96
//필기
//


httpclient 디펜던시

https://github.com/ddj82/bichena.git




<<깃>>

( '~' => home directory : c:/Users/계정명)
사용자명@사용자 장치명 MINGW64 ~ 
$

현재 디렉토리 검색 : pwd
ls => 경로 안의 파일
ls -l => 경로 안의 파일 상세히
ls -a => 경로 안의 파일, 숨긴 파일까지
ls -la => 경로 안의 파일, 숨긴 파일까지 상세히

(drwxr-xr-x)
(lrwxrwxrwx)
(-rw-r--r--)
d => 디렉토리
l => 링크파일
- => 파일
소유주 권한
그룹선택자 권한
다른사용자 권한

권한
r : 읽기권한
w : 쓰기권한
x : 실행권한


cd => 체인지 디렉토리
cd .. => 상위 경로로 이동
cd ~ => 홈 디렉토리로

mkdir => 폴더 만들기

vim 실행할 파일.확장자명까지
a, i => 편집내용, 수정만 가능
esc => 실행모드로, 저장 삭제 가능

실행모드에서 
:w => 저장
:q => 나가기
:wq => 저장, 나가기
:q! => 수정한내용 저장 안하고 나가기






작업영역 > 스테이징 > 커밋영역



원격저장소 생성
git remote add 원격저장소이름 깃허브주소

원격저장소 목록보기
git remote -v


wlalqjrj@gmail.com


http://localhost:8090/ko/prodInsertEditer.jsp


-0510 수정-
main.jsp

로그인컨트롤러 
loginAD.ko

비채나컨트롤러 
admin2.ko, adminLoginPage.ko, adminProdDetail.ko, productDetailpage.ko, prodInsertEditer.ko
adminProdList.ko

어드민폴더
adminLogin.jsp
adminMain2.jsp
adminProdInsert.jsp
adminProdOneView.jsp

adminProdView.jsp



--------------------------------------------------------------------------------------------------------------------------------------------------
//
//112
//필기
//


<<리액트>>

<노드설치>
https://nodejs.org/
이유 리엑트프로젝트는 노드를 통해 노드에서 사용할수있는 관리자(패키지)가 필요하기때문


노드에서 제공하는 패키지 관리자
npm(node package manager) : 노드 패키지 관리자
npx : npm의 확장판 패키지 관리자
pnpm : 가장 최신에 나온 npm보다 2배 빠른 패키지 관리자
nvm, 등등

yarn : 2016년에 페이스북에서 만든 패키지 관리자


<노드 패키지 설치 위치>
C:\Users\사용자명\AppData\Roaming\npm


<cmd로 패키지 설치>
C:\Users\hi>npm --version
10.5.2

C:\Users\hi>npm -v
10.5.2

C:\Users\hi>npm install --global yarn {패키지 설치}

added 1 package in 1s

C:\Users\hi>npm update {버전 업데이트}

up to date in 563ms

C:\Users\hi>npm install --global pnpm

added 1 package in 2s

1 package is looking for funding
  run `npm fund` for details

C:\Users\hi>npm uninstall --global pnpm {패키지 제거}

removed 1 package in 689ms

C:\Users\hi>npm dedupe {중복된 패키지 정리해줌}

up to date in 560ms



<<넥스트 프레임워크로 프로젝트 생성(포트번호-3000)>>
<<[C:\rwork>npx create-next-app@latest]>>

c:\rwork>npx create-next-app@latest
√ What is your project named? ... first_app
√ Would you like to use TypeScript? ... [No] / Yes
√ Would you like to use ESLint? ... No / [Yes]
√ Would you like to use Tailwind CSS? ... [No] / Yes
√ Would you like to use `src/` directory? ... No / [Yes]
√ Would you like to use App Router? (recommended) ... [No] / Yes
√ Would you like to customize the default import alias (@/*)? ... [No] / Yes
Creating a new Next.js app in c:\rwork\first_app.

Using npm.

Initializing project with template: default


Installing dependencies:
- react
- react-dom
- next

Installing devDependencies:
- eslint
- eslint-config-next

npm WARN deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.
npm WARN deprecated rimraf@3.0.2: Rimraf versions prior to v4 are no longer supported
npm WARN deprecated glob@7.2.3: Glob versions prior to v9 are no longer supported

added 309 packages, and audited 310 packages in 32s

125 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
Initialized a git repository.

Success! Created first_app at c:\rwork\first_app




이미지, 영상 등 파일 위치
>>public폴더



<함수형 컴포넌트 형식> 
//리턴문에선 html태그들을 빈태그(<></>)로 묶어줘야함

형식1 : 
function App(){
   //변수 설정 가능
   return(
      <>
         이 안에 html태그 기술
      </>
   );
}

형식2 : 
const App = () =>{
   return(
      <>
         이 안에 html태그 기술
      </>
   );
}



**반드시 return() 함수안에는 1개의 엘리먼트로 묶어서 기술해야함.
return(
<>
<h1>안녕</h1>
<p>하이</p>
</>
);



**렌더링이란 : 
사용자인터페이스(UI : User Interface)의 업데이트와 관련된 프로세스를 말하며, 상태(State)가 변경될 때마다 UI를 업데이트 해야 한다. 이때, 리액트는 변경된 상태를 기반으로 UI의 특정 부분을 다시 그리는 과정을 거치는데, 이 과정을 "렌더링"이라고 한다.


**명명규칙
함수 : 파스칼기법(첫글자 대문자, 결합단어 첫글자 대문자)
속성, 변수, 이벤트핸들러 : 카멜기법(첫글자 소문자, 결합단어 첫글자 대문자)

예)
이벤트핸들러 : onclick(X) => onClick(O)
속성 : class(X) => className(O)
**반드시 엘리먼트의 시작과 종료가 존재해야 한다.
<br>(X) => <br /> (O)

자바스크립트의 표현식 : {} (jsp의 EL이랑 비슷)
ex : {속성값} => {props.name}
{함수호출문} => {getName()}
{연산식} => {tf == true ? "참" : "거짓"}





<<비트(Vite)빌드 도구로 프로젝트 생성(포트번호-5173)>>

npm create vite@latest
? Project name : vi_first_app
Select a framework : > React 선택
Select a variant : > JavaScript 선택

cd vi_first_app





<<클래스형 컴포턴트 형식>>
함수에서 클래스로 변환하기

//반드시 패키지 import해야함
import React from 'react'
//경우에 따라 react-dom도 import해야함
import ReactDOM from 'react-dom/client'


1. React.Component를 확장하는 동일한 이름의 ES6 class를 생성한다.
2. render()라고 불리는 빈 메소드를 추가한다.
3. 함수의 내용을 render() 메소드 안으로 옮긴다.
4. render() 내용 안에 있는 props를 this.props로 변경합니다.
5. 남아있는 빈 함수 선언을 삭제한다.


<**형식>
{export default} class 클래스명 extends React.Component {
   render(){
      return(
         <>
            <h1 id="titleHTag">클래스형 컴포넌트</h1>
         </>
      )
   }
}
//export default 클래스명


MPA(Multi Page Application) : 다중 페이지 애플리케이션

SPA(Single Page Application) : 단일 페이지 애플리케이션


<<styling 과 css>>
1. 일반적인 (전역) 외부 css방법 : src/styles 폴더에 기술하고 _app.js에 모듈로 추가해준다.

2. 지역 모듈 css기법 : src/styles 폴더에 모듈명.module.css로 파일명을 만들어 준다. (**모듈명은 파스칼기법으로)
해당 css는 반드시 import하는 곳에서 사용할 때 css의 이름과 동일하게 기술해주어야 한다.
-----------------------예시)---------------------------------------------------------------
Todo.module.css안에 기술된 내용
.ContentList {
   margin: 10px;
   background-color: #555;
   color: #fff;
}

import stys from '../styles/Todo.module.css';
/*생략...*/

<ol>
   <li className={stys.ContentList}>항목1</li>
   /*생략...*/
</ol>
/*생략...*/
--------------------------------------------------------------------------------------------

3. 인라인 방법
-----------------------예시)---------------------------------------------------------------
<li style={{margin: 10+'px', backgroundColor: `#555`, color: `#fff`}}>항목1</li>
<li style={{margin: `10px`, backgroundColor: `#555`, color: `#fff`}}>항목1</li>
--------------------------------------------------------------------------------------------





state : 컴포넌트 내부에서 변경할 수 있는 값을 의미함.

클래스컴포넌트 : state필드로 상태값을 저장, setState()메소드로 상태값을 변경/설정 가능

rendering이나 DidMount()등등 자꾸만 2번 처리가 되는 이유 : 
next.config.mjs파일에 프로젝트의 reactStrictMode: true,	//리액트모드가 엄격모드로 처리되고 있어서임. reactStrictMode: false, 로 변경하고 재부팅하면 됨.

const nextConfig = {
   //reactStrictMode: true,
   reactStrictMode: false,
};
export default nextConfig;


리액트 훅(Hock)이란 : 16.8 버전에서 도입된 기능(내장함수)
리액트 컴포넌트 안에서만 사용할 수 있는 'use'로 사작하는 특별한 함수를 말한다.
**리액트 훅은 함수 컴포넌트 내에서만 호출할 수 있다.(클래스 컴포넌트 사용안됨)
**반드시 리액트 모듈에서 사용할 함수를 import해주어야 한다.

useState : 함수 컴포넌트 내에서 상태를 관리하는 함수.
useEffect : 부수 효과(side effects)를 다루는데 사용되며, 컴포넌트가 렌더링될 때마다 특정 작업을 수행할 수 있다.
useContext : 컨택스트(Context)를 사용하여 전역 데이터를 사용할 수 있게 해준다.
useReducer : useState와 비슷하지만, 더 복잡한 상태 관리를 할 때 사용된다.
useRef : DOM 요소나 다른 값에 대한 참조를 생성할 때 사용된다.
useSearchParam : get방식으로 보낸 데이터의 정보를 읽어올 수 있는 함수




--------------------------------------------------------------------------------------------
취업할때 w3에서 vue.js 공뷰
--------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------
//
//113
//필기
//


props : 부모컴포넌트에서 자식컴포넌트로 속성들이나 전달하는 정보들을 담고있는 내장객체



state : 컴포넌트 내부에서 변경할 수 있는 값을 의미함.

클래스컴포넌트 : state필드로 상태값을 저장, setState()메소드로 상태값을 변경/설정 가능

rendering이나 DidMount()등등 자꾸만 2번 처리가 되는 이유 : 
next.config.mjs파일에 프로젝트의 reactStrictMode: true,	//리액트모드가 엄격모드로 처리되고 있어서임. reactStrictMode: false, 로 변경하고 재부팅하면 됨.

const nextConfig = {
   //reactStrictMode: true,
   reactStrictMode: false,
};
export default nextConfig;


<<리액트 훅(Hock)이란 : 16.8 버전에서 도입된 기능(내장함수)>>
리액트 컴포넌트 안에서만 사용할 수 있는 'use'로 사작하는 특별한 함수를 말한다.
**리액트 훅은 함수 컴포넌트 내에서만 호출할 수 있다.(클래스 컴포넌트 사용안됨)
**반드시 리액트 모듈에서 사용할 함수를 import해주어야 한다.
예: import {useState, useEffect} from 'react'; 


useState : 함수 컴포넌트 내에서 상태를 관리하는 함수.
useEffect : 부수 효과(side effects)를 다루는데 사용되며, 컴포넌트가 렌더링될 때마다 특정 작업을 수행할 수 있다.
useContext : 컨택스트(Context)를 사용하여 전역 데이터를 사용할 수 있게 해준다.
useReducer : useState와 비슷하지만, 더 복잡한 상태 관리를 할 때 사용된다.
useRef : DOM 요소나 다른 값에 대한 참조를 생성할 때 사용된다.
useSearchParam : get방식으로 보낸 데이터의 정보를 읽어올 수 있는 함수


**useState함수 형식 : 해당 변수의 초기값을 설정하는 함수, 상태 정보를 담아서 전달하는 함수
const [state를저장할변수, state변수의setter메소드] = useState(초기값);
예: const [cnt, setCnt] = useState(0); 
=> cnt = 0;
=> setCnt(cnt) {
   this.cnt = cnt;
}

**useEffect함수 형식 : 
useEffect(() => {//부수 효과를 수행하는 코드}, [dependencies]);
- 첫번째 매개인자(부수 효과 함수) :
컴포넌트가 렌더링될 때마다 실행됨.
이 함수 내부에서 비동기 작업, 데이터 가져오기, 외부 API호출, 이벤트 리스너 등의 작업을 수행할 수 있다.

- 두번째 매개인자(의존성 배열(dependency array)) : [optional임]
이 배열에 포함된 값들이 변경될 때만 부수 효과 함수가 다시 실행된다.
만약 의존성 배열을 전달하지 않으면, 부수 효과 함수는 컴포넌트가 렌더링될 때마다 매번 실행된다.
빈 배열을 전달하면 컴포넌트가 마운트될 때 한번만 실행되며, 언마운트 시에 정리(clean-up) 작업을 수행할 수 있다.
--------------------------------------------------------------------------------------------

컴포넌트의 라이프 사이클
***클래스형 컴포넌트 : 
1. 마운트(Mount) : 리액트의 컴포넌트가 DOM에 삽입될 때, 즉 해당 컴포넌트가 브라우저의 화면에 나타날 때의 시점을 의미.
=> componentDidMount(){} 함수를 통해 마운트시점을 알리거나 마운트될 때의 실행해야하는 기능을 정의할 수 있다.

2. 업데이트(Update) : 컴포넌트의 상태가 update될 때의 시점을 의미
=> componentDidUpdate(prevProps, prevState){} 함수를 통해 해당 컴포넌트의 properties나 state의 갱신을 확인 할 수 있다.

3. 언마운트(Unmount) : 리액트 컴포넌트가 DOM에서 제거될 때, 즉 해당 컴포넌트가 화면에서 사라질 때의 시점을 의미
=> componentWillUnmount(){} 함수를 통해 해당 컴포넌트가 제거되기 전에 실행해야 하는 기능을 정의할 수 있다.


***함수형 컴포넌트 : 
마운트, 업데이트, 언마운트의 사이클을 똑같이 가지고 있으나, 클래스형 컴포넌트처럼 해당 시점의 함수를 사용할 수 없다.
따라서 해당 라이프 사이클에 대한 부분은 useEffect()함수를 이용하여 각 사이클 단계에 대한 설정을 할 수 있다.

1. 마운트(Mount) : useEffect(() => {}, []); //두번째 매개인자의 값을 []로만 전달하는 경우 마운트 시점에만 실행됨.

2. 업데이트(Update) : useEffect(() => {}, [state값인자]); //두번째 매개인자의 값을 state값인자로 전달하는 경우, 해당 state가 변경될 때마다 실행됨.

3. 언마운트(Unmount) : 마운트와 형식은 동일하나 첫번째 매개인자의 함수 안에 return (){} 함수를 기술하면 해당 함수는 언마운트 시점에 실행됨.
useEffect(() => {
   //마운트 시점에 실행되는 코드 기술 ...
   ...
   
   return () => {
      //언마운트 시점에 실행되는 코드 기술 ...
   }
}, []);
--------------------------------------------------------------------------------------------


전개 대입연산자(...): 
- 기존 객체나 배열을 수정하지 않고도 간단하게 새로운 객체나 배열을 만들 수 있다.
- 객체나 배열의 요소를 펼쳐서 새로운 객체나 배열을 생성하는 JavaScript의 문법이다.
- 대입 연산자 왼쪽에 사용됩니다.

전개대입연산자의 종류
1. 객체의 전개: 객체의 키-값 쌍을 펼쳐서 다른 객체에 추가한다.
예시: 
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
// obj2는 { a: 1, b: 2, c: 3 } 가 된다.


2. 배열의 전개: 배열의 요소를 펼쳐서 다른 배열에 추가한다.
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];
// arr2는 [1, 2, 3, 4, 5] 가 된다.


3. 함수 인자의 전개: 함수에 배열을 전달할 때 사용할 수 있다.
function myFunc(a, b, c) {
    console.log(a, b, c); // 1 2 3 출력
}
const args = [1, 2, 3];
myFunc(...args); 


4.전개대입: 객체나 배열의 요소를 다른 변수에 대입할 때 사용된다.
const { a, ...rest } = { a: 1, b: 2, c: 3 };
// a는 1, rest는 { b: 2, c: 3 }가 된다.

const [first, ...others] = [1, 2, 3, 4, 5];
// first는 1, others는 [2, 3, 4, 5] 가 된다.

=======================================================

**package.json에서 버전 명시 기호의 의미

^18.2.5 =>  ^기호는 두번째 기술된 값부터는 다른 버전이 허용 가능하다는 의미
예: 18.5.7 (O)  18.2.7 (O) 19.0.1 (X - 첫번째 버전이 다르므로 허용 안됨.)

~18.2.5 => ~기호는 세번째 기술된 값부터는 다른 버전이 허용 가능하다는 의미
예: 18.2.1 (O) 18.1.2(X -두번째 버전이 다르므로 허용 안됨.)

>18.2.5 => 18.2.5버전보다 큰 버전만 허용(18.2.5버전 미포함)
>=18.2.5 => 18.2.5이상 버전만 허용(18.2.5버전 포함)
<18.2.5 =>  18.2.5버전보다 작은 버전만 허용(18.2.5버전 미포함)
<=18.2.5 =>  18.2.5이하 버전만 허용(18.2.5버전 포함)

=======================================================

const [render, setRender] = useState(false);

useEffect(()=> setRender(true), []);
return render ? <Component {...pageProps} /> : null ;


=======================================================

리액트 라우터란
리액트 라우터(React Router)는 리액트 애플리케이션에서 클라이언트 측 라우팅을 구현하기 위한 라이브러리임.
**라우팅 : 사용자가 애플리케이션 내에서 다른 URL로 이동할 때 해당 URL에 맞는 컴포넌트를 렌더링하는 과정을 말함.
**이러한 방식으로 페이지 간 전환이 원활하게 이루어지며, URL이 변경됨에 따라 해당하는 컴포넌트가 자동으로 렌더링됨.
**애플리케이션의 상태를 URL과 동기화하여 북마크, 뒤로가기, 앞으로 가기 등의 브라우저 기능을 쉽게 활용할 수 있도록 해준다.

React Router의 주요 구성 요소
: <BrowserRouter>, <Routes>, <Switch>, <Link> 등이 있다. 
- <BrowserRouter> :  HTML5의 History API를 사용하여 브라우저의 URL을 관리함.

1. 반드시 먼저 리액트 라우터 라이브러리의 설치가 이루어져야 한다.
npm install react-router-dom
- "dependencies"에 "react-router-dom": "^6.23.1"버전이 설치됨.

2. _app.js파일의 App함수 변경하기
/*
페이지가 변경이 되려면 컴포넌트의 상태와 렌더링 시 특정 작업을 수행해야 하므로, useState, useEffect 훅을 import해준다.
useState: 함수 컴포넌트 내에서 상태를 관리하는 함수.
useEffect: 부수 효과(side effects)를 다루는데 사용되며, 컴포넌트가 렌더링될 때마다 특정 작업을 수행할 수 있다.
*/
import { useState, useEffect } from 'react';

export default function App({ Component, pageProps }) {
  const [render, setRender] = useState(false);
  useEffect(() => setRender(true), []);
  {/*... => 전개 대입변수: 해당 변수의 값을 새로운 객체나 배열로 받을 수 있다. */}
  return render ? <Component {...pageProps} /> : null;
}

3. 브라우저 라우터설정하기
1. react-router-dom모듈 추가하기
=> import { BrowserRouter, Routes, Route } from "react-router-dom"; 


**react-router-dom 6버전 미만에는 Switch태그를 사용하였으나, 6버전 이상부터는 Routes태그를 사용함.
**또한 6버전 이상에서는 Route태그의 컴포넌트 연결은 element속성을 사용하여 연결함.
- next프레임워크 애플리케이션인 경우: index.js파일에 설정할 것
2. return ()함수 안에 <BrowerRouter>설정하기
=> return (
    <BrowserRouter>
        <Header />
        <Routes>
          <Route path="/" exact element={<Main/>}/>
          <Route path="/customer" exact element={<CustomerList/>}/>
          <Route path="/about" exact element={<About/>}/>
        </Routes>
        <Footer />
    </BrowserRouter>
  );


- vite빌드 도구로 만든 애플리케이션이나 기존 리액트프로젝트인 경우 : main.jsx파일에 설정할 것
2. ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
        <Header />
        <Routes>
          <Route path="/" exact element={<Main/>}/>
          <Route path="/customer" exact element={<CustomerList/>}/>
          <Route path="/about" exact element={<About/>}/>
        </Routes>
        <Footer />
    </BrowserRouter>
  </React.StrictMode>,
)


**6미만버전 Switch태그 사용, Route태그의 컴포넌트 연결은 component속성을 사용하여 연결함.
<BrowserRouter>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route component={NotFound} />
      </Switch>
</BrowserRouter>

3. Link태그나 a태그등을 이용하여 페이지 이동을 할 수 있도록 설정하기
Link태그 : 페이지 이동이 일어나지 않고 재렌더링만 됨. 속도가 빠르고, 페이지 로딩이 없다.
<Link to='/about'>회사소개</Link>


a 태그 : 페이지 이동이 일어나고 렌더링에 대한 처리도 해야하므로 속도라 Link태그보다 느리다.
<a href='/about'>회사소개</a>
=======================================================

리액트 참고 사이트:
https://ko.legacy.reactjs.org/docs/state-and-lifecycle.html



const nextConfig = {
  reactStrictMode: true,
  /* next프레임워크로 라우터가 기본 설정되어 있기 때문에,
  리엑트 라우터를 사용하기 위해 아래와 같은 설정이 필요함. */
  // rewrites() 클라이언트 측 라우팅을 지원하는 싱글 페이지 애플리케이션(SPA)을 위해 서버 측에서 URL 경로를 재작성하는 방법을 제공한다.
  async rewrites(){
    return [
      {
        /*"source" : "/:any*" => 모든 URL에 대한 패턴을 설정 */
        "source" : "/:any*",
        /*"destination" : "/" => 모든 요청은 루트 경로로 보낸다는 의미 */
        "destination" : "/",
      },
    ];
  }
};

export default nextConfig;




<<스프링 부트>>

- 스프링 프레임워크와 스프링 부트의 차이점
둘다 자바기반은 맞지만 

프레임워크는 자바기반의 프레임워크이면서 내가 필요한 기능을 골라서 사용할수 있고
의존성주입이나 
포괄적으로 지원해주는 프레임워크

부트는 자바기반보다 스프링프레임워크 기반의 프레임워크
부트라는것은 프레임워크의 일부분
조금더 자동화, 조금더 편리한


@스프링부트란?
- 웹 프로그램을 쉽고 빠르게 만들 수 있도록 도와주는 자바 기반의 웹 프레임워크
- 스프링프레임워크 기반의 프레임워크 이기도 함
- 톰캣과 같은 WAS(Web Application Server)가 내장되어 있다.
- 설정이 편하고 쉬우며, 쿠키나 세션 처리, 로그인/로그아웃 처리, 권한 처리, 데이터베이스 처리 등
웹 프로그램을 위해 만들어야 할 기능이 미리 구현되어 있다.
- 보안이 뛰어나다.
    - SQL 인젝션은 악의적인 SQL을 주입하여 공격하는 방법이다.
    - XSS(cross-site scripting)는 자바스크립트를 삽입해 공격하는 방법이다.
    - CSRF(cross-site request forgery)는 위조된 요청을 보내는 공격 방법이다.
    - 클릭재킹(clickjacking)은 사용자의 의도하지 않은 클릭을 유도하는 공격 방법이다.


@빌드관리도구 : Maven과 Gradle
- 빌드란 소스코드 파일을 실행 가능한 소프트웨어 산출물로 만드는 과정을 말한다.
Maven이란 XML기반으로 자바라이브러리를 관리하는 빌드관리도구(라이브러리 형상관리 도구)임.
=> pom.xml
Gradle이란 JSON기반으로 자바라이브러리를 관리하는 빌드관리도구(라이브러리 형상관리 도구)이며, 
안드로이드 앱을 만들때 필요한 공식 빌드도구이다.
=> bundle.gradle (디펜던시 추가 후 실행작업 필요)


@스프링부트 설정 파일 : application.properties (src/main/resources)
- server설정, database설정, 인코딩설정 등


@롬복


@스프링부트 프로젝트 생성하기.




<스프링부트의 시큐리티 => 필터와 인터셉터가 합쳐진 기능>
































